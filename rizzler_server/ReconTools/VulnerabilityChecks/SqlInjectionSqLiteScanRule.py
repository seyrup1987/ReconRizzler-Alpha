# Filename: VulnerabilityChecks/SqlInjectionSqLiteScanRule.py

import asyncio
import html
import logging
import random
import re
import time
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Pattern, Set

import aiohttp

# Use the SQLiAlert and Tech from the generic SqlInjectionScanRule
from .SqlInjectionScanRule import SQLiAlert, Tech # CORRECTED: Was 'Alert'

# --- SQLite Specific Constants and Payloads ---
SQLITE_ONE_LINE_COMMENT = "--"
SQLITE_TIME_PAYLOAD_TEMPLATES = [
    "case randomblob(<<<<NUMBLOBBYTES>>>>) when not null then 1 else 1 end ",
    "' || case randomblob(<<<<NUMBLOBBYTES>>>>) when not null then '' else '' end || '", # Ensure string concatenation for string contexts
    "\" || case randomblob(<<<<NUMBLOBBYTES>>>>) when not null then '' else '' end || \"",
    f"case randomblob(<<<<NUMBLOBBYTES>>>>) when not null then 1 else 1 end {SQLITE_ONE_LINE_COMMENT}",
    f"' || case randomblob(<<<<NUMBLOBBYTES>>>>) when not null then '' else '' end {SQLITE_ONE_LINE_COMMENT}",
    f"\" || case randomblob(<<<<NUMBLOBBYTES>>>>) when not null then '' else '' end {SQLITE_ONE_LINE_COMMENT}",
    "<<<<ORIGINALVALUE>>>> AND case randomblob(<<<<NUMBLOBBYTES>>>>) when not null then 1 else 1 end ", # Assuming numeric original value context
    "<<<<ORIGINALVALUE>>>>' || case randomblob(<<<<NUMBLOBBYTES>>>>) when not null then '' else '' end || '",
    "<<<<ORIGINALVALUE>>>>\" || case randomblob(<<<<NUMBLOBBYTES>>>>) when not null then '' else '' end || \"",
    f"<<<<ORIGINALVALUE>>>> AND case randomblob(<<<<NUMBLOBBYTES>>>>) when not null then 1 else 1 end {SQLITE_ONE_LINE_COMMENT}",
    f"<<<<ORIGINALVALUE>>>>' || case randomblob(<<<<NUMBLOBBYTES>>>>) when not null then '' else '' end {SQLITE_ONE_LINE_COMMENT}",
    f"<<<<ORIGINALVALUE>>>>\" || case randomblob(<<<<NUMBLOBBYTES>>>>) when not null then '' else '' end {SQLITE_ONE_LINE_COMMENT}",
]
SQLITE_ERROR_PATTERNS = [
    re.compile(r"no such function: randomblob", re.IGNORECASE | re.DOTALL),
    re.compile(r"near \".+\": syntax error", re.IGNORECASE | re.DOTALL),
    re.compile(r"SELECTs to the left and right of UNION do not have the same number of result columns", re.IGNORECASE | re.DOTALL)
]
UNION_ATTACK_TEMPLATE = "<<<<VALUE>>>><<<<SYNTACTIC_PREVIOUS_STATEMENT_TYPE_CLOSER>>>><<<<SYNTACTIC_PREVIOUS_STATEMENT_CLAUSE_CLOSER>>>> <<<<UNIONSTATEMENT>>>> select <<<<SQLITE_VERSION_FUNCTION>>>><<<<UNIONADDITIONALCOLUMNS>>>><<<<SYNTACTIC_NEXT_STATEMENT_COMMENTER>>>>"
SYNTACTIC_PREVIOUS_STATEMENT_TYPE_CLOSERS = ["", "'", "\""]
SYNTACTIC_PREVIOUS_STATEMENT_CLAUSE_CLOSERS = ["", ")", "))", ")))"] # Reduced for brevity
SYNTACTIC_UNION_STATEMENTS = ["UNION"]
SQLITE_VERSION_FUNCTIONS = ["sqlite_version()", "sqlite_version()||''"] # Ensure string context for version
UNION_ADDITIONAL_COLUMNS = ["", ",null", ",null,null"] # Reduced
SYNTACTIC_NEXT_STATEMENT_COMMENTERS = [SQLITE_ONE_LINE_COMMENT]
SQLITE_VERSION_NUMBER_PATTERN = re.compile(r"[3-9]{1}\.[0-9]{1,2}(\.[0-9]{1,2}(\.[0-9]{1,2})?)?") # SQLite versions usually start with 3+
RANDOM_ALPHANUM_CHARS = "abcdefghijklmnopqrstuvwxyz0123456789"

class SqlInjectionSqLiteScanRule:
    tech_required: Set[str] = {"sqlite"} # Primary trigger

    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 active_scan_async_q: Optional[asyncio.Queue] = None, # Added
                 http_timeout: float = 20.0, # Increased default for time-based
                 # Rule-specific configurations
                 max_time_requests_per_payload_type: int = 3, # Reduced default
                 max_union_requests_total: int = 10,
                 enable_time_based: bool = True,
                 enable_union_based_version_detection: bool = False, # Keep default as False
                 min_blob_bytes_for_delay: int = 50000, # 50KB
                 max_blob_bytes_for_delay: int = 5000000, # 5MB (reduced from 100MB)
                 blob_multiplier_step: int = 5, # Reduced step
                 expected_delay_threshold_ms: int = 3000, # Lowered
                 parse_delay_difference_ms: int = 500, # Increased
                 incremental_delay_increases_for_alert: int = 2,
                 **kwargs # To accept other potential args from sqli_generic_config
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.active_scan_async_q = active_scan_async_q
        self.http_timeout = http_timeout
        
        self.max_time_requests_per_payload_type = max_time_requests_per_payload_type
        self.max_union_requests_total = max_union_requests_total
        self.enable_time_based = enable_time_based
        self.enable_union_based_version_detection = enable_union_based_version_detection
        self.min_blob_bytes_for_delay = min_blob_bytes_for_delay
        self.max_blob_bytes_for_delay = max_blob_bytes_for_delay
        self.blob_multiplier_step = blob_multiplier_step
        self.expected_delay_threshold_ms = expected_delay_threshold_ms
        self.parse_delay_difference_ms = parse_delay_difference_ms
        self.incremental_delay_increases_for_alert = incremental_delay_increases_for_alert
        
        self._time_requests_count = 0
        self._union_requests_count = 0
        self.logger.debug(f"SqlInjectionSqLiteScanRule initialized. Timeout: {self.http_timeout}s")

    async def _emit_alert(self, alert_obj: SQLiAlert): # Using SQLiAlert from generic rule
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_obj.as_dict()})
                self.logger.info(f"SQLiSqLite: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"SQLiSqLite: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"SQLiSqLite: Async queue not available. Alert not emitted: {alert_obj.name}")

    async def _send_request_async(
        self, session: aiohttp.ClientSession, method: str, url: str,
        headers: Dict[str, str], cookies: Dict[str, str],
        data: Optional[Any] = None, param_name_attacked: Optional[str] = None,
        payload_used: Optional[str] = None
    ) -> Tuple[Optional[Any], Optional[str], float]:
        start_time = time.monotonic()
        response_text: Optional[str] = None
        aio_response_status: Optional[int] = None
        aio_response_headers: Optional[Dict[str,str]] = None
        
        current_headers = headers.copy()
        if "User-Agent" not in current_headers:
             current_headers["User-Agent"] = "SQLiteScanner/1.0"

        log_payload_snippet = str(payload_used)[:50] + "..." if payload_used and len(payload_used) > 50 else payload_used
        self.logger.debug(f"SQLite Sending {method} to {url} (Param: {param_name_attacked}, Payload: {log_payload_snippet})")

        try:
            request_data_for_aiohttp = data
            if isinstance(data, dict) and method.upper() == "POST" and \
               (not current_headers.get("Content-Type") or "application/x-www-form-urlencoded" in current_headers.get("Content-Type","").lower()):
                form = aiohttp.FormData()
                for k, v_item in data.items(): form.add_field(k, str(v_item))
                request_data_for_aiohttp = form
            
            async with session.request(
                method.upper(), url, headers=current_headers, cookies=cookies, 
                data=request_data_for_aiohttp, timeout=aiohttp.ClientTimeout(total=self.http_timeout), 
                allow_redirects=False
            ) as resp:
                aio_response_status = resp.status
                aio_response_headers = dict(resp.headers)
                response_text = await resp.text(errors='replace')
            
            duration_ms = (time.monotonic() - start_time) * 1000
            self.logger.debug(f"SQLite Response from {url}: Status {aio_response_status}, Duration: {duration_ms:.0f}ms")

            @dataclass
            class DetachedResponse: status: int; headers: Dict[str, str]; text_content: Optional[str]
            return DetachedResponse(status=aio_response_status, headers=aio_response_headers, text_content=response_text), response_text, duration_ms
        except asyncio.TimeoutError:
            self.logger.warning(f"SQLite Timeout for {method} {url} (Payload: {log_payload_snippet})")
            return None, None, self.http_timeout * 1000
        except aiohttp.ClientError as e:
            self.logger.warning(f"SQLite AIOHTTP ClientError for {method} {url} (Payload: {log_payload_snippet}): {type(e).__name__} - {e}")
            return None, None, (time.monotonic() - start_time) * 1000
        except Exception as e:
            self.logger.error(f"SQLite Unexpected error for {method} {url} (Payload: {log_payload_snippet}): {e}", exc_info=True)
            return None, None, (time.monotonic() - start_time) * 1000

    def _build_request_params(self, base_url: str, injection_location: str, param_name: str, payload: str, original_value: str, method: str, original_form_data: Optional[Dict[str, str]] = None) -> Tuple[str, Optional[Dict[str, str]]]:
        target_url = base_url; request_data: Optional[Dict[str, str]] = None
        if injection_location == "url_params": # Matched with ActiveVulnerabilityCheck
            parsed_url = urllib.parse.urlparse(base_url)
            query_params = urllib.parse.parse_qs(parsed_url.query, keep_blank_values=True)
            query_params[param_name] = [payload]
            target_url = parsed_url._replace(query=urllib.parse.urlencode(query_params, doseq=True)).geturl()
        elif injection_location in ["form_data_post", "form_data_get"] :
            request_data = (original_form_data or {}).copy()
            request_data[param_name] = payload
            target_url = base_url
            if injection_location == "form_data_get" and method.upper() == "GET":
                parsed_url = urllib.parse.urlparse(base_url)
                query_params = urllib.parse.parse_qs(parsed_url.query, keep_blank_values=True)
                for k, v_item in request_data.items(): query_params[k] = [str(v_item)]
                target_url = parsed_url._replace(query=urllib.parse.urlencode(query_params, doseq=True)).geturl()
                request_data = None
        return target_url, request_data

    async def _test_sqlite_time_based(
        self, session: aiohttp.ClientSession, base_url: str,
        original_headers: Dict[str, str], original_cookies: Dict[str, str],
        injection_details: Dict[str, Any], baseline_duration_ms: float
    ) -> bool: # Returns True if alert emitted
        if not self.enable_time_based: return False
        # ... (logic from original file, modified to call self._emit_alert) ...
        # Replace alert creation with:
        # alert = SQLiAlert(...)
        # alert.attack_details = {"location": location, "param": param_name, ...}
        # await self._emit_alert(alert)
        # return True
        param_name = injection_details["param_name"]; original_value = injection_details["original_value"]; location = injection_details["location"]; method = injection_details.get("method", "GET"); all_form_fields = injection_details.get("all_form_fields")
        found_time_based_vuln = False
        for time_payload_template in SQLITE_TIME_PAYLOAD_TEMPLATES:
            if found_time_based_vuln or self._time_requests_count >= self.max_time_requests_per_payload_type * len(SQLITE_TIME_PAYLOAD_TEMPLATES): break
            sequential_increases = 0; detectable_delay_payload: Optional[str] = None; detectable_delay_duration_ms: float = 0; max_delay_payload: Optional[str] = None; max_delay_duration_ms: float = 0
            previous_delay_ms = baseline_duration_ms
            num_blobs = float(self.min_blob_bytes_for_delay) # Start as float for multiplication
            while num_blobs <= self.max_blob_bytes_for_delay:
                if found_time_based_vuln or sequential_increases >= self.incremental_delay_increases_for_alert or self._time_requests_count >= self.max_time_requests_per_payload_type * len(SQLITE_TIME_PAYLOAD_TEMPLATES) : break
                attack_payload = time_payload_template.replace("<<<<ORIGINALVALUE>>>>", original_value).replace("<<<<NUMBLOBBYTES>>>>", str(int(num_blobs)))
                current_headers = original_headers.copy(); current_cookies = original_cookies.copy()
                if location == "header": current_headers[param_name] = attack_payload
                elif location == "cookie": current_cookies[param_name] = attack_payload
                target_url, request_data = self._build_request_params(base_url, location, param_name, attack_payload, original_value, method, all_form_fields)
                if location in ["header", "cookie"]: target_url, request_data = base_url, None
                self._time_requests_count += 1
                attack_resp_obj, attack_resp_text, attack_duration_ms = await self._send_request_async(session, method, target_url, current_headers, current_cookies, request_data, param_name, attack_payload)
                if not attack_resp_obj: num_blobs *= self.blob_multiplier_step; continue
                if attack_resp_text:
                    for err_pattern in SQLITE_ERROR_PATTERNS:
                        match = err_pattern.search(attack_resp_text)
                        if match:
                            self.logger.info(f"SQLite Error-based (from Time Test): Pattern '{err_pattern.pattern}' matched for '{param_name}'")
                            alert = SQLiAlert(cwe_id=89, name="SQL Injection - SQLite Error Based (from Time Test)", description=f"SQLite error detected: {err_pattern.pattern}", uri=target_url, param=param_name, attack=attack_payload, evidence=match.group(0)[:200], rdbms=str(Tech.SQLite), injection_type="Error-based (SQLite specific)", confidence=3)
                            alert.attack_details = {"location": location, "param": param_name, "method": method}
                            await self._emit_alert(alert)
                            return True # Error found, stop time-based for this param
                random_str_payload = ''.join(random.choices(RANDOM_ALPHANUM_CHARS, k=len(attack_payload)))
                rand_current_headers = original_headers.copy(); rand_current_cookies = original_cookies.copy()
                if location == "header": rand_current_headers[param_name] = random_str_payload
                elif location == "cookie": rand_current_cookies[param_name] = random_str_payload
                rand_target_url, rand_request_data = self._build_request_params(base_url, location, param_name, random_str_payload, original_value, method, all_form_fields)
                if location in ["header", "cookie"]: rand_target_url, rand_request_data = base_url, None
                self._time_requests_count += 1
                _, _, parse_delay_check_duration_ms = await self._send_request_async(session, method, rand_target_url, rand_current_headers, rand_current_cookies, rand_request_data, param_name, random_str_payload)
                is_parse_time_equivalent = abs(attack_duration_ms - parse_delay_check_duration_ms) < self.parse_delay_difference_ms
                self.logger.debug(f"SQLite Time Test: blobs={int(num_blobs)}, attack_T={attack_duration_ms:.0f}ms, prev_T={previous_delay_ms:.0f}ms, parse_T={parse_delay_check_duration_ms:.0f}ms. ParseEquiv={is_parse_time_equivalent}")
                if attack_duration_ms > previous_delay_ms and not is_parse_time_equivalent and (attack_duration_ms - previous_delay_ms > self.parse_delay_difference_ms / 2): # Ensure increase is significant
                    if max_delay_payload is None or attack_duration_ms > max_delay_duration_ms : max_delay_payload = attack_payload; max_delay_duration_ms = attack_duration_ms
                    sequential_increases += 1
                    if detectable_delay_payload is None: detectable_delay_payload = attack_payload; detectable_delay_duration_ms = attack_duration_ms
                else: sequential_increases = 0; detectable_delay_payload = None; detectable_delay_duration_ms = 0
                previous_delay_ms = attack_duration_ms
                if attack_duration_ms > self.expected_delay_threshold_ms * 5: break 
                num_blobs *= self.blob_multiplier_step
            if sequential_increases >= self.incremental_delay_increases_for_alert and detectable_delay_payload:
                self.logger.info(f"SQLite Time-based SQLi: Param '{param_name}' vulnerable.")
                found_time_based_vuln = True
                alert = SQLiAlert(cwe_id=89, name="SQL Injection - SQLite Time Based", description="Time-based SQLite SQLi detected.", uri=target_url, param=param_name, attack=max_delay_payload or detectable_delay_payload, evidence=f"Baseline: {baseline_duration_ms:.0f}ms. Max delay: {max_delay_duration_ms:.0f}ms.", rdbms=str(Tech.SQLite), injection_type="Time-based (SQLite randomblob)", confidence=2)
                alert.attack_details = {"location": location, "param": param_name, "method": method}
                await self._emit_alert(alert)
                return True
        return False

    async def _test_sqlite_union_based_version_detection(self, session: aiohttp.ClientSession, base_url: str, original_headers: Dict[str, str], original_cookies: Dict[str, str], injection_details: Dict[str, Any], baseline_resp_text: Optional[str]) -> bool: # Returns True if alert emitted
        if not self.enable_union_based_version_detection: return False
        # ... (logic from original file, modified to call self._emit_alert) ...
        # Replace alert creation with:
        # alert = SQLiAlert(...)
        # alert.attack_details = {"location": location, "param": param_name, ...}
        # await self._emit_alert(alert)
        # return True
        param_name = injection_details["param_name"]; original_value = injection_details["original_value"]; location = injection_details["location"]; method = injection_details.get("method", "GET"); all_form_fields = injection_details.get("all_form_fields")
        candidate_values_for_injection = ["", original_value]
        all_union_attacks = []
        for val_prefix in candidate_values_for_injection:
            for type_closer in SYNTACTIC_PREVIOUS_STATEMENT_TYPE_CLOSERS:
                for clause_closer in SYNTACTIC_PREVIOUS_STATEMENT_CLAUSE_CLOSERS:
                    for union_stmt in SYNTACTIC_UNION_STATEMENTS:
                        for version_func in SQLITE_VERSION_FUNCTIONS:
                            for add_cols in UNION_ADDITIONAL_COLUMNS:
                                for commenter in SYNTACTIC_NEXT_STATEMENT_COMMENTERS:
                                    attack = UNION_ATTACK_TEMPLATE.replace("<<<<VALUE>>>>", val_prefix).replace("<<<<SYNTACTIC_PREVIOUS_STATEMENT_TYPE_CLOSER>>>>", type_closer).replace("<<<<SYNTACTIC_PREVIOUS_STATEMENT_CLAUSE_CLOSER>>>>", clause_closer).replace("<<<<UNIONSTATEMENT>>>>", union_stmt).replace("<<<<SQLITE_VERSION_FUNCTION>>>>", version_func).replace("<<<<UNIONADDITIONALCOLUMNS>>>>", add_cols).replace("<<<<SYNTACTIC_NEXT_STATEMENT_COMMENTER>>>>", commenter)
                                    all_union_attacks.append(attack)
        attacks_to_try = random.sample(all_union_attacks, min(len(all_union_attacks), self.max_union_requests_total))
        self.logger.debug(f"SQLite UNION: Trying up to {len(attacks_to_try)} payloads for '{param_name}'.")
        for attack_payload in attacks_to_try:
            if self._union_requests_count >= self.max_union_requests_total: break
            current_headers = original_headers.copy(); current_cookies = original_cookies.copy()
            if location == "header": current_headers[param_name] = attack_payload
            elif location == "cookie": current_cookies[param_name] = attack_payload
            target_url, request_data = self._build_request_params(base_url, location, param_name, attack_payload, original_value, method, all_form_fields)
            if location in ["header", "cookie"]: target_url, request_data = base_url, None
            self._union_requests_count += 1
            attack_resp_obj, attack_resp_text, _ = await self._send_request_async(session, method, target_url, current_headers, current_cookies, request_data, param_name, attack_payload)
            if not (attack_resp_obj and attack_resp_text): continue
            version_match = SQLITE_VERSION_NUMBER_PATTERN.search(attack_resp_text)
            if version_match:
                sqlite_version = version_match.group(0)
                if baseline_resp_text is None or not re.search(re.escape(sqlite_version), baseline_resp_text):
                    self.logger.info(f"SQLite UNION Version Detection: Found version '{sqlite_version}' for '{param_name}'")
                    alert = SQLiAlert(cwe_id=89, name=f"SQL Injection - SQLite Version Detected (UNION)", description=f"SQLite version ({sqlite_version}) identified via UNION SQLi.", uri=target_url, param=param_name, attack=attack_payload, evidence=f"Detected SQLite Version: {sqlite_version}", rdbms=str(Tech.SQLite), injection_type="UNION-based (Version Detection)", confidence=3)
                    alert.attack_details = {"location": location, "param": param_name, "method": method}
                    await self._emit_alert(alert)
                    return True
            for err_pattern in SQLITE_ERROR_PATTERNS:
                match = err_pattern.search(attack_resp_text)
                if match and (baseline_resp_text is None or not err_pattern.search(baseline_resp_text)):
                    if "UNION" in err_pattern.pattern.upper() or "COLUMN" in err_pattern.pattern.upper() :
                        self.logger.info(f"SQLite UNION Error: Pattern '{err_pattern.pattern}' matched for '{param_name}'")
                        alert = SQLiAlert(cwe_id=89, name="SQL Injection - SQLite UNION Based Error", description=f"UNION-related SQLite error: {err_pattern.pattern}", uri=target_url, param=param_name, attack=attack_payload, evidence=match.group(0)[:200], rdbms=str(Tech.SQLite), injection_type="UNION-based (Error)", confidence=3)
                        alert.attack_details = {"location": location, "param": param_name, "method": method}
                        await self._emit_alert(alert)
                        return True
        return False

    async def scan(
        self,
        original_url: str,
        aiohttp_session: aiohttp.ClientSession,
        injection_details: Dict[str, Any],
        original_headers: Dict[str, str],
        original_cookies: Dict[str, str],
        original_page_content_for_baseline_errors: Optional[str] = None,
        # Other common args
        base_app_url: Optional[str] = None,
        html_content: Optional[str] = None, # Can be same as original_page_content_for_baseline_errors
        worker_ident: Optional[str] = "SQLiSqLiteScan",
        page_specific_technologies: Optional[List[str]] = None,
        service_type_hint: Optional[str] = None,
    ) -> None: # Changed return type
        self._time_requests_count = 0
        self._union_requests_count = 0
        
        param_name = injection_details["param_name"]
        location = injection_details["location"]
        method = injection_details.get("method", "GET")
        # Use form_action_url if provided, otherwise original_url for tests
        base_url_for_tests = injection_details.get("action_url", original_url)

        self.logger.info(f"[{worker_ident}] Starting SQLite SQLi scan for param: '{param_name}' at location '{location}' on URL: {base_url_for_tests}")

        # Fetch baseline for time-based and error diffing in UNION
        original_target_url_for_baseline, original_request_data_for_baseline = self._build_request_params(
            base_url_for_tests, location, param_name, 
            injection_details["original_value"], injection_details["original_value"], 
            method, injection_details.get("all_form_fields")
        )
        baseline_headers_for_req = original_headers.copy(); baseline_cookies_for_req = original_cookies.copy()
        if location == "header": baseline_headers_for_req[param_name] = injection_details["original_value"]; original_target_url_for_baseline, original_request_data_for_baseline = base_url_for_tests, None
        elif location == "cookie": baseline_cookies_for_req[param_name] = injection_details["original_value"]; original_target_url_for_baseline, original_request_data_for_baseline = base_url_for_tests, None
        
        self.logger.debug(f"[{worker_ident}] SQLite Scan: Fetching baseline for '{param_name}'.")
        baseline_resp_obj, baseline_resp_text, baseline_duration_ms = await self._send_request_async(
            aiohttp_session, method, original_target_url_for_baseline,
            baseline_headers_for_req, baseline_cookies_for_req, original_request_data_for_baseline
        )

        if baseline_resp_obj is None:
            self.logger.warning(f"[{worker_ident}] SQLite Scan: Could not fetch baseline for '{param_name}'. Time-based checks might be unreliable.")
            baseline_duration_ms = self.http_timeout * 1000 
        
        if baseline_duration_ms > self.expected_delay_threshold_ms: # Re-fetch if too slow
            self.logger.debug(f"[{worker_ident}] SQLite Scan: Baseline duration {baseline_duration_ms:.0f}ms high. Re-fetching.")
            _, _, baseline_duration_ms_retry = await self._send_request_async(aiohttp_session, method, original_target_url_for_baseline, baseline_headers_for_req, baseline_cookies_for_req, original_request_data_for_baseline)
            if baseline_duration_ms_retry < baseline_duration_ms: baseline_duration_ms = baseline_duration_ms_retry
            if baseline_duration_ms > self.expected_delay_threshold_ms: self.logger.warning(f"[{worker_ident}] SQLite Scan: Baseline duration {baseline_duration_ms:.0f}ms still high for '{param_name}'.")

        if self.enable_time_based:
            await self._test_sqlite_time_based(aiohttp_session, base_url_for_tests, original_headers, original_cookies, injection_details, baseline_duration_ms)
        
        # Only run UNION if no high confidence alert (e.g. error from time test) was already found
        # This check needs to be more robust if alerts are emitted async. For now, simple sequential.
        # A better way would be a flag like self._found_high_confidence_for_param
        if self.enable_union_based_version_detection:
             await self._test_sqlite_union_based_version_detection(aiohttp_session, base_url_for_tests, original_headers, original_cookies, injection_details, baseline_resp_text)
            
        self.logger.info(f"[{worker_ident}] SQLite SQLi scan for param: '{param_name}' completed.")