# DirectoryBrowsingScanRule.py
import asyncio
import re
from typing import List, Dict, Pattern, Optional
from urllib.parse import urljoin, urlparse

import aiohttp  # For asynchronous HTTP requests
from bs4 import BeautifulSoup

# Constants
MESSAGE_PREFIX = "ascanrules.directorybrowsing."
ALERT_TAGS: Dict[str, str] = {
    "OWASP_2021_A01_BROKEN_AC": "",
    "OWASP_2017_A05_BROKEN_AC": "",
    "PolicyTag.API": "",
    "PolicyTag.QA_STD": "",
    "PolicyTag.QA_FULL": "",
    "PolicyTag.PENTEST": "",
}

# Regex Patterns (flags=re.IGNORECASE for case-insensitive matching)
PATTERN_IIS: Pattern[str] = re.compile(r"Parent Directory", re.IGNORECASE)
PATTERN_APACHE: Pattern[str] = re.compile(
    r"\bDirectory Listing\b.*(Tomcat|Apache)", re.IGNORECASE
)
PATTERN_GENERAL_DIR1: Pattern[str] = re.compile(r"\bDirectory\b", re.IGNORECASE)
PATTERN_GENERAL_DIR2: Pattern[str] = re.compile(r"[\s<]+IMG\s*=", re.IGNORECASE)
PATTERN_GENERAL_PARENT: Pattern[str] = re.compile(
    r"Parent directory", re.IGNORECASE
)


class Alert:
    """
    Represents a security alert.  This is a simplified version for demonstration.
    """

    RISK_INFO = 1
    RISK_LOW = 2
    RISK_MEDIUM = 3
    RISK_HIGH = 4

    CONFIDENCE_LOW = 1
    CONFIDENCE_MEDIUM = 2
    CONFIDENCE_HIGH = 3

    def __init__(
        self,
        name: str,
        description: str,
        solution: str,
        reference: str,
        risk: int,
        confidence: int,
        attack: str,
        evidence: str,
        cwe_id: int,
        wasc_id: int,
        alert_tags: Dict[str, str],
    ):
        self.name = name
        self.description = description
        self.solution = solution
        self.reference = reference
        self.risk = risk
        self.confidence = confidence
        self.attack = attack
        self.evidence = evidence
        self.cwe_id = cwe_id
        self.wasc_id = wasc_id
        self.alert_tags = alert_tags

    def __str__(self):
        return f"Alert: {self.name} - Risk: {self.risk} - Confidence: {self.confidence}"


class DirectoryBrowsingScanRule:
    """
    Asynchronously scans a URL for directory browsing vulnerabilities.
    """

    def __init__(
        self,
        scope_technologies: List[str] = None,
        message_prefix: str = MESSAGE_PREFIX,
        alert_tags: Dict[str, str] = ALERT_TAGS,
        parent_logger=None,
    ):
        """
        Initializes the scanner with configurations.

        Args:
            scope_technologies: List of technologies to consider in scope (e.g., "IIS", "Apache").
            message_prefix: Prefix for internationalized messages.
            alert_tags: Tags associated with the alert.
            parent_logger: Logger from the parent class.
        """
        self.scope_technologies = scope_technologies or []
        self.message_prefix = message_prefix
        self.alert_tags = alert_tags
        self.logger = parent_logger  # Use the parent logger if available, else create a new one
        if not self.logger:
            import logging

            self.logger = logging.getLogger(__name__)
            self.logger.setLevel(logging.INFO)  # Or whatever default level you want

    def scan(self, url: str, content: str, headers: Dict[str, str]) -> Optional[Alert]:
        """
        Performs the directory browsing scan.

        Args:
            url: The URL to scan.
            content: The content of the page as a string.
            headers: The HTTP headers of the response.

        Returns:
            An Alert object if a directory browsing vulnerability is found, otherwise None.
        """
        result = False
        confidence = Alert.CONFIDENCE_MEDIUM
        evidence = ""

        try:
            if not content:
                self.logger.debug(f"No content to scan for {url}")
                return None

            if (
                "IIS" in self.scope_technologies
                and (match := self._match_body_pattern(content, PATTERN_IIS))
                is not None
            ):
                result = True
                evidence = match
            elif (
                any(tech in self.scope_technologies for tech in ["Apache", "Tomcat"])
                and (match := self._match_body_pattern(content, PATTERN_APACHE))
                is not None
            ):
                result = True
                evidence = match
            elif (match := self._match_body_pattern(content, PATTERN_GENERAL_PARENT)) is not None:
                result = True
                confidence = Alert.CONFIDENCE_LOW
                evidence = match
            elif (match1 := self._match_body_pattern(content, PATTERN_GENERAL_DIR1)) is not None:
                if self._match_body_pattern(content, PATTERN_GENERAL_DIR2) is not None:
                    result = True
                    confidence = Alert.CONFIDENCE_LOW
                    evidence = match1  # Only include the first match in evidence

        except Exception as e:
            self.logger.error(f"An error occurred during the scan for {url}: {e}")
            return None

        if result:
            return Alert(
                name="Directory Browsing Vulnerability",
                description="The web server is configured to allow directory browsing.",
                solution="Disable directory browsing on the web server.",
                reference="https://owasp.org/www-project-top-ten/",
                risk=Alert.RISK_MEDIUM,
                confidence=confidence,
                attack=url,
                evidence=evidence,
                cwe_id=548,
                wasc_id=48,
                alert_tags=self.alert_tags,
            )
        return None

    def _match_body_pattern(self, body: str, pattern: Pattern[str]) -> Optional[str]:
        """
        Checks if a pattern exists in the body.

        Args:
            body: The body of the HTTP response.
            pattern: The regex pattern to search for.

        Returns:
            The matched string if the pattern is found, otherwise None.
        """
        match = pattern.search(body)
        if match:
            return match.group(0)
        return None