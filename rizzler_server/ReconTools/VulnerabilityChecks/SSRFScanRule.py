# Filename: VulnerabilityChecks/SSRFScanRule.py

import asyncio
import logging
import random
import re
import time
import uuid # For unique interaction IDs
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Set

import aiohttp

# --- Alert Definition ---
@dataclass
class SSRFAlert:
    # Non-default fields first
    cwe_id: int
    name: str
    description: str
    uri: str         # The URL of the application endpoint tested
    param: str       # The parameter/injection point tested
    attack: str      # The payload URL sent
    evidence: str    # Description of how SSRF was detected (OAST, error, content)

    # Default fields
    wasc_id: int = 2   # WASC-02: Insufficient Input Validation (related, SSRF is a specific type)
    other_info: str = ""  # e.g., OAST interaction ID, specific error message
    solution: str = (
        "Validate all user-supplied input that is used to construct URLs for server-side requests. "
        "Use an allow-list (whitelist) of permitted domains, protocols, and ports. "
        "Disable unused URL schemes. "
        "Ensure that the server-side HTTP client does not follow redirects by default, or validates redirect targets. "
        "Implement network segmentation to prevent the server from accessing sensitive internal resources."
    )
    reference: str = (
        "CWE-918: https://cwe.mitre.org/data/definitions/918.html\n"
        "OWASP SSRF Prevention Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"
    )
    risk: int = 4  # High
    confidence: int = 1 # Low by default, increased by evidence type
    oast_interaction_id: Optional[str] = None
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A10": "Server-Side Request Forgery (SSRF)",
        "WSTG_V42_INPV_19": "Testing_for_Server_Side_Request_Forgery",
    })
    attack_details: Dict[str, Any] = field(default_factory=dict) # Added for consistency

    def as_dict(self) -> Dict[str, Any]:
        tags = self.alert_tags.copy()
        if self.oast_interaction_id:
            tags["OAST_Interaction"] = "Detected"
        
        return {
            "vulnerability_type": "SSRF",
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack,
            "injection_point_info": f"Location: {self.attack_details.get('location', 'N/A')}, Parameter: {self.param}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": tags,
            "other_info": self.other_info
        }

# --- SSRF Specific Payloads and Targets ---
COMMON_INTERNAL_TARGETS = {
    "localhost_http": "http://127.0.0.1/", "localhost_https": "https://127.0.0.1/",
    "localhost_loopback_http": "http://localhost/",
    "aws_metadata": "http://169.254.169.254/latest/meta-data/",
    "aws_userdata": "http://169.254.169.254/latest/user-data/",
    "gcp_metadata_legacy": "http://metadata.google.internal/computeMetadata/v1beta1/",
    "gcp_metadata": "http://metadata.google.internal/computeMetadata/v1/?recursive=true",
    "azure_metadata": "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
    "digitalocean_metadata": "http://169.254.169.254/metadata/v1.json",
}
SSRF_ERROR_PATTERNS = [
    re.compile(r"connect(?:ion)? refused", re.IGNORECASE), re.compile(r"failed to connect", re.IGNORECASE),
    re.compile(r"could not resolve host", re.IGNORECASE), re.compile(r"timeout|time out|timed out", re.IGNORECASE),
    re.compile(r"no route to host", re.IGNORECASE), re.compile(r"network is unreachable", re.IGNORECASE),
    re.compile(r"javax\.net\.ssl\.SSLHandshakeException", re.IGNORECASE),
    re.compile(r"java\.net\.UnknownHostException", re.IGNORECASE), re.compile(r"java\.net\.ConnectException", re.IGNORECASE),
    re.compile(r"System\.Net\.Sockets\.SocketException", re.IGNORECASE),
]
METADATA_CONTENT_PATTERNS = {
    "aws_metadata": [re.compile(r"ami-id|instance-id|public-ipv4", re.IGNORECASE)],
    "gcp_metadata": [re.compile(r"instance/|project/", re.IGNORECASE), re.compile(r"\"items\":", re.IGNORECASE)],
    "azure_metadata": [re.compile(r"compute", re.IGNORECASE), re.compile(r"vmId", re.IGNORECASE)],
}

class SSRFScanRule:
    tech_required: Set[str] = set() # SSRF is generally agnostic

    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 oast_base_url: Optional[str] = None,
                 http_timeout: float = 15.0,
                 internal_targets_to_test: Optional[Dict[str,str]] = None,
                 max_oast_payloads_per_point: int = 3,
                 active_scan_async_q: Optional[asyncio.Queue] = None # Added
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.oast_base_url = self._normalize_oast_url(oast_base_url) if oast_base_url else None
        self.http_timeout = http_timeout
        self.internal_targets = internal_targets_to_test or COMMON_INTERNAL_TARGETS
        self.max_oast_payloads_per_point = max_oast_payloads_per_point
        self.active_scan_async_q = active_scan_async_q # Store it

        if not self.oast_base_url:
            self.logger.warning("SSRFScanRule initialized without an OAST base URL. Blind SSRF detection will be limited.")
        self.logger.debug(f"SSRFScanRule initialized. OAST: {self.oast_base_url}, Timeout: {self.http_timeout}s")

    async def _emit_alert(self, alert_obj: SSRFAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({
                    "type": "active_scan_alert", "alert": alert_obj.as_dict()
                })
                self.logger.info(f"SSRFScan: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"SSRFScan: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"SSRFScan: Async queue not available. Alert not emitted: {alert_obj.name}")

    def _normalize_oast_url(self, url: str) -> str:
        parsed = urllib.parse.urlparse(url)
        return parsed.netloc if parsed.netloc else parsed.path.split('/')[0]

    def _generate_oast_payload(self, unique_id: str, scheme: str = "http") -> str:
        if not self.oast_base_url:
            return "oast_server_not_configured_error"
        return f"{scheme}://{unique_id}.{self.oast_base_url}/ssrf_hit"

    def _generate_bypass_payloads(self, base_payload: str) -> List[str]:
        payloads = [base_payload]
        parsed_base = urllib.parse.urlparse(base_payload)
        hostname = parsed_base.hostname
        if hostname:
            payloads.append(base_payload.replace(".", "%2E").replace("/", "%2F")) # Basic URL encoding
            if re.match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", hostname):
                try:
                    ip_parts = list(map(int, hostname.split('.')))
                    decimal_ip = (ip_parts[0] << 24) + (ip_parts[1] << 16) + (ip_parts[2] << 8) + ip_parts[3]
                    payloads.append(base_payload.replace(hostname, str(decimal_ip)))
                except ValueError: pass # If IP parts are not int
        return list(set(payloads))

    async def _send_ssrf_attempt_async(
        self, session: aiohttp.ClientSession, method: str, url: str,
        headers: Optional[Dict[str, str]], cookies: Optional[Dict[str, str]],
        data: Optional[aiohttp.FormData] = None, json_data: Optional[Dict[str, Any]] = None,
        text_data: Optional[str] = None,
        attacked_param_name: Optional[str] = None, ssrf_payload_sent: Optional[str] = None
    ) -> Tuple[Optional[Any], Optional[str], float, Optional[str]]:
        start_time = time.monotonic()
        response_text: Optional[str] = None
        error_type_str: Optional[str] = None
        detached_resp_obj = None
        
        current_headers = (headers or {}).copy()
        if "User-Agent" not in current_headers:
             current_headers["User-Agent"] = random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            ])
        
        log_payload_snippet = str(ssrf_payload_sent)[:100] + "..." if ssrf_payload_sent and len(ssrf_payload_sent) > 100 else ssrf_payload_sent
        self.logger.debug(f"SSRF Scan: Sending {method} to {url} (Param: {attacked_param_name}, SSRF Payload: {log_payload_snippet})")
        
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            request_kwargs: Dict[str, Any] = {
                "headers": current_headers, "timeout": timeout, "allow_redirects": False
            }
            if cookies: request_kwargs["cookies"] = cookies # Pass cookies if any
            if data: request_kwargs["data"] = data
            if json_data: request_kwargs["json"] = json_data
            if text_data: request_kwargs["data"] = text_data

            async with session.request(method.upper(), url, **request_kwargs) as resp:
                try:
                    response_text = await resp.text(errors='replace')
                except Exception as e_read:
                    self.logger.debug(f"SSRF Scan: Error reading response body from {url}: {e_read}")
                
                @dataclass
                class DetachedResponse: status: int; headers: Dict[str, str]; text_content: Optional[str]
                detached_resp_obj = DetachedResponse(status=resp.status, headers=dict(resp.headers), text_content=response_text)
        
        except asyncio.TimeoutError: error_type_str = "TimeoutError"
        except aiohttp.ClientConnectionError as e: error_type_str = type(e).__name__
        except aiohttp.ClientError as e: error_type_str = type(e).__name__
        except Exception as e: error_type_str = type(e).__name__
            
        if error_type_str:
            self.logger.debug(f"SSRF Scan: Request for {method} {url} (SSRF Payload: {log_payload_snippet}) resulted in {error_type_str}.")
            
        return detached_resp_obj, response_text, (time.monotonic() - start_time) * 1000, error_type_str

    def _check_response_for_ssrf_indicators(
        self, response_obj: Optional[Any], response_text: Optional[str],
        error_type: Optional[str], ssrf_payload_key: str,
        oast_unique_id: Optional[str] = None
    ) -> Tuple[Optional[str], int, int]:
        if ssrf_payload_key == "oast" and oast_unique_id:
            return f"OAST interaction payload sent. Check OAST server for ID: {oast_unique_id}", SSRFAlert.confidence.fget(SSRFAlert(0,"","","","","")).LOW +1, 0 # type: ignore

        if error_type:
            return f"Network error '{error_type}' when server tried to access '{ssrf_payload_key}'.", SSRFAlert.confidence.fget(SSRFAlert(0,"","","","","")).LOW, 0 # type: ignore
        if response_text:
            for pattern in SSRF_ERROR_PATTERNS:
                if pattern.search(response_text):
                    return f"Error pattern '{pattern.pattern}' matched in response when targeting '{ssrf_payload_key}'.", SSRFAlert.confidence.fget(SSRFAlert(0,"","","","","")).LOW, 0 # type: ignore

        if response_text and ssrf_payload_key in METADATA_CONTENT_PATTERNS:
            for pattern in METADATA_CONTENT_PATTERNS[ssrf_payload_key]:
                if pattern.search(response_text):
                    return f"Content pattern '{pattern.pattern}' for '{ssrf_payload_key}' matched in response.", SSRFAlert.confidence.fget(SSRFAlert(0,"","","","","")).LOW +2, 1 # type: ignore
        return None, 0, 0

    def _prepare_app_request_with_ssrf_payload(
        self, app_url: str, location: str, param_name: str, ssrf_payload: str,
        original_form_data: Optional[Dict[str, Any]],
        original_json_data: Optional[Dict[str, Any]], # This should be the full original JSON body
        original_text_data: Optional[str]
    ) -> Tuple[str, Optional[aiohttp.FormData], Optional[Dict[str, Any]], Optional[str]]:
        current_app_url = app_url
        form_data_to_send = None
        json_data_to_send = None
        text_data_to_send = None

        if location == "url_params": # Corrected from "url_query"
            parsed_url = urllib.parse.urlparse(app_url)
            query_params = urllib.parse.parse_qs(parsed_url.query, keep_blank_values=True)
            query_params[param_name] = [ssrf_payload]
            new_query = urllib.parse.urlencode(query_params, doseq=True)
            current_app_url = parsed_url._replace(query=new_query).geturl()
        elif location == "form_data_post" or location == "form_data_get":
            form_data_dict = (original_form_data or {}).copy()
            form_data_dict[param_name] = ssrf_payload
            if location == "form_data_get":
                parsed_url = urllib.parse.urlparse(app_url)
                query_params = urllib.parse.parse_qs(parsed_url.query, keep_blank_values=True)
                for k, v_list_val in urllib.parse.parse_qs(urllib.parse.urlencode(form_data_dict, doseq=True)).items():
                    query_params[k] = v_list_val
                new_query = urllib.parse.urlencode(query_params, doseq=True)
                current_app_url = parsed_url._replace(query=new_query).geturl()
            else: # POST
                form_data_to_send = aiohttp.FormData()
                for k,v in form_data_dict.items():
                    form_data_to_send.add_field(k, str(v))

        elif location == "request_body_json_fields": # Assuming param_name is the key to modify
            json_data_to_send = (original_json_data or {}).copy()
            if isinstance(json_data_to_send, dict):
                # This is simplified. For nested paths like "user.profile.url", more complex logic is needed.
                # Assuming param_name is a top-level key or a special marker like "_JSON_BODY_".
                if param_name == "_JSON_BODY_": # Replace entire body if it's the marker
                    try:
                        # If ssrf_payload is a URL, it's not valid JSON.
                        # This injection point type implies the *value* of a field is a URL.
                        # The SSRF payload itself (a URL) should be the value of a field.
                        # This logic needs rethinking if param_name is "_JSON_BODY_".
                        # For now, let's assume param_name is an actual field name.
                        self.logger.warning("SSRF: _JSON_BODY_ injection for JSON not fully implemented, needs field path.")
                    except json.JSONDecodeError:
                         self.logger.warning(f"SSRF: SSRF payload '{ssrf_payload}' is not valid JSON for _JSON_BODY_ injection.")
                else: # param_name is a field name
                    json_data_to_send[param_name] = ssrf_payload
            else:
                self.logger.warning(f"SSRF: Cannot inject into JSON body for param '{param_name}' as original body is not a dict.")
        elif location == "request_body_xml_raw":
            if original_text_data and param_name in original_text_data: # param_name is placeholder
                text_data_to_send = original_text_data.replace(param_name, ssrf_payload)
            else: # Fallback: send payload as raw body
                text_data_to_send = ssrf_payload
        elif location == "request_body_text_raw":
            text_data_to_send = ssrf_payload # Replace entire text body
        # Header and Cookie locations are handled by modifying headers/cookies in the request call directly.
        return current_app_url, form_data_to_send, json_data_to_send, text_data_to_send

    async def scan(
        self,
        original_url: str, # The application's vulnerable endpoint URL
        aiohttp_session: aiohttp.ClientSession,
        injection_details: Dict[str, Any],
        original_headers: Dict[str, str],
        original_cookies: Dict[str, str],
        # Other common args for compatibility
        base_app_url: Optional[str] = None,
        html_content: Optional[str] = None,
        worker_ident: Optional[str] = "SSRFScan",
        page_specific_technologies: Optional[List[str]] = None,
        service_type_hint: Optional[str] = None,
    ) -> None: # Changed return type
        location = injection_details.get("location")
        param_name = injection_details.get("param_name")
        http_method = injection_details.get("method", "GET").upper()
        target_app_url = injection_details.get("action_url", original_url)
        
        # Get original form/body data from injection_details if available
        original_form_data = injection_details.get("all_form_fields")
        original_json_data = injection_details.get("original_full_body") if location == "request_body_json_fields" else None
        original_text_data = injection_details.get("original_value") if location in ["request_body_xml_raw", "request_body_text_raw"] and param_name == "REQUEST_BODY" else None


        if not param_name:
            self.logger.debug(f"[{worker_ident}] SSRFScan: No param_name in injection_details for {original_url}. Skipping.")
            return

        injection_point_desc = f"{location} parameter '{param_name}'"
        self.logger.info(f"[{worker_ident}] Starting SSRF scan for {injection_point_desc} at {target_app_url}")

        # A. OAST Payloads
        if self.oast_base_url:
            oast_payloads_generated = 0
            for i in range(self.max_oast_payloads_per_point):
                unique_id = str(uuid.uuid4())
                oast_target_url = self._generate_oast_payload(unique_id)
                if oast_target_url == "oast_server_not_configured_error": break
                
                oast_payloads_generated +=1
                for ssrf_payload_to_inject in self._generate_bypass_payloads(oast_target_url):
                    current_app_url, post_form_data, post_json_data, post_text_data = \
                        self._prepare_app_request_with_ssrf_payload(
                            target_app_url, location, param_name, ssrf_payload_to_inject,
                            original_form_data, original_json_data, original_text_data
                        )
                    
                    # Modify headers/cookies directly for these locations
                    current_headers = original_headers.copy()
                    current_cookies = original_cookies.copy() # This is a dict, not raw string
                    if location == "header": current_headers[param_name] = ssrf_payload_to_inject
                    if location == "cookie": current_cookies[param_name] = ssrf_payload_to_inject

                    resp_obj, _, _, net_error = await self._send_ssrf_attempt_async(
                        aiohttp_session, http_method, current_app_url, current_headers, current_cookies,
                        data=post_form_data, json_data=post_json_data, text_data=post_text_data,
                        attacked_param_name=param_name, ssrf_payload_sent=ssrf_payload_to_inject
                    )
                    evidence_str, conf, _ = self._check_response_for_ssrf_indicators(resp_obj, None, net_error, "oast", unique_id)
                    alert = SSRFAlert(
                        cwe_id=918, name="Server-Side Request Forgery (OAST Attempt)",
                        description=f"SSRF attempt made using OAST payload via parameter '{param_name}'. External OAST server must be checked for interaction.",
                        uri=target_app_url, param=param_name, attack=ssrf_payload_to_inject,
                        evidence=evidence_str or "OAST payload sent.",
                        other_info=f"OAST Interaction ID: {unique_id}. Target in payload: {oast_target_url}",
                        confidence=conf, oast_interaction_id=unique_id
                    )
                    alert.attack_details = {"location": location, "param": param_name, "method": "OAST"}
                    await self._emit_alert(alert)

        # B. Internal Targets & Metadata Services
        for target_key, internal_target_url in self.internal_targets.items():
            for ssrf_payload_to_inject in self._generate_bypass_payloads(internal_target_url):
                current_app_url, post_form_data, post_json_data, post_text_data = \
                    self._prepare_app_request_with_ssrf_payload(
                        target_app_url, location, param_name, ssrf_payload_to_inject,
                        original_form_data, original_json_data, original_text_data
                    )

                current_headers = original_headers.copy()
                current_cookies = original_cookies.copy()
                if location == "header": current_headers[param_name] = ssrf_payload_to_inject
                if location == "cookie": current_cookies[param_name] = ssrf_payload_to_inject

                resp_obj, resp_text, _, net_error = await self._send_ssrf_attempt_async(
                    aiohttp_session, http_method, current_app_url, current_headers, current_cookies,
                    data=post_form_data, json_data=post_json_data, text_data=post_text_data,
                    attacked_param_name=param_name, ssrf_payload_sent=ssrf_payload_to_inject
                )

                evidence_str, conf, risk_adj = self._check_response_for_ssrf_indicators(resp_obj, resp_text, net_error, target_key)
                if evidence_str:
                    alert = SSRFAlert(
                        cwe_id=918, name=f"Potential SSRF ({target_key})",
                        description=f"Potential SSRF detected when targeting '{target_key}' ({internal_target_url}) via parameter '{param_name}'.",
                        uri=target_app_url, param=param_name, attack=ssrf_payload_to_inject,
                        evidence=evidence_str,
                        other_info=f"Targeted internal key: {target_key}",
                        confidence=conf,
                        risk=min(SSRFAlert.risk.fget(SSRFAlert(0,"","","","","")), SSRFAlert.risk.fget(SSRFAlert(0,"","","","","")) + risk_adj) # type: ignore
                    )
                    alert.attack_details = {"location": location, "param": param_name, "method": "Internal Target"}
                    await self._emit_alert(alert)
        
        self.logger.debug(f"[{worker_ident}] SSRF scan finished for {injection_point_desc} at {target_app_url}.")