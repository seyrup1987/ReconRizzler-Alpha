# Filename: VulnerabilityChecks/CodeInjectionScanRule.py
import asyncio
import re
from typing import List, Dict, Pattern, Optional, Any, Set # Added Any, Set
from urllib.parse import urljoin, urlparse, parse_qs, urlencode # Added parse_qs, urlencode
import random
import string
import aiohttp
from bs4 import BeautifulSoup # Not used in this version, can be removed if not needed later
import logging # Added logging
from dataclasses import dataclass, field # For a more standard Alert class

# --- Alert Definition (using dataclass for consistency) ---
@dataclass
class CodeInjectionAlert: # Renamed for clarity and using dataclass
    # Non-default fields first
    cwe_id: int
    name: str
    description: str
    uri: str
    attack: str
    evidence: str
    
    # Default fields
    wasc_id: int = 20 # WASC-20: Improper Input Handling (leading to Code Injection)
    solution: str = "Review server-side code and properly sanitize all user-supplied input before using it in dynamic code execution contexts. Use parameterized queries or safe APIs where possible."
    reference: str = "https://owasp.org/www-community/attacks/Code_Injection, CWE-94: https://cwe.mitre.org/data/definitions/94.html"
    risk: int = 4 # High
    confidence: int = 2 # Medium (can be High if evidence is strong)
    alert_tags: Dict[str, str] = field(default_factory=lambda: { # Use default_factory for mutable defaults
        "OWASP_2021_A03_INJECTION": "", # Updated tag format
        "WSTG_V42_INPV_11_CODE_INJ": "",
    })

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": "Code Injection",
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack if len(self.attack) < 200 else self.attack[:100] + "... (truncated)",
            "injection_point_info": f"Parameter: {self.attack_details.get('param', 'N/A')}" if hasattr(self, 'attack_details') else "N/A", # Assuming attack_details might be added
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": self.alert_tags,
        }

# Constants
PHP_CONTROL_TOKEN = "zap_token_php_ci" # Made more specific
PHP_ENCODED_TOKEN = ( # Ensure this encoding matches the token
    "chr(122).chr(97).chr(112).chr(95).chr(116).chr(111).chr(107).chr(101).chr(110)."
    "chr(95).chr(112).chr(104).chr(112).chr(95).chr(99).chr(105)"
)

PHP_PAYLOADS = [
    f'";print({PHP_ENCODED_TOKEN});$var="',
    f"';print({PHP_ENCODED_TOKEN});$var='",
    f"${{@print({PHP_ENCODED_TOKEN})}}",
    f"${{@print({PHP_ENCODED_TOKEN})}}\\",
    f";print({PHP_ENCODED_TOKEN});",
]

ASP_PAYLOADS_TEMPLATE = ['"+response.write({0}*{1})+"', "'+response.write({0}*{1})+'", "response.write({0}*{1})"]
MAX_VALUE_ASP = 999998


class CodeInjectionScanRule:
    tech_required: Set[str] = {"php", "asp", "aspx"} # Specific to these technologies

    def __init__(
        self,
        parent_logger: Optional[logging.Logger] = None,
        # scope_technologies is now handled by tech_required and ActiveVulnerabilityCheck
        # message_prefix: str = MESSAGE_PREFIX, # Not used, can be removed
        # alert_tags: Dict[str, str] = ALERT_TAGS, # Defined in Alert class
        active_scan_async_q: Optional[asyncio.Queue] = None, # Added
        http_timeout: float = 10.0 # Added for consistency
    ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.active_scan_async_q = active_scan_async_q
        self.http_timeout = http_timeout
        self.logger.debug(f"CodeInjectionScanRule initialized.")

    async def _emit_alert(self, alert_obj: CodeInjectionAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({
                    "type": "active_scan_alert", "alert": alert_obj.as_dict()
                })
                self.logger.info(f"CodeInjectionScan: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"CodeInjectionScan: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"CodeInjectionScan: Async queue not available. Alert not emitted: {alert_obj.name}")

    async def _send_request_with_payload(
        self, session: aiohttp.ClientSession, base_url: str, method: str,
        param_name: str, payload: str,
        original_params: Dict[str, str], # Original query params for GET, or form fields for POST
        is_form_post: bool = False
    ) -> Optional[str]: # Returns response text or None on error
        
        current_url = base_url
        req_params = None
        req_data = None

        if method == "GET":
            modified_params = original_params.copy()
            modified_params[param_name] = payload
            req_params = modified_params
        elif method == "POST":
            if is_form_post:
                modified_data = original_params.copy() # original_params are form fields here
                modified_data[param_name] = payload
                req_data = aiohttp.FormData()
                for k, v in modified_data.items():
                    req_data.add_field(k, str(v))
            else: # Non-form POST, e.g. JSON/XML - this rule doesn't handle structured bodies yet
                self.logger.warning("CodeInjectionScanRule: Non-form POST not fully supported for payload injection yet.")
                return None
        else: # PUT, etc.
            self.logger.warning(f"CodeInjectionScanRule: HTTP method {method} not fully supported for payload injection.")
            return None
        
        try:
            async with session.request(
                method, current_url, params=req_params, data=req_data,
                timeout=aiohttp.ClientTimeout(total=self.http_timeout)
            ) as response:
                return await response.text(errors='replace')
        except aiohttp.ClientError as e:
            self.logger.debug(f"CodeInjection: ClientError for {current_url} with payload for {param_name}: {e}")
        except asyncio.TimeoutError:
            self.logger.debug(f"CodeInjection: Timeout for {current_url} with payload for {param_name}.")
        except Exception as e_req:
            self.logger.error(f"CodeInjection: Unexpected error for {current_url} with payload for {param_name}: {e_req}")
        return None


    async def test_php_injection(
        self, session: aiohttp.ClientSession, target_url: str, method: str,
        param_name: str, original_params_or_form_data: Dict[str, str], is_form_post: bool
    ) -> None: # Changed return type
        for php_payload in PHP_PAYLOADS:
            self.logger.debug(f"Testing [PHP] [{param_name}] = [{php_payload[:30]}...] on {target_url}")
            
            response_text = await self._send_request_with_payload(
                session, target_url, method, param_name, php_payload, original_params_or_form_data, is_form_post
            )

            if response_text and PHP_CONTROL_TOKEN in response_text:
                self.logger.info(f"[PHP Code Injection Found] on param [{param_name}] with payload [{php_payload[:30]}...] at {target_url}")
                alert = CodeInjectionAlert(
                    cwe_id=94, name="PHP Code Injection Vulnerability",
                    description=f"PHP code injection vulnerability detected in parameter '{param_name}'.",
                    uri=target_url, attack=php_payload, evidence=PHP_CONTROL_TOKEN,
                    risk=CodeInjectionAlert.RISK_HIGH, confidence=CodeInjectionAlert.CONFIDENCE_MEDIUM,
                    # alert_tags can be customized if needed, defaults are from dataclass
                )
                alert.attack_details = {"param": param_name, "payload_type": "PHP"} # Add attack_details
                await self._emit_alert(alert)
                return # Found one, no need to test more PHP payloads for this param

    async def test_asp_injection(
        self, session: aiohttp.ClientSession, target_url: str, method: str,
        param_name: str, original_params_or_form_data: Dict[str, str], is_form_post: bool
    ) -> None: # Changed return type
        bignum1 = random.randint(1, MAX_VALUE_ASP // 2) # Ensure product doesn't overflow typical int too easily
        bignum2 = random.randint(1, MAX_VALUE_ASP // 2)
        expected_result_str = str(bignum1 * bignum2)
        
        current_asp_payloads = [p.format(bignum1, bignum2) for p in ASP_PAYLOADS_TEMPLATE]

        for asp_payload in current_asp_payloads:
            self.logger.debug(f"Testing [ASP] [{param_name}] = [{asp_payload[:30]}...] on {target_url}")

            response_text = await self._send_request_with_payload(
                session, target_url, method, param_name, asp_payload, original_params_or_form_data, is_form_post
            )

            if response_text and expected_result_str in response_text:
                self.logger.info(f"[ASP Code Injection Found] on param [{param_name}] with payload [{asp_payload[:30]}...] at {target_url}")
                alert = CodeInjectionAlert(
                    cwe_id=94, name="ASP Code Injection Vulnerability",
                    description=f"ASP code injection vulnerability detected in parameter '{param_name}'.",
                    uri=target_url, attack=asp_payload, evidence=expected_result_str,
                    risk=CodeInjectionAlert.RISK_HIGH, confidence=CodeInjectionAlert.CONFIDENCE_MEDIUM,
                )
                alert.attack_details = {"param": param_name, "payload_type": "ASP"} # Add attack_details
                await self._emit_alert(alert)
                return # Found one

    async def scan(
        self,
        original_url: str, # The URL where the parameter/form was found
        aiohttp_session: aiohttp.ClientSession,
        injection_details: Dict[str, Any], # param_name, original_value, location, method, all_form_fields, action_url
        page_specific_technologies: Optional[List[str]] = None, # List of lowercase tech strings
        # Other common args for compatibility, though not all used by this specific rule
        base_app_url: Optional[str] = None,
        html_content: Optional[str] = None,
        worker_ident: Optional[str] = "CodeInjScan",
        original_headers: Optional[Dict[str, str]] = None,
        original_cookies: Optional[Dict[str, str]] = None,
        service_type_hint: Optional[str] = None, # e.g., "php", "asp"
    ) -> None: # Changed return type
        param_name = injection_details.get("param_name")
        original_value = injection_details.get("original_value") # Not directly used in these tests, but good to have
        location = injection_details.get("location") # e.g., "url_params", "form_data_post"
        method = injection_details.get("method", "GET").upper()
        target_url = injection_details.get("action_url", original_url) # Use form action if available

        if not param_name:
            self.logger.debug(f"[{worker_ident}] CodeInjection: No param_name in injection_details for {original_url}. Skipping.")
            return

        self.logger.info(f"[{worker_ident}] Starting Code Injection scan for param '{param_name}' at {target_url} (Location: {location}, Method: {method})")

        # Determine original parameters or form data
        original_params_or_form_data: Dict[str, str] = {}
        is_form_post = False
        if location == "url_params":
            parsed_target = urlparse(target_url)
            original_params_or_form_data = {k: v[0] for k, v in parse_qs(parsed_target.query, keep_blank_values=True).items()}
        elif location == "form_data_post":
            original_params_or_form_data = injection_details.get("all_form_fields", {}).copy()
            is_form_post = True
        elif location == "form_data_get": # GET form, params are in URL
            parsed_target = urlparse(target_url)
            original_params_or_form_data = {k: v[0] for k, v in parse_qs(parsed_target.query, keep_blank_values=True).items()}
        else:
            self.logger.debug(f"[{worker_ident}] CodeInjection: Location '{location}' not directly handled for param extraction. Assuming empty original params for {param_name}.")


        # Use page_specific_technologies or service_type_hint to decide which tests to run
        techs_to_check_lower = {tech.lower() for tech in (page_specific_technologies or [])}
        if service_type_hint:
            techs_to_check_lower.add(service_type_hint.lower())

        if "php" in techs_to_check_lower:
            await self.test_php_injection(aiohttp_session, target_url, method, param_name, original_params_or_form_data, is_form_post)
        
        if "asp" in techs_to_check_lower or "aspx" in techs_to_check_lower: # Check for both asp and aspx
            await self.test_asp_injection(aiohttp_session, target_url, method, param_name, original_params_or_form_data, is_form_post)

        self.logger.debug(f"[{worker_ident}] Code Injection scan finished for param '{param_name}' at {target_url}.")