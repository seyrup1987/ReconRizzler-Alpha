# Filename: VulnerabilityChecks/BufferOverflowScanRule.py

import asyncio
import json
import logging
import random
import string
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set
from urllib.parse import urlencode, urlparse, parse_qs
import uuid # Added for User-Agent

import aiohttp

# --- Alert Definition ---
@dataclass
class BufferOverflowAlert:
    cwe_id: int
    name: str
    description: str
    uri: str
    attack: str
    evidence: str
    wasc_id: int = 7
    other_info: str = ""
    solution: str = (
        "Review server-side code for the affected input handling. "
        "Ensure all input buffers have proper bounds checking and length validation. "
        "Use memory-safe functions and libraries. "
        "Consider input validation and sanitization to limit input length where appropriate."
    )
    reference: str = (
        "CWE-120: https://cwe.mitre.org/data/definitions/120.html\n"
        "OWASP: Buffer Overflows - https://owasp.org/www-community/attacks/Buffer_overflow"
    )
    risk: int = 2
    confidence: int = 1
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A03": "Injection",
        "WSTG_V42_INPV_02": "Testing_for_Buffer_Overflow",
    })

    # Keep the explicit __init__ if you prefer it for clarity or specific logic
    def __init__(self, cwe_id: int, name: str, description: str, uri: str, attack: str, evidence: str,
                 wasc_id: int = 7, other_info: str = "", solution: Optional[str] = None,
                 reference: Optional[str] = None, risk: int = 2, confidence: int = 1,
                 alert_tags: Optional[Dict[str, str]] = None):
        self.cwe_id = cwe_id
        self.name = name
        self.description = description
        self.uri = uri
        self.attack = attack
        self.evidence = evidence
        self.wasc_id = wasc_id
        self.other_info = other_info
        self.solution = solution or (
            "Review server-side code for the affected input handling. "
            "Ensure all input buffers have proper bounds checking and length validation. "
            "Use memory-safe functions and libraries. "
            "Consider input validation and sanitization to limit input length where appropriate."
        )
        self.reference = reference or (
            "CWE-120: https://cwe.mitre.org/data/definitions/120.html\n"
            "OWASP: Buffer Overflows - https://owasp.org/www-community/attacks/Buffer_overflow"
        )
        self.risk = risk
        self.confidence = confidence
        self.alert_tags = alert_tags or {
            "OWASP_2021_A03": "Injection",
            "WSTG_V42_INPV_02": "Testing_for_Buffer_Overflow",
        }

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": "Buffer Overflow",
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack if len(self.attack) < 200 else self.attack[:100] + "... (truncated)",
            "injection_point_info": self.other_info,
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": self.alert_tags,
        }

# --- Constants ---
PAYLOAD_CHARACTER = 'A'
# Define payload lengths for different strengths
PAYLOAD_LENGTHS_LOW = [500, 1500]
PAYLOAD_LENGTHS_MEDIUM = [500, 2000, 5000]
PAYLOAD_LENGTHS_HIGH = [500, 1000, 2000, 5000, 10000, 15000]
PAYLOAD_LENGTHS_INSANE = [250, 500, 1000, 2000, 4000, 8000, 10000, 16000, 20000, 30000]


class BufferOverflowScanRule:
    tech_required: Set[str] = set()

    ALERT_TAGS_CLASS_LEVEL: Dict[str, str] = {
        "OWASP_2021_A03": "Injection",
        "WSTG_V42_INPV_02": "Testing_for_Buffer_Overflow",
    }

    def __init__(
        self,
        parent_logger: Optional[logging.Logger] = None,
        http_timeout: float = 20.0, # Default timeout for each request
        active_scan_async_q: Optional[asyncio.Queue] = None
    ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q
        self.logger.debug(f"BufferOverflowScanRule initialized with base timeout: {self.http_timeout}s")

    async def _emit_alert(self, alert_obj: BufferOverflowAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({
                    "type": "active_scan_alert", "alert": alert_obj.as_dict()
                })
                self.logger.info(f"BufferOverflowScan: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"BufferOverflowScan: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"BufferOverflowScan: Async queue not available. Alert not emitted: {alert_obj.name}")

    def _generate_long_string(self, length: int, char: str = PAYLOAD_CHARACTER) -> str:
        return char * length

    def _get_injection_point_description(self, injection_details: Dict[str, Any]) -> str:
        location = injection_details.get("location", "N/A")
        param_name = injection_details.get("param_name", "N/A")
        method = injection_details.get("method", "N/A")

        if location == "url_params":
            return f"URL Parameter (Method: {method}): '{param_name}'"
        elif location in ["form_data_post", "form_data_get"]:
            return f"Form Field (Method: {method}, Location: {location}): '{param_name}'"
        elif location == "header":
            return f"HTTP Header: '{param_name}'"
        elif location == "cookie":
            return f"HTTP Cookie: '{param_name}'"
        elif location in ["request_body_json_fields", "request_body_xml_raw", "request_body_text_raw"]:
            if param_name == "REQUEST_BODY" or location.endswith("_raw"):
                return f"Entire HTTP Request Body (Method: {method}, Type: {location})"
            else:
                return f"Field in HTTP Request Body (Method: {method}, Type: {location}): '{param_name}'"
        return f"Unknown Location (Method: {method}, Param: {param_name})"


    async def scan(
        self,
        original_url: str,
        original_headers: Dict[str, str],
        original_cookies: Dict[str, str], # This is a dict of cookie_name: cookie_value_str
        injection_details: Dict[str, Any],
        aiohttp_session: aiohttp.ClientSession,
        attack_strength: str = "MEDIUM", # NEW PARAMETER
        base_app_url: Optional[str] = None,
        html_content: Optional[str] = None,
        worker_ident: Optional[str] = "BOFScan",
        page_specific_technologies: Optional[List[str]] = None,
        service_type_hint: Optional[str] = None,
    ) -> None:
        
        location = injection_details.get("location")
        param_name = injection_details.get("param_name")
        http_method = injection_details.get("method", "GET").upper()
        target_url = injection_details.get("action_url", original_url) 

        injection_point_desc = self._get_injection_point_description(injection_details)
        self.logger.info(f"[{worker_ident}] BOF Scan: Targeting {injection_point_desc} at {target_url} (Strength: {attack_strength})")

        payload_lengths_to_use: List[int]
        if attack_strength.upper() == "LOW":
            payload_lengths_to_use = PAYLOAD_LENGTHS_LOW
        elif attack_strength.upper() == "HIGH":
            payload_lengths_to_use = PAYLOAD_LENGTHS_HIGH
        elif attack_strength.upper() == "INSANE":
            payload_lengths_to_use = PAYLOAD_LENGTHS_INSANE
        else: # MEDIUM or default
            payload_lengths_to_use = PAYLOAD_LENGTHS_MEDIUM
        
        self.logger.debug(f"[{worker_ident}] BOFScan: Using payload lengths {payload_lengths_to_use} for strength {attack_strength}.")


        for length in payload_lengths_to_use:
            attack_payload = self._generate_long_string(length)
            current_headers = original_headers.copy()
            
            current_url_for_request = target_url
            post_data_for_request = None
            json_data_for_request = None # Not used by this rule currently

            if location == "url_params":
                parsed_target_url = urlparse(current_url_for_request)
                query_params = parse_qs(parsed_target_url.query, keep_blank_values=True)
                query_params[param_name] = [attack_payload]
                new_query_string = urlencode(query_params, doseq=True)
                current_url_for_request = parsed_target_url._replace(query=new_query_string).geturl()

            elif location in ["form_data_post", "form_data_get"]:
                form_fields = injection_details.get("all_form_fields", {}).copy()
                form_fields[param_name] = attack_payload
                if http_method == "GET":
                    parsed_target_url = urlparse(current_url_for_request)
                    query_params = parse_qs(parsed_target_url.query, keep_blank_values=True)
                    for k, v_list_item in {key: [val] for key, val in form_fields.items()}.items():
                        query_params[k] = v_list_item
                    new_query_string = urlencode(query_params, doseq=True)
                    current_url_for_request = parsed_target_url._replace(query=new_query_string).geturl()
                else: # POST
                    post_data_for_request = aiohttp.FormData()
                    for k, v in form_fields.items():
                        post_data_for_request.add_field(k, str(v))
                    current_headers = {k: v for k, v in current_headers.items() if k.lower() != 'content-type'}
            elif location == "header":
                current_headers[param_name] = attack_payload
            elif location == "cookie":
                # Build cookie string from original_cookies dict and then modify
                temp_cookies = original_cookies.copy()
                temp_cookies[param_name] = attack_payload
                current_headers["Cookie"] = "; ".join([f"{k}={v}" for k,v in temp_cookies.items()])
            elif location in ["request_body_json_fields", "request_body_xml_raw", "request_body_text_raw"]:
                if param_name == "REQUEST_BODY" or location.endswith("_raw"):
                    post_data_for_request = attack_payload
                    if not injection_details.get("original_content_type", "").lower().startswith("application/x-www-form-urlencoded"):
                         current_headers["Content-Type"] = "text/plain"
                else:
                    self.logger.warning(f"[{worker_ident}] BOF Scan: Injecting into specific fields of JSON/XML not yet fully supported for '{param_name}'. Skipping length {length}.")
                    continue
            else:
                self.logger.warning(f"[{worker_ident}] BOF Scan: Unsupported injection location '{location}' for param '{param_name}'. Skipping length {length}.")
                continue

            self.logger.debug(f"[{worker_ident}] BOF Scan: Attempting length {length} for {injection_point_desc}. URL: {current_url_for_request}, Method: {http_method}")
            alert_generated_for_length = False
            try:
                req_start_time = asyncio.get_event_loop().time()
                # Adjust timeout based on payload length slightly, but cap it by self.http_timeout
                # Very long payloads might take longer for the server to process even if no BOF
                request_specific_timeout = min(self.http_timeout, 5 + (length / 2000)) # e.g. 5s base + 1s per 2k chars

                async with aiohttp_session.request(
                    method=http_method, url=current_url_for_request,
                    headers=current_headers, data=post_data_for_request,
                    timeout=aiohttp.ClientTimeout(total=request_specific_timeout)
                ) as response:
                    status_code = response.status
                    self.logger.debug(f"[{worker_ident}] BOF Scan: Received HTTP {status_code} for length {length} at {injection_point_desc}.")
                    if status_code >= 500:
                        alert = BufferOverflowAlert(
                            cwe_id=120, name="Potential Buffer Overflow (Server Error)",
                            description=f"Injecting a long string ({length} chars) into '{injection_point_desc}' resulted in a server error (HTTP {status_code}).",
                            uri=current_url_for_request, attack=attack_payload[:100]+"...", # Truncate for alert
                            evidence=f"Server returned HTTP status {status_code}.",
                            other_info=f"Injection Point: {injection_point_desc}, Payload Length: {length} chars.",
                            risk=2, confidence=1, alert_tags=self.ALERT_TAGS_CLASS_LEVEL.copy()
                        )
                        await self._emit_alert(alert)
                        alert_generated_for_length = True
            except asyncio.TimeoutError:
                elapsed_time = asyncio.get_event_loop().time() - req_start_time
                self.logger.info(f"[{worker_ident}] BOF Scan: Timeout ({elapsed_time:.2f}s) for length {length} at {injection_point_desc}. Potential BO.")
                alert = BufferOverflowAlert(
                    cwe_id=120, name="Potential Buffer Overflow (Request Timeout)",
                    description=f"Injecting a long string ({length} chars) into '{injection_point_desc}' caused a request timeout after {elapsed_time:.2f} seconds.",
                    uri=current_url_for_request, attack=attack_payload[:100]+"...",
                    evidence=f"Request timed out after {elapsed_time:.2f}s (configured request timeout: {request_specific_timeout:.2f}s).",
                    other_info=f"Injection Point: {injection_point_desc}, Payload Length: {length} chars.",
                    risk=3, confidence=2, alert_tags=self.ALERT_TAGS_CLASS_LEVEL.copy()
                )
                await self._emit_alert(alert)
                alert_generated_for_length = True
            except aiohttp.ClientConnectionError as e:
                elapsed_time = asyncio.get_event_loop().time() - req_start_time
                self.logger.info(f"[{worker_ident}] BOF Scan: Connection error ({type(e).__name__}) for length {length} at {injection_point_desc}. Potential BO. Error: {e}")
                alert = BufferOverflowAlert(
                    cwe_id=120, name="Potential Buffer Overflow (Connection Error)",
                    description=f"Injecting a long string ({length} chars) into '{injection_point_desc}' caused a connection error ({type(e).__name__}).",
                    uri=current_url_for_request, attack=attack_payload[:100]+"...",
                    evidence=f"Connection error: {type(e).__name__} - {str(e)}.",
                    other_info=f"Injection Point: {injection_point_desc}, Payload Length: {length} chars. Occurred after {elapsed_time:.2f}s.",
                    risk=3, confidence=2, alert_tags=self.ALERT_TAGS_CLASS_LEVEL.copy()
                )
                await self._emit_alert(alert)
                alert_generated_for_length = True
            except aiohttp.ClientError as e:
                self.logger.warning(f"[{worker_ident}] BOF Scan: ClientError ({type(e).__name__}) for length {length} at {injection_point_desc}. Error: {e}")
            except Exception as e:
                self.logger.error(f"[{worker_ident}] BOF Scan: Unexpected error ({type(e).__name__}) for length {length} at {injection_point_desc}. Error: {e}", exc_info=True)

            if alert_generated_for_length:
                 self.logger.info(f"[{worker_ident}] BOF Scan: Potential buffer overflow indicator found for {injection_point_desc} at {target_url} with length {length}.")
            
            await asyncio.sleep(0.1) # Small delay between sending large payloads

        self.logger.debug(f"[{worker_ident}] BOF Scan: Finished checks for {injection_point_desc} at {target_url}.")