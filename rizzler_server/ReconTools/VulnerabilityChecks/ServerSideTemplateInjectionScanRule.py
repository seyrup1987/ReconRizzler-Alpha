# Filename: VulnerabilityChecks/ServerSideTemplateInjectionScanRule.py

import asyncio
import logging
import re
import json
from urllib.parse import urlparse, parse_qs, urlencode, urljoin
from typing import Any, Dict, List, Optional, Set, Tuple

import aiohttp

class ServerSideTemplateInjectionScanRule:
    """
    Active scan rule to detect Server-Side Template Injection (SSTI) vulnerabilities.
    """
    tech_required: Set[str] = set() # Agnostic, but could be refined for specific engines
    rule_id = "ACTIVE-SSTI-001" # Unique ID for this rule

    # Common SSTI polyglots and their expected evaluated output (simple arithmetic)
    # Payloads are designed to result in "49"
    SSTI_PAYLOADS_ARITHMETIC = [
        ("{{7*7}}", "49"),
        ("<%= 7*7 %>", "49"),
        ("${7*7}", "49"),
        ("#{7*7}", "49"),
        ("{{'7'*2}}", "77"), # String concatenation often results in "77"
        ("${'7'*2}", "77"),
        ("<% '7'*2 %>", "77"), # Some engines might output this differently or error
        ("*{7*7}", "49"), # Thymeleaf-like
        ("{{= 7*7}}", "49"), # Some template engines use {{= ... }}
        ("{{ 7*'7' }}", "49"), # Handle potential type coercion if '7' is treated as int
        ("{{ \"foo\".toUpperCase() == \"FOO\" ? 49 : 0 }}", "49"), # More complex expression
        ("{{ [1,2,3].indexOf(2) == 1 ? 49 : 0 }}", "49"),
    ]
    # Payloads that might cause errors or specific string reflections if vulnerable
    SSTI_PAYLOADS_REFLECT_MARKER = [
        ("{{''.class.name}}", "java.lang.String"), # Java (e.g., Freemarker, Velocity)
        ("{{self}}", "self"), # Python (e.g., Jinja2, Django) - look for object representation
        ("{{ this.constructor.constructor('return process')().version }}", "v"), # Node.js (potential RCE if successful) - look for 'v' from version
        ("<%= self.class %>", "Ruby"), # Ruby (e.g., ERB) - look for class name
        ("${this.getClass().forName('java.lang.Runtime')}", "java.lang.Runtime"), # MVEL, OGNL
    ]


    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 active_scan_async_q: Optional[asyncio.Queue] = None,
                 http_timeout: float = 10.0):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.active_scan_async_q = active_scan_async_q
        self.http_timeout = http_timeout
        self.user_agent = "Mozilla/5.0 (Vishu-SSTI-Scanner/1.0)"

    async def _send_request(self,
                            session: aiohttp.ClientSession,
                            method: str,
                            url: str,
                            headers: Optional[Dict[str, str]] = None,
                            data: Optional[Any] = None,
                            json_payload: Optional[Dict[str, Any]] = None) -> Tuple[Optional[str], int, Optional[Dict[str,str]]]:
        """Helper to send HTTP requests."""
        try:
            async with session.request(method, url, headers=headers, data=data, json=json_payload, timeout=aiohttp.ClientTimeout(total=self.http_timeout)) as response:
                response_text = await response.text()
                return response_text, response.status, response.headers
        except aiohttp.ClientError as e:
            self.logger.debug(f"HTTP request to {url} failed during SSTI check: {e}")
        except asyncio.TimeoutError:
            self.logger.debug(f"HTTP request to {url} timed out during SSTI check.")
        except Exception as e:
            self.logger.error(f"Unexpected error during HTTP request to {url} for SSTI: {e}", exc_info=True)
        return None, -1, None

    async def _generate_alert(self,
                              original_url: str,
                              parameter_name: str,
                              parameter_location: str,
                              payload_used: str,
                              evidence_snippet: str,
                              expected_output: str,
                              confidence: str = "Firm",
                              severity: str = "High",
                              cwe_id: int = 94, # CWE-94: Improper Control of Generation of Code ('Code Injection')
                              description_override: Optional[str] = None
                             ):
        """Generates and queues an alert dictionary."""
        if not self.active_scan_async_q:
            self.logger.warning("Active scan async queue not available. Cannot report SSTI finding.")
            return

        alert_detail = {
            "type": "Server-Side Template Injection (SSTI)",
            "name": f"SSTI in parameter '{parameter_name}' ({parameter_location})",
            "description": description_override or (
                f"A Server-Side Template Injection (SSTI) vulnerability was detected. "
                f"The payload '{payload_used}' injected into the '{parameter_name}' parameter (located in {parameter_location}) "
                f"appears to have been evaluated by the server, as the expected output '{expected_output}' was found in the response. "
                f"SSTI vulnerabilities can often lead to Remote Code Execution (RCE)."
            ),
            "url_tested": original_url,
            "parameter_tested": parameter_name,
            "parameter_location": parameter_location,
            "payload_used": payload_used,
            "evidence": evidence_snippet[:200], # Truncate evidence
            "severity": severity,
            "confidence": confidence,
            "cwe_id": cwe_id,
            "remediation": (
                "Identify the template engine in use and apply context-specific escaping/sandboxing. "
                "Avoid passing user-supplied input directly into template rendering contexts. "
                "If possible, use template engines that offer robust sandboxing features by default."
            ),
            "rule_id": self.rule_id,
            "scan_type": "active"
        }
        await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_detail})
        self.logger.info(f"SSTI vulnerability found: {alert_detail['name']} on {original_url}")

    async def scan(self,
                   original_url: str,
                   aiohttp_session: aiohttp.ClientSession,
                   worker_ident: str,
                   injection_details: Dict[str, Any], # Contains param_name, original_value, location, method, action_url, all_form_fields
                   original_headers: Dict[str, str],
                   original_cookies: Dict[str, str],
                   attack_strength: str = "MEDIUM", # LOW, MEDIUM, HIGH
                   # page_specific_technologies: Optional[List[str]] = None, # Could be used for engine-specific payloads
                   **kwargs # For future flexibility
                  ):
        """
        Performs SSTI scan on a given injection point.
        """
        param_name = injection_details.get("param_name")
        original_param_value = injection_details.get("original_value", "")
        location = injection_details.get("location") # e.g., "url_params", "form_post", "request_body_json_fields"
        http_method = injection_details.get("method", "GET").upper()
        target_url = injection_details.get("action_url", original_url) # For forms, this might be different

        if not param_name or not location:
            self.logger.debug(f"[{worker_ident}] SSTI: Missing param_name or location in injection_details for {original_url}. Skipping.")
            return

        self.logger.debug(f"[{worker_ident}] SSTI: Scanning {param_name} ({location}) on {target_url} with strength {attack_strength}")

        payload_set = self.SSTI_PAYLOADS_ARITHMETIC
        if attack_strength == "HIGH":
            payload_set.extend(self.SSTI_PAYLOADS_REFLECT_MARKER)
        elif attack_strength == "LOW":
            payload_set = self.SSTI_PAYLOADS_ARITHMETIC[:3] # Fewer payloads for LOW

        for payload_str, expected_reflection in payload_set:
            current_headers = {**original_headers, "User-Agent": self.user_agent} # Make a copy
            # Ensure cookies are in the format aiohttp expects (string or Morsel object)
            # Assuming original_cookies is {name: value_string}
            cookie_jar = aiohttp.CookieJar(unsafe=True)
            for name, value in original_cookies.items():
                cookie_jar.update_cookies({name: value}, urlparse(target_url))


            data_for_request = None
            json_for_request = None
            modified_url = target_url

            if location == "url_params": # Assumes GET, but could be POST with URL params
                parsed_target_url = urlparse(target_url)
                query_params = parse_qs(parsed_target_url.query, keep_blank_values=True)
                query_params[param_name] = [payload_str]
                # Preserve other original parameters
                for orig_p_name, orig_p_vals in parse_qs(parsed_target_url.query, keep_blank_values=True).items():
                    if orig_p_name != param_name:
                        query_params[orig_p_name] = orig_p_vals
                
                modified_url = parsed_target_url._replace(query=urlencode(query_params, doseq=True)).geturl()

            elif location.startswith("form_"): # e.g., "form_post", "form_get"
                form_fields = injection_details.get("all_form_fields", {}).copy()
                form_fields[param_name] = payload_str
                if http_method == "GET":
                    parsed_target_url = urlparse(target_url)
                    query_params = parse_qs(parsed_target_url.query, keep_blank_values=True)
                    for k,v in form_fields.items(): query_params[k] = [v] # Override/add form fields to query
                    modified_url = parsed_target_url._replace(query=urlencode(query_params, doseq=True)).geturl()
                else: # POST, PUT, etc.
                    data_for_request = form_fields # aiohttp handles urlencoding for dict data

            elif location == "request_body_json_fields":
                if isinstance(original_param_value, dict) and http_method in ["POST", "PUT", "PATCH"]:
                    # This assumes param_name is "REQUEST_BODY" and original_param_value is the full JSON body.
                    # A more granular approach would traverse the JSON. For now, we'll try replacing the whole body
                    # if it's a simple string, or try to inject if it's a known structure.
                    # This part is tricky for generic SSTI without knowing JSON structure.
                    # Let's try a naive approach: if the original body was a string, replace it.
                    # If it was a dict, try to inject into each top-level string field.
                    # For this example, we'll assume param_name="REQUEST_BODY" means we test the payload as the *entire* body.
                    # This is a simplification. A real JSON SSTI fuzzer would be more complex.
                    if param_name == "REQUEST_BODY": # And original_param_value was the original JSON structure
                        # Try to send the payload as if it's a field value in a simple JSON
                        json_for_request = {"vulnerable_field_test": payload_str}
                        current_headers["Content-Type"] = "application/json"
                    else:
                        self.logger.debug(f"[{worker_ident}] SSTI: JSON body injection for specific fields not yet fully implemented. Skipping {param_name}.")
                        continue
                else:
                    self.logger.debug(f"[{worker_ident}] SSTI: JSON body injection for {param_name} not applicable (original value not dict or wrong method).")
                    continue
            
            elif location == "header":
                current_headers[param_name] = payload_str

            elif location == "cookie":
                # Update the specific cookie with the payload
                temp_cookies = original_cookies.copy()
                temp_cookies[param_name] = payload_str
                cookie_jar = aiohttp.CookieJar(unsafe=True) # Re-init for this specific modification
                for name, value in temp_cookies.items():
                    cookie_jar.update_cookies({name: value}, urlparse(target_url))
            else:
                self.logger.debug(f"[{worker_ident}] SSTI: Unknown injection location '{location}' for {param_name}. Skipping.")
                continue

            response_body, status_code, response_headers = await self._send_request(
                aiohttp_session, http_method, modified_url, headers=current_headers,
                data=data_for_request, json_payload=json_for_request
                # Pass cookie_jar to session.request if not using global session jar
            )

            if response_body and status_code != -1:
                # Check for arithmetic evaluation
                if expected_reflection in response_body:
                    # More precise check: ensure it's not just the payload string itself
                    # This regex tries to find the reflection NOT surrounded by typical template delimiters
                    # This is a heuristic and might need refinement.
                    # For "49", we look for "49" that isn't "{{49}}" or similar.
                    # A simple check is often good enough for a start.
                    if not re.search(re.escape(payload_str), response_body, re.IGNORECASE):
                        evidence_start = max(0, response_body.find(expected_reflection) - 50)
                        evidence_end = min(len(response_body), response_body.find(expected_reflection) + len(expected_reflection) + 50)
                        evidence = response_body[evidence_start:evidence_end]
                        
                        await self._generate_alert(
                            original_url=target_url, # Use the actual URL hit
                            parameter_name=param_name,
                            parameter_location=location,
                            payload_used=payload_str,
                            evidence_snippet=evidence,
                            expected_output=expected_reflection
                        )
                        return # Found a vulnerability for this parameter, move to next parameter/page

        self.logger.debug(f"[{worker_ident}] SSTI: Finished scan for {param_name} ({location}) on {target_url}. No arithmetic SSTI found.")