# Filename: VulnerabilityChecks/CrossSiteScriptingScanRule.py
import asyncio
import re
from typing import List, Dict, Pattern, Optional, Any, Set
from urllib.parse import urljoin, urlparse, quote, parse_qs, urlencode
import random
import string
import aiohttp
from bs4 import BeautifulSoup
import logging
from dataclasses import dataclass, field
import html
import uuid # Added for unique marker

# --- Alert Definition ---
@dataclass
class XSSAlert:
    cwe_id: int
    name: str
    description: str
    uri: str
    attack: str
    evidence: str
    wasc_id: int = 8
    solution: str = (
        "Sanitize all user-supplied input by using appropriate contextual output encoding "
        "(e.g., HTML entity encoding for HTML context, JavaScript escaping for script context). "
        "Implement a strong Content Security Policy (CSP). Use modern web frameworks that "
        "auto-escape XSS by default."
    )
    reference: str = "https://owasp.org/www-community/attacks/xss/, CWE-79: https://cwe.mitre.org/data/definitions/79.html"
    risk: int = 3
    confidence: int = 1
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A03_INJECTION": "",
        "WSTG_V42_INPV_01_REFLECTED_XSS": "",
    })
    attack_details: Dict[str, Any] = field(default_factory=dict)

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": "Cross-Site Scripting (XSS)",
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack if len(self.attack) < 200 else self.attack[:100] + "... (truncated)",
            "injection_point_info": f"Parameter: {self.attack_details.get('param', 'N/A')}, Location: {self.attack_details.get('location', 'N/A')}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": self.alert_tags,
            "other_info": f"Attack Details: {self.attack_details}"
        }

# Constants
XSS_EYECATCHER_PREFIX = "zXssScanEyecatcher"

# Define payload sets for different strengths
XSS_PAYLOADS_LOW = [
    "<script>alert('{marker}')</script>",
    "<img src=x onerror=alert('{marker}')>"
]
XSS_PAYLOADS_MEDIUM = [
    "<script>alert('{marker}')</script>",
    "<img src=x onerror=alert('{marker}')>",
    "<svg onload=alert('{marker}')>",
    "'\"><script>alert('{marker}')</script>",
    "javascript:alert('{marker}')" # For href/src attributes
]
XSS_PAYLOADS_HIGH = XSS_PAYLOADS_MEDIUM + [
    "\" onfocus=alert('{marker}') autofocus>", # Attribute injection
    "<details/open/ontoggle=alert('{marker}')>", # HTML5 based
    "<iframe src=\"javascript:alert('{marker}')\"></iframe>",
    "<a href=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgnJE1BUktFUkonKTs8L3NjcmlwdD4=\">Click Me</a>".replace("$MARKER$", "{marker}"), # data URI
    "<object data=\"javascript:alert('{marker}')\"></object>"
]
XSS_PAYLOADS_INSANE = XSS_PAYLOADS_HIGH + [ # Add more obscure/evasive payloads
    "<body onload=alert('{marker}')>",
    "<video><source onerror=\"alert('{marker}')\">",
    "<div style=\"width:expression(alert('{marker}'))\"></div>", # IE specific, but good for variety
    "<!--<script>alert('{marker}')</script>-->", # Comment breakout attempt
    "<scri<script>pt>alert('{marker}')</scri</script>pt>", # Filter evasion
    "eval('ale'+'rt(\\'{marker}\\')')", # JS eval
    "String.fromCharCode(97,108,101,114,116,40,39,{marker_ascii_codes},39,41)" # FromCharCode
]


class CrossSiteScriptingScanRule:
    tech_required: Set[str] = set()

    def __init__(
        self,
        parent_logger: Optional[logging.Logger] = None,
        active_scan_async_q: Optional[asyncio.Queue] = None,
        http_timeout: float = 10.0,
    ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.active_scan_async_q = active_scan_async_q
        self.http_timeout = http_timeout
        self.logger.debug(f"CrossSiteScriptingScanRule initialized.")

    async def _emit_alert(self, alert_obj: XSSAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({
                    "type": "active_scan_alert", "alert": alert_obj.as_dict()
                })
                self.logger.info(f"XSSScan: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"XSSScan: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"XSSScan: Async queue not available. Alert not emitted: {alert_obj.name}")

    async def _send_request_with_xss_payload(
        self, session: aiohttp.ClientSession, base_url: str, method: str,
        param_name: str, payload_with_marker: str,
        original_params_or_form_data: Dict[str, str],
        is_form_post: bool = False
    ) -> Optional[str]:
        current_url = base_url
        req_params = None
        req_data = None

        if method == "GET":
            modified_params = original_params_or_form_data.copy()
            modified_params[param_name] = payload_with_marker
            req_params = modified_params
        elif method == "POST":
            if is_form_post:
                modified_data = original_params_or_form_data.copy()
                modified_data[param_name] = payload_with_marker
                req_data = aiohttp.FormData()
                for k, v_item in modified_data.items():
                    req_data.add_field(k, str(v_item))
            else:
                self.logger.warning("XSSScanRule: Non-form POST not fully supported for XSS payload injection yet.")
                return None
        else:
            self.logger.warning(f"XSSScanRule: HTTP method {method} not fully supported for XSS payload injection.")
            return None
        
        try:
            async with session.request(
                method, current_url, params=req_params, data=req_data,
                timeout=aiohttp.ClientTimeout(total=self.http_timeout)
            ) as response:
                try:
                    response_bytes = await response.read()
                    return response_bytes.decode(errors='replace')
                except Exception as e_read:
                    self.logger.debug(f"XSSScan: Error reading response body for {current_url}: {e_read}")
                    return ""
        except aiohttp.ClientError as e:
            self.logger.debug(f"XSSScan: ClientError for {current_url} with payload for {param_name}: {e}")
        except asyncio.TimeoutError:
            self.logger.debug(f"XSSScan: Timeout for {current_url} with payload for {param_name}.")
        except Exception as e_req:
            self.logger.error(f"XSSScan: Unexpected error for {current_url} with payload for {param_name}: {e_req}")
        return None

    def _check_reflection_in_html(self, response_text: str, marker: str, payload_template: str) -> Optional[str]:
        if marker not in response_text:
            return None
        
        marker_idx = response_text.find(marker)
        if marker_idx == -1: return None

        snippet_start = max(0, marker_idx - len(payload_template) - 30) # Increased context window
        snippet_end = min(len(response_text), marker_idx + len(marker) + len(payload_template) + 30)
        snippet = response_text[snippet_start:snippet_end]

        # Check for unescaped structural parts of common XSS vectors
        # This is still heuristic but better than just marker presence.
        # A full DOM parser and JS execution would be needed for high confidence.
        
        # Check for <script> context
        if "<script" in payload_template.lower():
            # Look for the marker inside what appears to be a script tag context
            # A simple check: is the marker itself not HTML escaped, and are script tags not fully escaped?
            if not (html.escape(marker) != marker and marker in html.escape(response_text)): # Marker is not escaped
                 # Check if <script> or similar is present unescaped near the marker
                if re.search(r"<script[^>]*>.*?" + re.escape(marker) + r".*?</script>", response_text, re.IGNORECASE | re.DOTALL):
                    return f"Marker '{marker}' reflected inside a <script> block. Snippet: {html.escape(snippet)}"

        # Check for HTML attribute context (e.g., onerror, onfocus, href=javascript:)
        # This is harder to do reliably without full parsing.
        # If payload contains "onerror=" and this string (unescaped) is near the marker.
        if "onerror=" in payload_template.lower() and "onerror=" in snippet.lower():
            # Check if it's within a tag attribute context
            if re.search(r"<[^>]+onerror\s*=\s*[^>]*?"+re.escape(marker), response_text, re.IGNORECASE):
                 return f"Marker '{marker}' reflected near an 'onerror=' attribute. Snippet: {html.escape(snippet)}"
        
        if "javascript:alert" in payload_template.lower() and "javascript:" in snippet.lower():
            if re.search(r"""\b(href|src|action|formaction)\s*=\s*['"]?\s*javascript:.*?{marker}""".format(marker=re.escape(marker)), response_text, re.IGNORECASE | re.VERBOSE):
                return f"Marker '{marker}' reflected in a 'javascript:' URL context. Snippet: {html.escape(snippet)}"

        # Default if marker is found but specific contexts are not easily confirmed passively
        return f"Marker '{marker}' reflected in response. Manual verification of context needed. Snippet: {html.escape(snippet)}"


    async def scan(
        self,
        original_url: str,
        aiohttp_session: aiohttp.ClientSession,
        injection_details: Dict[str, Any],
        attack_strength: str = "MEDIUM", # NEW PARAMETER
        base_app_url: Optional[str] = None,
        html_content: Optional[str] = None,
        worker_ident: Optional[str] = "XSSScan",
        original_headers: Optional[Dict[str, str]] = None,
        original_cookies: Optional[Dict[str, str]] = None,
        page_specific_technologies: Optional[List[str]] = None,
        service_type_hint: Optional[str] = None,
    ) -> None:
        param_name = injection_details.get("param_name")
        location = injection_details.get("location")
        method = injection_details.get("method", "GET").upper()
        target_url_for_payload = injection_details.get("action_url", original_url)

        if not param_name:
            self.logger.debug(f"[{worker_ident}] XSSScan: No param_name in injection_details for {original_url}. Skipping.")
            return

        self.logger.info(f"[{worker_ident}] Starting XSS scan for param '{param_name}' at {target_url_for_payload} (Strength: {attack_strength})")

        payload_templates_to_use: List[str]
        if attack_strength.upper() == "LOW":
            payload_templates_to_use = XSS_PAYLOADS_LOW
        elif attack_strength.upper() == "HIGH":
            payload_templates_to_use = XSS_PAYLOADS_HIGH
        elif attack_strength.upper() == "INSANE":
            payload_templates_to_use = XSS_PAYLOADS_INSANE
        else: # MEDIUM or default
            payload_templates_to_use = XSS_PAYLOADS_MEDIUM
        
        self.logger.debug(f"[{worker_ident}] XSSScan: Using {len(payload_templates_to_use)} payload templates for strength {attack_strength}.")

        original_params_or_form_data: Dict[str, str] = {}
        is_form_post = False
        if location == "url_params":
            parsed_target = urlparse(target_url_for_payload)
            original_params_or_form_data = {k: v[0] for k, v in parse_qs(parsed_target.query, keep_blank_values=True).items()}
        elif location == "form_data_post":
            original_params_or_form_data = injection_details.get("all_form_fields", {}).copy()
            is_form_post = True
        elif location == "form_data_get":
            parsed_target = urlparse(target_url_for_payload)
            original_params_or_form_data = {k: v[0] for k, v in parse_qs(parsed_target.query, keep_blank_values=True).items()}

        for payload_template in payload_templates_to_use:
            unique_marker_base = f"{XSS_EYECATCHER_PREFIX}_{param_name[:5]}_{uuid.uuid4().hex[:4]}"
            
            payload_with_marker = payload_template
            if "{marker}" in payload_template:
                 payload_with_marker = payload_template.format(marker=unique_marker_base)
            elif "{marker_ascii_codes}" in payload_template: # For String.fromCharCode
                ascii_codes = ",".join(map(str, [ord(c) for c in unique_marker_base]))
                payload_with_marker = payload_template.format(marker_ascii_codes=ascii_codes)
            else: # If template doesn't use marker, append it for tracking (less ideal for detection)
                payload_with_marker = payload_template + unique_marker_base


            self.logger.debug(f"[{worker_ident}] XSS Testing [{param_name}] with marker [{unique_marker_base}] using template: {payload_template[:50]}...")

            response_text = await self._send_request_with_xss_payload(
                aiohttp_session, target_url_for_payload, method, param_name, payload_with_marker,
                original_params_or_form_data, is_form_post
            )

            if response_text:
                evidence_str = self._check_reflection_in_html(response_text, unique_marker_base, payload_template)
                if evidence_str:
                    self.logger.info(f"[{worker_ident}] Potential XSS Found for param [{param_name}] with marker [{unique_marker_base}] at {target_url_for_payload}")
                    alert = XSSAlert(
                        cwe_id=79, name="Potential Cross-Site Scripting (XSS)",
                        description=f"A payload injected into parameter '{param_name}' was reflected in the response, indicating a potential XSS vulnerability.",
                        uri=target_url_for_payload,
                        attack=payload_with_marker,
                        evidence=evidence_str,
                        risk=3 if "reflected inside a <script> block" in evidence_str or "javascript:' URL context" in evidence_str else 2, # Higher risk if in script/js context
                        confidence=2 if "reflected inside a <script> block" in evidence_str or "javascript:' URL context" in evidence_str else 1,
                    )
                    alert.attack_details = {"param": param_name, "location": location, "payload_template": payload_template, "marker": unique_marker_base}
                    await self._emit_alert(alert)
                    # Consider if you want to stop after first finding for this param or try all payloads
                    # For XSS, trying all payloads for a parameter is often beneficial.

        self.logger.debug(f"[{worker_ident}] XSS scan finished for param '{param_name}' at {target_url_for_payload}.")