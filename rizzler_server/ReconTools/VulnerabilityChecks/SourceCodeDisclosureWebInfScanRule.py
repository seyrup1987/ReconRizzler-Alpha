# Filename: VulnerabilityChecks/SourceCodeDisclosureWebInfScanRule.py

import asyncio
import logging
import random
import re
import tempfile # Not strictly needed if not de-compiling externally, but good for future
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple, TYPE_CHECKING
from collections import deque

import aiohttp

if TYPE_CHECKING:
    from asyncio import Queue # For type hinting

@dataclass
class WebInfDisclosureAlert:
    cwe_id: int = 541
    wasc_id: int = 34
    name: str = "WEB-INF Source Code or Configuration Disclosure"
    description: str = ""
    uri: str = ""
    attack_payload_url: str = ""
    evidence: str = ""
    other_info: str = ""
    solution: str = (
        "Ensure that the WEB-INF directory and its contents (like web.xml, applicationContext.xml, "
        "classes directory, lib directory, and specific configuration files) are not directly accessible "
        "to web users. Configure web server access controls to deny direct requests to these resources. "
        "Review application configurations to ensure sensitive information is not hardcoded or unnecessarily exposed."
    )
    reference: str = (
        "OWASP: Testing for WEB-INF leakage (WSTG-CONF-05) - https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/05-Testing_for_WEB-INF_Leakage\n"
        "CWE-541: https://cwe.mitre.org/data/definitions/541.html"
    )
    risk: int = 3
    confidence: int = 3
    # Class level constants for risk
    RISK_HIGH: int = 3
    RISK_MEDIUM: int = 2
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A05": "Security Misconfiguration",
        "OWASP_2017_A06": "Security Misconfiguration",
        "WSTG_V42_CONF_05": "Enumerate Infrastructure and Application Admin Interfaces",
    })
    alert_ref_suffix: str = "1"

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": "SourceCodeDisclosure_WEB-INF",
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack_payload_url,
            "injection_point_info": "N/A (Direct Request)",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": self.alert_tags,
            "other_info": self.other_info,
            "alert_ref": f"SourceCodeDisclosureWebInfScanRule-{self.alert_ref_suffix}"
        }

WEBINF_CONFIG_FILES = [
    "web.xml",
    "applicationContext.xml",
    "struts-config.xml",
    "faces-config.xml",
    "application.xml",
]
JAVA_CLASSNAME_PATTERN = re.compile(rb"[a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)+")
JAVA_IMPORT_CLASSNAME_PATTERN = re.compile(rb"import\s+([a-zA-Z0-9_.]+?\.[A-Z_][a-zA-Z0-9_]*);", re.MULTILINE)
PROPERTIES_FILE_PATTERN = re.compile(rb'"([/a-zA-Z0-9_-]+\.properties)"')


class SourceCodeDisclosureWebInfScanRule:
    tech_required: Set[str] = { # Technologies that often use WEB-INF
        "Java", "JSP", "Apache Tomcat", "Apache Struts", "Spring Framework",
        "IBM WebSphere", "Oracle WebLogic", "JBoss Application Server", "Jetty",
        "GlassFish Server", "SAP NetWeaver", "Adobe ColdFusion", "Liferay Portal"
    }
    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 http_timeout: float = 10.0,
                 active_scan_async_q: Optional['Queue'] = None # Added parameter
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q # Store the queue

    def _get_target_url(self, base_app_uri: urllib.parse.ParseResult, path: str) -> str:
        if base_app_uri.path.endswith('/') and path.startswith('/'):
            effective_path = base_app_uri.path + path[1:]
        elif not base_app_uri.path.endswith('/') and not path.startswith('/'):
             effective_path = base_app_uri.path + '/' + path
        else:
            effective_path = base_app_uri.path + path
        
        if effective_path.startswith('//'):
            effective_path = effective_path[1:]

        return urllib.parse.urlunparse((
            base_app_uri.scheme,
            base_app_uri.netloc,
            effective_path,
            '', '', ''
        ))

    async def _fetch_url_content(
        self,
        session: aiohttp.ClientSession,
        url: str,
        original_headers: Optional[Dict[str, str]] = None
    ) -> Tuple[Optional[bytes], Optional[int], Optional[Dict[str,str]]]:
        
        headers_to_send = (original_headers or {}).copy()
        if "User-Agent" not in headers_to_send:
             headers_to_send["User-Agent"] = random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            ])
        
        self.logger.debug(f"WEB-INF Scan: Fetching {url}")
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.get(url, headers=headers_to_send, timeout=timeout, allow_redirects=False) as resp:
                content = await resp.read()
                return content, resp.status, dict(resp.headers)
        except Exception as e:
            self.logger.warning(f"WEB-INF Scan: Request to {url} failed: {type(e).__name__} - {e}")
            return None, None, None

    def _find_strings_in_bytestream(self, pattern: re.Pattern, content: bytes) -> Set[str]:
        found_strings: Set[str] = set()
        try:
            matches = pattern.findall(content)
            for match_bytes in matches:
                try:
                    if isinstance(match_bytes, tuple):
                        match_bytes = match_bytes[0]
                    
                    decoded_string = match_bytes.decode('utf-8', errors='ignore').strip()
                    if decoded_string:
                        found_strings.add(decoded_string)
                except Exception:
                    pass
        except Exception as e:
            self.logger.debug(f"WEB-INF Scan: Error during regex string finding: {e}")
        return found_strings

    async def _queue_alert(self, alert_instance: WebInfDisclosureAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_instance.as_dict()})
            except Exception as e_queue:
                self.logger.error(f"Failed to put WEB-INF alert onto async queue: {e_queue}")
        else:
            self.logger.warning("active_scan_async_q not available in WEB-INF rule, cannot queue alert.")


    async def scan(
        self,
        base_app_url: str,
        original_headers: Dict[str, str],
        aiohttp_session: aiohttp.ClientSession,
        # The following are part of a more generic signature but less used by this specific rule
        original_cookies: Optional[Dict[str, str]] = None,
        page_specific_technologies: Optional[List[str]] = None, # Can be used to confirm Java/JSP target
        injection_details: Optional[Dict[str, Any]] = None,
        original_page_content_for_baseline_errors: Optional[str] = None
    ) -> None: # Changed return type to None
        
        if not self.active_scan_async_q:
            self.logger.warning("WEB-INF scan skipped: active_scan_async_q not configured.")
            return

        try:
            parsed_base_app_uri = urllib.parse.urlparse(base_app_url)
            if not parsed_base_app_uri.scheme or not parsed_base_app_uri.netloc:
                self.logger.error(f"WEB-INF Scan: Invalid base_app_url: {base_app_url}")
                return
        except Exception as e:
            self.logger.error(f"WEB-INF Scan: Could not parse base_app_url '{base_app_url}': {e}")
            return

        # Check if target is likely Java-based before proceeding
        is_java_target = False
        if page_specific_technologies:
            for tech in page_specific_technologies:
                if tech.lower() in {t.lower() for t in self.tech_required}:
                    is_java_target = True
                    break
        if not is_java_target:
            # Fallback: check common Java headers if no tech info
            if original_headers:
                if any(h.lower() == 'server' and ('tomcat' in v.lower() or 'jetty' in v.lower() or 'websphere' in v.lower() or 'weblogic' in v.lower() or 'jboss' in v.lower()) for h,v in original_headers.items()):
                    is_java_target = True
                elif any(h.lower() == 'x-powered-by' and ('jsp' in v.lower() or 'servlet' in v.lower()) for h,v in original_headers.items()):
                    is_java_target = True
        
        if not is_java_target:
            self.logger.debug(f"WEB-INF Scan: Skipping {base_app_url} as it does not appear to be a Java/JSP application based on available hints.")
            return

        self.logger.info(f"Starting WEB-INF disclosure scan for base URL: {base_app_url}")

        java_classes_to_find: deque[str] = deque()
        java_classes_handled: Set[str] = set()
        properties_files_handled: Set[str] = set()
        alerts_generated_count = 0

        for config_filename in WEBINF_CONFIG_FILES:
            target_path = f"/WEB-INF/{config_filename}"
            file_url = self._get_target_url(parsed_base_app_uri, target_path)
            
            content, status, _ = await self._fetch_url_content(aiohttp_session, file_url, original_headers)

            if status == 200 and content:
                self.logger.info(f"WEB-INF Scan: Found accessible config file: {file_url}")
                alert = WebInfDisclosureAlert(
                    name=f"WEB-INF Configuration File Accessible: {config_filename}",
                    description=f"The configuration file '{config_filename}' within WEB-INF is directly accessible.",
                    uri=file_url, attack_payload_url=file_url,
                    evidence=content[:200].decode('utf-8', errors='ignore') + "...",
                    other_info=f"File size: {len(content)} bytes.",
                    risk=WebInfDisclosureAlert.RISK_MEDIUM,
                    alert_ref_suffix="config"
                )
                await self._queue_alert(alert)
                alerts_generated_count += 1
                
                potential_classes_in_config = self._find_strings_in_bytestream(JAVA_CLASSNAME_PATTERN, content)
                for classname in potential_classes_in_config:
                    if not classname.startswith("java.") and \
                       not classname.startswith("javax.") and \
                       classname not in java_classes_to_find and \
                       classname not in java_classes_handled:
                        if '.' in classname and classname.count('.') >= 1:
                            self.logger.debug(f"WEB-INF Scan: Potential class '{classname}' found in '{config_filename}'")
                            java_classes_to_find.append(classname)
            elif status is not None and status != 404 :
                 self.logger.info(f"WEB-INF Scan: Interesting status {status} for {file_url} (not 200 or 404).")

        while java_classes_to_find:
            classname = java_classes_to_find.popleft()
            if classname in java_classes_handled:
                continue
            java_classes_handled.add(classname)

            class_path_on_server = classname.replace('.', '/') + ".class"
            target_path = f"/WEB-INF/classes/{class_path_on_server}"
            class_file_url = self._get_target_url(parsed_base_app_uri, target_path)

            self.logger.debug(f"WEB-INF Scan: Attempting to fetch class file: {class_file_url}")
            content, status, _ = await self._fetch_url_content(aiohttp_session, class_file_url, original_headers)

            if status == 200 and content:
                is_likely_class_file = content.startswith(b'\xCA\xFE\xBA\xBE')
                
                if is_likely_class_file:
                    self.logger.info(f"WEB-INF Scan: Successfully downloaded potential class file: {class_file_url}")
                    alert = WebInfDisclosureAlert(
                        name=f"Java Class File Disclosed: {classname}",
                        description=f"The Java class file '{classname}.class' was found and downloaded from WEB-INF/classes.",
                        uri=class_file_url, attack_payload_url=class_file_url,
                        evidence=f"Successfully downloaded {len(content)} bytes. File starts with Java magic number (CAFEBABE).",
                        other_info=f"Class name: {classname}. Full path: {target_path}",
                        risk=WebInfDisclosureAlert.RISK_HIGH,
                        alert_ref_suffix="class"
                    )
                    await self._queue_alert(alert)
                    alerts_generated_count += 1

                    potential_imports = self._find_strings_in_bytestream(JAVA_IMPORT_CLASSNAME_PATTERN, content)
                    for imported_classname_match in potential_imports:
                        imported_classname = imported_classname_match
                        if not imported_classname.startswith("java.") and \
                           not imported_classname.startswith("javax.") and \
                           imported_classname not in java_classes_to_find and \
                           imported_classname not in java_classes_handled:
                            self.logger.debug(f"WEB-INF Scan: Potential imported class '{imported_classname}' found in '{classname}.class'")
                            java_classes_to_find.append(imported_classname)
                    
                    potential_props_files = self._find_strings_in_bytestream(PROPERTIES_FILE_PATTERN, content)
                    for props_filename_match in potential_props_files:
                        props_filename = props_filename_match
                        if props_filename in properties_files_handled:
                            continue
                        properties_files_handled.add(props_filename)

                        props_target_path_in_classes = props_filename.lstrip('/')
                        props_full_path = f"/WEB-INF/classes/{props_target_path_in_classes}"
                        props_file_url = self._get_target_url(parsed_base_app_uri, props_full_path)
                        
                        self.logger.debug(f"WEB-INF Scan: Attempting to fetch properties file: {props_file_url} (referenced by {classname})")
                        props_content, props_status, _ = await self._fetch_url_content(aiohttp_session, props_file_url, original_headers)
                        
                        if props_status == 200 and props_content:
                            self.logger.info(f"WEB-INF Scan: Successfully downloaded properties file: {props_file_url}")
                            alert = WebInfDisclosureAlert(
                                name=f"Properties File Disclosed: {props_filename}",
                                description=f"The properties file '{props_filename}' was found and downloaded, referenced by class '{classname}'.",
                                uri=props_file_url, attack_payload_url=props_file_url,
                                evidence=props_content[:200].decode('utf-8', errors='ignore') + "...",
                                other_info=f"Referenced by class: {classname}. Path: {props_full_path}",
                                risk=WebInfDisclosureAlert.RISK_MEDIUM,
                                cwe_id=200,
                                alert_ref_suffix="properties"
                            )
                            await self._queue_alert(alert)
                            alerts_generated_count += 1
                else:
                    self.logger.debug(f"WEB-INF Scan: Downloaded {class_file_url}, but it does not appear to be a Java class file (missing CAFEBABE). Size: {len(content)}")
            elif status is not None and status != 404:
                 self.logger.info(f"WEB-INF Scan: Interesting status {status} for class {class_file_url} (not 200 or 404).")

        if alerts_generated_count > 0:
            self.logger.info(f"WEB-INF disclosure scan for {base_app_url} completed. Found {alerts_generated_count} potential alerts.")
        else:
            self.logger.info(f"WEB-INF disclosure scan for {base_app_url} completed. No alerts generated.")
        return # No longer returns a list