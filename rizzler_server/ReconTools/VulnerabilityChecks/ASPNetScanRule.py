# Filename: VulnerabilityChecks/ASPNetScanRule.py

import asyncio
import logging
import random
import string
import uuid
import urllib.parse
import html # For XSS evidence
import re # For ViewState and error parsing
import base64 # For ViewState
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Set

import aiohttp
from bs4 import BeautifulSoup # For extracting ViewState and other form fields

# --- Alert Dataclass ---
@dataclass
class ASPNetVulnerabilityAlert:
    # Non-default arguments first
    cwe_id: int
    name: str
    description: str
    uri: str
    
    # Default arguments follow
    wasc_id: Optional[int] = None
    attack_details: Dict[str, Any] = field(default_factory=dict)
    evidence: str = ""
    solution: str = (
        "Apply latest patches to ASP.NET Framework, IIS, and any third-party components. "
        "Review web.config for secure configurations (e.g., customErrors='On', ViewState MAC enabled). "
        "Follow OWASP guidelines for ASP.NET security."
    )
    reference: str = ""
    risk: int = 3
    confidence: int = 2
    alert_tags: Dict[str, str] = field(default_factory=dict)

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": self.alert_tags.get("Framework", "ASP.NET"),
            "type": self.name,
            "detail": self.description,
            "payload_used": str(self.attack_details.get("payload", "N/A")),
            "injection_point_info": f"{self.attack_details.get('check_type', 'N/A')}: {self.attack_details.get('path', self.attack_details.get('parameter', 'N/A'))}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id if self.wasc_id else 0,
            "alert_tags": self.alert_tags,
            "other_info": f"Attack Details: {self.attack_details}"
        }

# --- Main Scan Rule Class ---
class ASPNetScanRule:
    tech_required: Set[str] = {
        "asp.net", "asp.net mvc", "asp.net core", # Generic ASP.NET
        "asp.net boilerplate", "abp framework",   # Specific Frameworks
        "akilli ticaret",                         # Specific Product
        "dotnetnuke", "dnn"                       # Specific CMS
    }

    # Common ASP.NET paths
    TRACE_AXD_PATH = "/trace.axd"
    ELMAH_AXD_PATH = "/elmah.axd" # Common, but could be configured elsewhere
    TELERIK_WEBRESOURCE_PATH = "/Telerik.Web.UI.WebResource.axd"
    # Known vulnerable Telerik paths (examples, more might be needed for specific CVEs)
    TELERIK_VULN_DIALOGS = [
        "/Telerik.Web.UI.DialogHandler.aspx", # General handler
        # Specific dialogs related to CVE-2017-11317 or similar file upload/path traversal issues
        # e.g., RadAsyncUpload, RadEditor dialogs if they have known vulnerable query params
    ]

    # Simple XSS payload for ViewState check
    VIEWSTATE_XSS_PAYLOAD = f"AspNetScanRuleXssTest{uuid.uuid4().hex[:4]}"


    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 oast_base_url: Optional[str] = None,
                 http_timeout: float = 15.0,
                 active_scan_async_q: Optional[asyncio.Queue] = None
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.oast_base_url = self._normalize_oast_url(oast_base_url) if oast_base_url else None
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q

    def _normalize_oast_url(self, url: str) -> Optional[str]:
        if not url: return None
        parsed = urllib.parse.urlparse(url)
        return parsed.netloc if parsed.netloc else None

    async def _send_request(
        self, session: aiohttp.ClientSession, method: str, url: str,
        headers: Optional[Dict[str, str]] = None, params: Optional[Dict[str, Any]] = None,
        data: Optional[Any] = None, allow_redirects: bool = True
    ) -> Tuple[Optional[aiohttp.ClientResponse], str, Dict[str, str], Optional[bytes]]:
        req_headers = (headers or {}).copy()
        if "User-Agent" not in req_headers:
            req_headers["User-Agent"] = f"ASPNetScanner/1.0 ({uuid.uuid4().hex[:8]})"

        self.logger.debug(f"ASPNetScan: {method} {url}, Headers: {req_headers.keys()}, Data: {str(data)[:100] if data else 'None'}")
        resp_text, resp_headers_dict, resp_bytes = "", {}, None
        resp_obj = None
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.request(
                method.upper(), url, headers=req_headers, params=params, data=data,
                timeout=timeout, allow_redirects=allow_redirects
            ) as resp:
                resp_obj = resp
                try:
                    resp_bytes = await resp.read()
                    resp_text = resp_bytes.decode(errors='replace')
                except Exception as e_read:
                    self.logger.warning(f"Error reading response from {url}: {e_read}")
                resp_headers_dict = dict(resp.headers)
                self.logger.debug(f"ASPNetScan: Response from {url}: Status {resp.status}")
        except asyncio.TimeoutError:
            self.logger.warning(f"ASPNetScan: Request to {url} timed out.")
        except aiohttp.ClientError as e:
            self.logger.warning(f"ASPNetScan: Request to {url} client error: {e}")
        except Exception as e_req:
            self.logger.error(f"ASPNetScan: Unexpected error for {url}: {e_req}")
        return resp_obj, resp_text, resp_headers_dict, resp_bytes

    async def _emit_alert(self, alert_obj: ASPNetVulnerabilityAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({
                    "type": "active_scan_alert", "alert": alert_obj.as_dict()
                })
                self.logger.info(f"ASPNetScan: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"ASPNetScan: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"ASPNetScan: Async queue not available. Alert not emitted: {alert_obj.name}")

    # --- General ASP.NET Checks ---
    async def _check_trace_axd(self, session: aiohttp.ClientSession, base_app_url: str):
        target_url = urllib.parse.urljoin(base_app_url, self.TRACE_AXD_PATH.lstrip('/'))
        self.logger.debug(f"ASPNetScan: Checking for trace.axd at {target_url}")
        resp_obj, resp_text, _, _ = await self._send_request(session, "GET", target_url)

        if resp_obj and resp_obj.status == 200 and "Application Trace" in resp_text and "Request Details" in resp_text:
            alert = ASPNetVulnerabilityAlert(
                cwe_id=532, wasc_id=13, # Information Exposure Through Log Files
                name="ASP.NET trace.axd Exposed",
                description="ASP.NET application tracing (trace.axd) is enabled and publicly accessible, potentially leaking sensitive information.",
                uri=target_url,
                attack_details={"check_type": "InfoDisclosure", "path": self.TRACE_AXD_PATH, "method": "GET"},
                evidence=f"HTTP 200 and 'Application Trace' content found at {target_url}.",
                reference="https://docs.microsoft.com/en-us/previous-versions/aspnet/0x53a0c1",
                risk=2, confidence=3,
                alert_tags={"Framework": "ASP.NET", "Vulnerability": "InformationDisclosure", "Component": "trace.axd"}
            )
            await self._emit_alert(alert)

    async def _check_elmah_axd(self, session: aiohttp.ClientSession, base_app_url: str):
        target_url = urllib.parse.urljoin(base_app_url, self.ELMAH_AXD_PATH.lstrip('/'))
        self.logger.debug(f"ASPNetScan: Checking for elmah.axd at {target_url}")
        resp_obj, resp_text, _, _ = await self._send_request(session, "GET", target_url)

        if resp_obj and resp_obj.status == 200 and "Error Log for" in resp_text and "ELMAH" in resp_text:
            alert = ASPNetVulnerabilityAlert(
                cwe_id=532, wasc_id=13,
                name="ELMAH (Error Logging Modules and Handlers) Exposed",
                description="ELMAH error logs (elmah.axd) are publicly accessible, potentially leaking sensitive information, stack traces, and internal application details.",
                uri=target_url,
                attack_details={"check_type": "InfoDisclosure", "path": self.ELMAH_AXD_PATH, "method": "GET"},
                evidence=f"HTTP 200 and 'ELMAH' content found at {target_url}.",
                reference="https://elmah.github.io/",
                risk=3, confidence=3,
                alert_tags={"Framework": "ASP.NET", "Vulnerability": "InformationDisclosure", "Component": "elmah.axd"}
            )
            await self._emit_alert(alert)

    async def _check_detailed_errors(self, session: aiohttp.ClientSession, base_app_url: str):
        # Try a non-existent .aspx page
        non_existent_page = f"NonExistentPage{uuid.uuid4().hex[:6]}.aspx"
        target_url = urllib.parse.urljoin(base_app_url, non_existent_page)
        self.logger.debug(f"ASPNetScan: Checking for detailed errors at {target_url}")
        resp_obj, resp_text, _, _ = await self._send_request(session, "GET", target_url)

        if resp_obj and resp_obj.status >= 500: # Typically 500 for server errors, 404 if customErrors is On and handles it
            # Look for signs of customErrors="Off"
            if "Server Error in '/' Application." in resp_text or \
               "Stack Trace:" in resp_text or \
               "Version Information:" in resp_text or \
               "System.Web.HttpException" in resp_text:
                alert = ASPNetVulnerabilityAlert(
                    cwe_id=200, wasc_id=13, # Information Exposure
                    name="ASP.NET Detailed Error Messages Exposed (customErrors='Off')",
                    description="The application is configured to display detailed ASP.NET error messages (customErrors='Off' or similar), which can leak stack traces, version information, and internal paths.",
                    uri=target_url,
                    attack_details={"check_type": "InfoDisclosure", "path": non_existent_page, "method": "GET"},
                    evidence=f"HTTP {resp_obj.status} with detailed error content (e.g., 'Stack Trace:') at {target_url}.",
                    reference="https://docs.microsoft.com/en-us/dotnet/web/custom-errors",
                    risk=2, confidence=3,
                    alert_tags={"Framework": "ASP.NET", "Vulnerability": "InformationDisclosure", "Configuration": "customErrors"}
                )
                await self._emit_alert(alert)

    async def _check_aspnet_cookie_security(self, session: aiohttp.ClientSession, base_app_url: str):
        self.logger.debug(f"ASPNetScan: Checking cookie security for {base_app_url}")
        # Make a request to a common page that likely sets session cookies
        # (e.g., the base URL itself, or a known .aspx page if available)
        # For simplicity, using base_app_url.
        resp_obj, _, resp_headers, _ = await self._send_request(session, "GET", base_app_url)

        if resp_obj:
            set_cookie_headers = resp_obj.headers.getall("Set-Cookie", [])
            if not set_cookie_headers and hasattr(resp_obj, 'cookies'): # Fallback for aiohttp's cookie jar if Set-Cookie not directly in headers
                set_cookie_headers = [f"{name}={cookie.value};" for name, cookie in resp_obj.cookies.items()]


            asp_session_cookie_name = "ASP.NET_SessionId"
            forms_auth_cookie_name = ".ASPXAUTH" # Common forms auth cookie

            cookies_to_check = {
                asp_session_cookie_name: {"HttpOnly": False, "Secure": False, "SameSite": False},
                forms_auth_cookie_name: {"HttpOnly": False, "Secure": False, "SameSite": False}
            }
            found_cookies_details = {}

            for cookie_header in set_cookie_headers:
                cookie_name_match = re.match(r"([^=]+)=", cookie_header)
                if not cookie_name_match: continue
                cookie_name = cookie_name_match.group(1)

                if cookie_name in cookies_to_check:
                    found_cookies_details[cookie_name] = cookie_header
                    if "httponly" in cookie_header.lower():
                        cookies_to_check[cookie_name]["HttpOnly"] = True
                    if "secure" in cookie_header.lower():
                        cookies_to_check[cookie_name]["Secure"] = True
                    if "samesite" in cookie_header.lower(): # Basic check, doesn't validate Lax/Strict/None
                        cookies_to_check[cookie_name]["SameSite"] = True
            
            is_https = base_app_url.lower().startswith("https://")

            for name, flags in cookies_to_check.items():
                if name not in found_cookies_details: continue # Only check cookies that were actually set

                missing_flags_desc = []
                if not flags["HttpOnly"]:
                    missing_flags_desc.append("HttpOnly")
                if is_https and not flags["Secure"]: # Secure flag only critical over HTTPS
                    missing_flags_desc.append("Secure")
                # SameSite is more complex, but lack of any SameSite is a finding
                if not flags["SameSite"]:
                     missing_flags_desc.append("SameSite")


                if missing_flags_desc:
                    alert = ASPNetVulnerabilityAlert(
                        cwe_id=1004 if name == asp_session_cookie_name else 614, # Sensitive Cookie Without 'HttpOnly' / Sensitive Cookie in HTTPS Session Without 'Secure' Attribute
                        wasc_id=13, # Information Leakage (for session hijacking potential)
                        name=f"ASP.NET Cookie '{name}' Missing Security Flags",
                        description=f"The ASP.NET cookie '{name}' is missing the following security flags: {', '.join(missing_flags_desc)}. This can increase risk of session hijacking or other attacks.",
                        uri=base_app_url,
                        attack_details={"check_type": "CookieSecurity", "cookie_name": name, "missing_flags": missing_flags_desc},
                        evidence=f"Cookie '{name}' set with header: '{found_cookies_details[name]}'. Missing: {', '.join(missing_flags_desc)}.",
                        reference="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/02-Testing_for_Cookies_Attributes",
                        risk=2, confidence=3,
                        alert_tags={"Framework": "ASP.NET", "Vulnerability": "CookieSecurity", "CookieName": name}
                    )
                    await self._emit_alert(alert)

    async def _check_telerik_ui_exposure_and_vulns(self, session: aiohttp.ClientSession, base_app_url: str):
        telerik_resource_url = urllib.parse.urljoin(base_app_url, self.TELERIK_WEBRESOURCE_PATH.lstrip('/'))
        self.logger.debug(f"ASPNetScan: Checking for Telerik WebResource at {telerik_resource_url}")
        resp_obj, resp_text, _, _ = await self._send_request(session, "GET", telerik_resource_url)

        if resp_obj and resp_obj.status == 200 and ("Telerik.Web.UI" in resp_text or "RadScriptManager" in resp_text or "RadStyleSheetManager" in resp_text):
            alert = ASPNetVulnerabilityAlert(
                cwe_id=200, # Information Exposure (presence of component)
                name="Telerik UI for ASP.NET AJAX WebResource Exposed",
                description=(
                    f"The Telerik WebResource handler ({self.TELERIK_WEBRESOURCE_PATH}) is accessible. "
                    "Older or misconfigured versions of Telerik UI for ASP.NET AJAX are known to have critical vulnerabilities (e.g., CVE-2019-18935 RCE, CVE-2017-11317 RCE). "
                    "Further investigation for specific Telerik CVEs is recommended."
                ),
                uri=telerik_resource_url,
                attack_details={"check_type": "ComponentExposure", "path": self.TELERIK_WEBRESOURCE_PATH, "method": "GET"},
                evidence=f"HTTP 200 and Telerik-specific content found at {telerik_resource_url}. Snippet: {html.escape(resp_text[:150])}",
                reference="https://www.telerik.com/support/kb/aspnet-ajax/details/cryptographic-weakness, https://www.cve.org/CVERecord?id=CVE-2019-18935",
                risk=2, confidence=3, # Risk is for exposure, actual CVE would be higher
                alert_tags={"Framework": "ASP.NET", "Vulnerability": "ComponentExposure", "Component": "TelerikUI"}
            )
            await self._emit_alert(alert)

            # Placeholder for CVE-2019-18935 (RAU RCE) check - this is complex
            # A non-intrusive check might look for specific versions if exposed, or try to see if default keys are used (hard).
            # An active check would involve sending a crafted payload to RadAsyncUpload, which is risky.
            # For now, we've alerted on exposure.

            # Placeholder for CVE-2017-11317 (Dialog Handler RCE)
            # This would involve checking specific dialog handler URLs and parameters.
            # Example: /Telerik.Web.UI.DialogHandler.aspx?DialogName=FileBrowser&...
            # For now, we've alerted on general Telerik exposure.

    # --- CVE-Specific Checks ---
    async def _check_viewstate_xss_cve20040847(
        self, session: aiohttp.ClientSession, original_url: str, html_content_with_viewstate: str
    ):
        cve_id = "CVE-2004-0847"
        self.logger.debug(f"ASPNetScan ({cve_id}): Checking ViewState XSS for {original_url}")

        soup = BeautifulSoup(html_content_with_viewstate, 'html.parser')
        viewstate_tag = soup.find('input', {'name': '__VIEWSTATE'})
        if not viewstate_tag or not viewstate_tag.get('value'):
            self.logger.debug(f"ASPNetScan ({cve_id}): No __VIEWSTATE found on {original_url}")
            return

        original_viewstate_b64 = viewstate_tag['value']
        
        # Collect other form parameters to POST back
        form_data_to_post = {}
        for input_tag in soup.find_all('input'):
            name = input_tag.get('name')
            value = input_tag.get('value', '')
            if name and name not in ['__VIEWSTATE']: # Exclude original viewstate, we'll add modified one
                form_data_to_post[name] = value
        
        # Heuristic: Try appending payload to Base64 decoded, then re-encode.
        # This is a very simplified check and likely won't bypass MAC or encryption on modern systems.
        try:
            # Try to decode. If it fails, it might be encrypted or not plain Base64.
            # For this old CVE, it might be just Base64.
            decoded_viewstate_bytes = base64.b64decode(original_viewstate_b64)
            # Try to decode as UTF-8, if fails, treat as opaque bytes
            try:
                decoded_viewstate_str = decoded_viewstate_bytes.decode('utf-8')
                modified_viewstate_str = decoded_viewstate_str + self.VIEWSTATE_XSS_PAYLOAD
                modified_viewstate_bytes = modified_viewstate_str.encode('utf-8')
            except UnicodeDecodeError:
                # If not valid UTF-8, just append bytes
                modified_viewstate_bytes = decoded_viewstate_bytes + self.VIEWSTATE_XSS_PAYLOAD.encode('utf-8', 'ignore')
            
            tampered_viewstate_b64 = base64.b64encode(modified_viewstate_bytes).decode('utf-8')
        except Exception: # If any error in decoding/encoding, try raw tampering
            self.logger.debug(f"ASPNetScan ({cve_id}): ViewState not simple Base64. Trying raw append.")
            tampered_viewstate_b64 = original_viewstate_b64 + base64.b64encode(self.VIEWSTATE_XSS_PAYLOAD.encode()).decode()


        form_data_to_post['__VIEWSTATE'] = tampered_viewstate_b64
        
        # Determine form action and method
        form_tag = viewstate_tag.find_parent('form')
        action_url = original_url
        method = "POST" # ViewState is typically POSTed
        if form_tag:
            action = form_tag.get('action')
            if action:
                action_url = urllib.parse.urljoin(original_url, action)
            if form_tag.get('method'):
                method = form_tag.get('method').upper()

        if method != "POST":
            self.logger.debug(f"ASPNetScan ({cve_id}): ViewState form is not POST. Skipping.")
            return

        self.logger.debug(f"ASPNetScan ({cve_id}): Posting tampered ViewState to {action_url}")
        resp_obj, resp_text, _, _ = await self._send_request(session, "POST", action_url, data=form_data_to_post)

        if resp_obj and resp_text and self.VIEWSTATE_XSS_PAYLOAD in resp_text:
            # Further check if it's actually rendered unescaped (simplified here)
            if f">{self.VIEWSTATE_XSS_PAYLOAD}<" in resp_text or f"'{self.VIEWSTATE_XSS_PAYLOAD}'" in resp_text or f"\"{self.VIEWSTATE_XSS_PAYLOAD}\"" in resp_text:
                alert = ASPNetVulnerabilityAlert(
                    cwe_id=79, wasc_id=8,
                    name=f"ASP.NET ViewState XSS (Potential {cve_id})",
                    description=(
                        f"Potential XSS vulnerability related to __VIEWSTATE handling. A crafted payload injected into ViewState was reflected in the response. "
                        f"This is indicative of issues like {cve_id} on older or misconfigured systems."
                    ),
                    uri=action_url,
                    attack_details={"cve": cve_id, "check_type": "ViewStateXSS", "parameter": "__VIEWSTATE", "payload": self.VIEWSTATE_XSS_PAYLOAD, "method": "POST"},
                    evidence=f"Payload '{self.VIEWSTATE_XSS_PAYLOAD}' reflected in response after POSTing tampered ViewState. Snippet: ...{html.escape(resp_text[max(0, resp_text.find(self.VIEWSTATE_XSS_PAYLOAD)-30):resp_text.find(self.VIEWSTATE_XSS_PAYLOAD)+len(self.VIEWSTATE_XSS_PAYLOAD)+30])}...",
                    reference=f"https://nvd.nist.gov/vuln/detail/{cve_id}",
                    risk=3, confidence=1, # Low confidence due to simplified check and age of CVE
                    alert_tags={"Framework": "ASP.NET", "Vulnerability": "XSS", "Component": "ViewState", "CVE": cve_id}
                )
                await self._emit_alert(alert)

    async def _check_dnn_deserialization_cve202332571(
        self, session: aiohttp.ClientSession, base_app_url: str, service_type_hint: Optional[str]
    ):
        cve_id = "CVE-2023-32571"
        if not (service_type_hint and ("dotnetnuke" in service_type_hint.lower() or "dnn" in service_type_hint.lower())):
            return # Only run if DNN is hinted

        self.logger.info(f"ASPNetScan ({cve_id}): Target identified as DotNetNuke. Checking for signs related to {cve_id}.")
        # Specifics of CVE-2023-32571:
        # "DotNetNuke (DNN) versions between 5.0.0 and 9.10.2 are vulnerable to a deserialization attack that can lead to remote code execution."
        # This usually involves finding an endpoint that accepts serialized data (often XML or binary .NET objects)
        # and sending a crafted payload.

        # Step 1: Try to identify DNN version (often difficult without admin access or specific info leak)
        # A simple check might be for common DNN paths or generator tags, but version detection is harder.
        # For now, we'll assume if it's DNN, it *could* be vulnerable if version is in range.

        # Step 2: Identify known vulnerable endpoints for this CVE (if public info exists)
        # Without specific public details on *which* endpoints are vulnerable and *how* they accept serialized data
        # for this CVE, a generic active check is very hard.
        # A true active check would require sending a ysoserial.net payload (OAST-based) to such an endpoint.

        # For this initial rule, we will raise an informational alert if DNN is detected,
        # pointing to the CVE and recommending manual investigation or version checking.
        # A more advanced rule would need details on vulnerable parameters/endpoints.
        
        # Example: Check for a known DNN file that might indicate its presence strongly.
        dnn_readme_url = urllib.parse.urljoin(base_app_url, "/Install/DotNetNuke_Community_Edition_Source.readme") # Example path
        resp_obj, resp_text, _, _ = await self._send_request(session, "GET", dnn_readme_url)

        dnn_presence_evidence = ""
        if resp_obj and resp_obj.status == 200 and "DotNetNuke" in resp_text:
            dnn_presence_evidence = f"Found DotNetNuke indicator at {dnn_readme_url}."
        else: # If specific file not found, rely on the service_type_hint
            dnn_presence_evidence = f"Service hinted as '{service_type_hint}'."


        alert = ASPNetVulnerabilityAlert(
            cwe_id=502, # Deserialization of Untrusted Data
            name=f"Potential DotNetNuke (DNN) Deserialization RCE ({cve_id})",
            description=(
                f"The target is identified as DotNetNuke (DNN). Versions 5.0.0 through 9.10.2 are potentially vulnerable to {cve_id}, "
                "a deserialization vulnerability that can lead to Remote Code Execution. "
                "Active exploitation is complex and requires specific knowledge of vulnerable endpoints and payload crafting. "
                "Manual verification of DNN version and patch status is strongly recommended."
            ),
            uri=base_app_url,
            attack_details={"cve": cve_id, "check_type": "DNN Deserialization Potential", "service_hint": service_type_hint},
            evidence=f"{dnn_presence_evidence} Consider CVE-2023-32571 if DNN version is between 5.0.0 and 9.10.2.",
            reference=f"https://nvd.nist.gov/vuln/detail/{cve_id}",
            risk=4, confidence=1, # Low confidence without version check or active exploit attempt
            alert_tags={"Framework": "DotNetNuke", "Vulnerability": "RCE_Potential", "CVE": cve_id, "Type": "Deserialization"}
        )
        await self._emit_alert(alert)


    # --- Main Scan Orchestration Method ---
    async def scan(
        self,
        base_app_url: str,
        aiohttp_session: aiohttp.ClientSession,
        service_type_hint: Optional[str] = None, # e.g., "aspnet_boilerplate", "akilli_ticaret", "dotnetnuke", "generic_aspnet"
        original_url: Optional[str] = None, # The specific URL that triggered this scan
        original_headers: Optional[Dict[str, str]] = None,
        original_cookies: Optional[Dict[str, str]] = None,
        injection_details: Optional[Dict[str, Any]] = None, # For parameter-specific checks (not heavily used by this rule yet)
        html_content: Optional[str] = None # HTML of original_url, useful for ViewState
    ):
        self.logger.info(f"ASPNetScanRule: Starting scan for base_url='{base_app_url}', service_hint='{service_type_hint}', specific_page='{original_url}'")

        # Normalize base_app_url
        parsed_base = urllib.parse.urlparse(base_app_url)
        normalized_base_app_url = f"{parsed_base.scheme}://{parsed_base.netloc}{parsed_base.path.rstrip('/')}/"
        
        # URL for checks that should run against the specific page that triggered the scan
        # If original_url is not provided, default to normalized_base_app_url
        page_specific_url = original_url if original_url else normalized_base_app_url


        # --- General ASP.NET Checks (run against base_app_url) ---
        # These are typically server-wide configurations.
        await self._check_trace_axd(aiohttp_session, normalized_base_app_url)
        await self._check_elmah_axd(aiohttp_session, normalized_base_app_url)
        await self._check_detailed_errors(aiohttp_session, normalized_base_app_url)
        await self._check_telerik_ui_exposure_and_vulns(aiohttp_session, normalized_base_app_url)
        
        # Cookie security check should be done on a page that sets cookies,
        # page_specific_url is a good candidate.
        await self._check_aspnet_cookie_security(aiohttp_session, page_specific_url)

        # --- CVE-Specific Checks ---
        # CVE-2004-0847 (ViewState XSS) - needs HTML content of a page with ViewState
        if html_content: # If HTML content of the original_url is available
            soup = BeautifulSoup(html_content, 'html.parser')
            if soup.find('input', {'name': '__VIEWSTATE'}):
                await self._check_viewstate_xss_cve20040847(aiohttp_session, page_specific_url, html_content)
        
        # CVE-2023-32571 (DNN Deserialization)
        # This check is primarily informational based on service_type_hint
        await self._check_dnn_deserialization_cve202332571(aiohttp_session, normalized_base_app_url, service_type_hint)

        # --- Placeholder for Framework/Product Specific Checks ---
        # if service_type_hint == "aspnet_boilerplate":
        #     # Call checks specific to ASP.NET Boilerplate
        # elif service_type_hint == "akilli_ticaret":
        #     # Call checks specific to Akilli Ticaret
        # elif service_type_hint == "abp_framework":
        #     # Call checks specific to ABP Framework
        # These would require known unauthenticated CVEs for those products.

        self.logger.info(f"ASPNetScanRule: Scan finished for {base_app_url}")