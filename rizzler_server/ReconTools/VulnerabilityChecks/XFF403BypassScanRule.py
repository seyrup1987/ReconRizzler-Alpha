# Filename: VulnerabilityChecks/XFF403BypassScanRule.py

import asyncio
import logging
import random
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Set, Tuple

import aiohttp

# --- Alert Definition ---
@dataclass
class XFF403BypassAlert:
    cwe_id: int
    name: str
    description: str
    uri: str         # The URL of the application endpoint tested
    attack_header: str # e.g., "X-Forwarded-For: 127.0.0.1"
    evidence: str    # Description of how bypass was detected

    wasc_id: int = 14 # WASC-14: Server Misconfiguration (related to proxy/ACL setup)
    other_info: str = ""
    solution: str = (
        "Ensure that access control decisions are not solely based on the apparent source IP address when the application is behind a reverse proxy or load balancer. "
        "If X-Forwarded-For or similar headers are used for logging or application logic, they must be treated as untrusted user input. "
        "Configure the edge proxy/WAF to correctly set/overwrite these headers with trusted values. "
        "Implement robust access controls at the application layer based on authenticated user identity and roles, not just IP."
    )
    reference: str = (
        "CWE-290: Authentication Bypass by Spoofing - https://cwe.mitre.org/data/definitions/290.html\n"
        "OWASP Testing Guide: Test HTTP Verb Tampering (OTG-INPVAL-003) - (Related concept of bypassing controls via request modification)\n"
        "PortSwigger: Bypassing access controls via HTTP headers - https://portswigger.net/web-security/access-control/lab-http-header-bypass"
    )
    risk: int = 2  # Medium, as it bypasses an intended restriction
    confidence: int = 3 # High if conditions are met
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A01": "Broken Access Control",
        "OWASP_2017_A05": "Broken Access Control",
        "WSTG_V42_ATHZ_04": "Testing_for_Bypassing_Authorization_Schema", # Closest WSTG
        "Technique": "Header_Spoofing_XFF"
    })
    attack_details: Dict[str, Any] = field(default_factory=dict)

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": "Access Control Bypass (XFF)",
            "type": self.name,
            "detail": self.description,
            "payload_used": f"Header: {self.attack_header}", # Payload is the header itself
            "injection_point_info": "HTTP Header (X-Forwarded-For)",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": self.alert_tags,
            "other_info": self.other_info
        }

class XFF403BypassScanRule:
    tech_required: Set[str] = set() # Generally applicable if a proxy might be in use

    # Common internal/localhost IPs for X-Forwarded-For
    XFF_PAYLOAD_VALUES = "127.0.0.1, 0.0.0.0, 192.168.0.1, 10.0.0.1, 172.16.0.1, ::1"
    # Can also try single IPs from this list, or other common private ranges.
    # The Nuclei template uses a comma-separated list. Some proxies might pick the first, others the last.
    # For simplicity, we'll use the combined string as per the template.
    # More advanced versions could iterate through individual IPs or different X-header combinations.

    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 http_timeout: float = 10.0,
                 active_scan_async_q: Optional[asyncio.Queue] = None
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q
        self.logger.debug("XFF403BypassScanRule initialized.")

    async def _emit_alert(self, alert_obj: XFF403BypassAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({
                    "type": "active_scan_alert", "alert": alert_obj.as_dict()
                })
                self.logger.info(f"XFF403BypassScan: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"XFF403BypassScan: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"XFF403BypassScan: Async queue not available. Alert not emitted: {alert_obj.name}")

    async def _make_request(
        self, session: aiohttp.ClientSession, method: str, url: str,
        headers: Optional[Dict[str, str]], cookies: Optional[Dict[str, str]]
    ) -> Tuple[int, Optional[str]]:
        status_code = 0
        response_text: Optional[str] = None
        
        current_headers = (headers or {}).copy()
        if "User-Agent" not in current_headers:
             current_headers["User-Agent"] = "Mozilla/5.0 XFF-Bypass-Scanner/1.0"
        if "Accept" not in current_headers: # As per Nuclei template
            current_headers["Accept"] = "*/*"
        
        self.logger.debug(f"XFF403BypassScan: Sending {method} to {url} with headers: {current_headers.keys()}")
        
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.request(method.upper(), url, headers=current_headers, cookies=cookies, timeout=timeout, allow_redirects=False) as resp:
                status_code = resp.status
                try:
                    response_text = await resp.text(errors='replace')
                except Exception as e_read:
                    self.logger.debug(f"XFF403BypassScan: Error reading response body from {url}: {e_read}")
        except asyncio.TimeoutError:
            self.logger.debug(f"XFF403BypassScan: Request to {url} timed out.")
            status_code = -1 # Indicate timeout
        except aiohttp.ClientError as e:
            self.logger.debug(f"XFF403BypassScan: ClientError for {url}: {type(e).__name__}")
            status_code = -2 # Indicate client error
        except Exception as e:
            self.logger.error(f"XFF403BypassScan: Unexpected error for {url}: {e}", exc_info=True)
            status_code = -3 # Indicate other error
            
        return status_code, response_text


    async def scan(
        self,
        original_url: str, # The URL that returned 403 or is being tested
        aiohttp_session: aiohttp.ClientSession,
        original_headers: Dict[str, str],
        original_cookies: Dict[str, str],
        worker_ident: Optional[str] = "XFF403BypassScan",
        # Other common args for compatibility
        base_app_url: Optional[str] = None, 
        html_content: Optional[str] = None, # HTML of original_url if it was fetched
        injection_details: Optional[Dict[str, Any]] = None, # Not directly used for parameter injection here
        page_specific_technologies: Optional[List[str]] = None,
        service_type_hint: Optional[str] = None, # e.g., "HTTP_403_FORBIDDEN_PAGE_DETECTED"
        attack_strength: str = "MEDIUM" # Not heavily used by this rule, as it's a specific check
    ) -> None:
        
        # This rule is typically run on URLs that are known to be 403,
        # or as a general check on important paths.
        # The `service_type_hint` "HTTP_403_FORBIDDEN_PAGE_DETECTED" is a strong indicator.

        target_url = original_url # We test the URL directly
        http_method = "GET" # Nuclei template uses GET

        self.logger.info(f"[{worker_ident}] Starting XFF 403 Bypass scan for {target_url}")

        # 1. Make the first request (baseline) without XFF header modification
        self.logger.debug(f"[{worker_ident}] Sending baseline request to {target_url}")
        status_code_1, _ = await self._make_request(
            aiohttp_session, http_method, target_url, original_headers, original_cookies
        )

        if status_code_1 != 403:
            self.logger.info(f"[{worker_ident}] Baseline request to {target_url} did not return 403 (got {status_code_1}). Skipping XFF bypass test for this URL.")
            return

        self.logger.debug(f"[{worker_ident}] Baseline request to {target_url} returned 403. Proceeding with XFF test.")

        # 2. Make the second request with the X-Forwarded-For header
        headers_with_xff = original_headers.copy()
        xff_header_value = self.XFF_PAYLOAD_VALUES
        headers_with_xff["X-Forwarded-For"] = xff_header_value
        
        # Also try common variations if the first one fails, or based on attack_strength
        # For simplicity, this version uses the primary payload from Nuclei.
        # Other headers to consider for more comprehensive checks:
        # X-Real-IP, X-Client-IP, X-Originating-IP, Forwarded, etc.

        self.logger.debug(f"[{worker_ident}] Sending request to {target_url} with X-Forwarded-For: {xff_header_value}")
        status_code_2, response_text_2 = await self._make_request(
            aiohttp_session, http_method, target_url, headers_with_xff, original_cookies
        )

        # Check the condition: status_code_1 == 403 && status_code_2 != 403
        if status_code_1 == 403 and status_code_2 != 403 and status_code_2 > 0: # status_code_2 > 0 ensures it wasn't a network error
            evidence_str = (
                f"Initial request to {target_url} returned HTTP {status_code_1}. "
                f"Request with 'X-Forwarded-For: {xff_header_value}' returned HTTP {status_code_2}. "
                f"This change in status code indicates a potential bypass of access controls."
            )
            alert = XFF403BypassAlert(
                cwe_id=290, # Authentication Bypass by Spoofing
                name="X-Forwarded-For Header 403 Forbidden Bypass",
                description=(
                    f"The application returned an HTTP 403 Forbidden status for a standard request to {target_url}. "
                    f"However, by including an 'X-Forwarded-For' header with internal IP addresses (e.g., '{xff_header_value}'), "
                    f"the access restriction was bypassed, and the server responded with HTTP {status_code_2}. "
                    "This suggests that the application or an upstream proxy trusts the X-Forwarded-For header for access control decisions."
                ),
                uri=target_url,
                attack_header=f"X-Forwarded-For: {xff_header_value}",
                evidence=evidence_str,
                other_info=f"Original status: {status_code_1}, Status with XFF: {status_code_2}.",
                attack_details={"method": http_method, "header_used": "X-Forwarded-For", "header_value": xff_header_value}
            )
            await self._emit_alert(alert)
            self.logger.info(f"[{worker_ident}] Confirmed XFF 403 Bypass for {target_url}. Original: {status_code_1}, With XFF: {status_code_2}")
        else:
            self.logger.info(f"[{worker_ident}] XFF 403 Bypass attempt for {target_url} did not succeed. Original: {status_code_1}, With XFF: {status_code_2 if status_code_2 > 0 else 'Error/Timeout'}")
        
        self.logger.debug(f"[{worker_ident}] XFF 403 Bypass scan finished for {target_url}.")