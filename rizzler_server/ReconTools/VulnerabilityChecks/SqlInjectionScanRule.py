# Filename: VulnerabilityChecks/SqlInjectionScanRule.py

import asyncio
import html
import logging
import random
import re
import time
import urllib.parse
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple, Pattern, Callable, Set

import aiohttp

# --- Alert Definition ---
@dataclass
class SQLiAlert: # Renamed for clarity and consistency
    # Non-default fields first
    cwe_id: int
    name: str
    description: str
    uri: str
    param: str
    attack: str
    evidence: str
    
    # Default fields
    wasc_id: int = 19
    other_info: str = ""
    solution: str = (
        "Use parameterized queries (prepared statements) to prevent SQL Injection. "
        "Validate and sanitize all user-supplied input. "
        "Implement least privilege access to the database."
    )
    reference: str = (
        "https://owasp.org/www-community/attacks/SQL_Injection\n"
        "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
    )
    risk: int = 4
    confidence: int = 3
    rdbms: Optional[str] = None
    injection_type: Optional[str] = None
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "OWASP_2021_A03": "Injection",
        "OWASP_2017_A01": "Injection",
        "WSTG_V42_INPV_05": "SQL_Injection"
    })
    attack_details: Dict[str, Any] = field(default_factory=dict)

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": "SQL Injection",
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack,
            "injection_point_info": f"Param: {self.param}, Location: {self.attack_details.get('location', 'N/A')}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "rdbms": self.rdbms,
            "injection_type": self.injection_type,
            "alert_tags": self.alert_tags,
            "other_info": self.other_info,
            "attack_details_dict": self.attack_details
        }

# --- RDBMS Definitions ---
class Tech(Enum):
    MySQL = "MySQL"; MsSQL = "Microsoft SQL Server"; Oracle = "Oracle"; PostgreSQL = "PostgreSQL"
    SQLite = "SQLite"; Sybase = "Sybase"; Db2 = "IBM DB2"; Informix = "Informix"
    Firebird = "Firebird"; HypersonicSQL = "Hypersonic SQL"; GENERIC_DB = "Generic RDBMS"
    def __str__(self): return self.value

class RDBMS:
    def __init__(self, name: str, tech: Tech, error_regexes: List[str], union_error_regexes: Optional[List[str]] = None):
        self.name: str = name; self.tech: Tech = tech
        self.error_patterns: List[Pattern] = [re.compile(p, re.IGNORECASE | re.DOTALL) for p in error_regexes]
        self.union_error_patterns: List[Pattern] = [re.compile(p, re.IGNORECASE | re.DOTALL) for p in (union_error_regexes or [])]
    def is_generic(self) -> bool: return self.tech == Tech.GENERIC_DB

RDBMS_DEFINITIONS = [
    RDBMS("MySQL", Tech.MySQL, [r"You have an error in your SQL syntax", r"com\.mysql\.jdbc\.exceptions", r"The used SELECT statements have a different number of columns"], [r"The used SELECT statements have a different number of columns"]),
    RDBMS("Microsoft SQL Server", Tech.MsSQL, [r"com\.microsoft\.sqlserver\.jdbc", r"\[Microsoft\]\[SQL Server\]", r"Unclosed quotation mark after the character string", r"All queries combined using a UNION.+must have an equal number of expressions"], [r"All queries combined using a UNION.+must have an equal number of expressions"]),
    RDBMS("Oracle", Tech.Oracle, [r"ORA-\d{5}:", r"oracle\.jdbc", r"query block has incorrect number of result columns"], [r"query block has incorrect number of result columns", r"ORA-01789", r"ORA-01790"]),
    RDBMS("PostgreSQL", Tech.PostgreSQL, [r"org\.postgresql\.util\.PSQLException", r"ERROR:  syntax error at or near", r"each UNION query must have the same number of columns"], [r"each UNION query must have the same number of columns"]),
    RDBMS("SQLite", Tech.SQLite, [r"near \".+\": syntax error", r"SQLiteException", r"SELECTs to the left and right of UNION do not have the same number of result columns"], [r"SELECTs to the left and right of UNION do not have the same number of result columns"]),
    RDBMS("Sybase", Tech.Sybase, [r"com\.sybase\.jdbc", r"net\.sourceforge\.jtds\.jdbc"]),
    RDBMS("IBM DB2", Tech.Db2, [r"com\.ibm\.db2\.jcc"]), RDBMS("Informix", Tech.Informix, [r"com\.informix\.jdbc"]),
    RDBMS("Firebird", Tech.Firebird, [r"org\.firebirdsql\.jdbc"]),
    RDBMS("Hypersonic SQL", Tech.HypersonicSQL, [r"org\.hsql", r"Unexpected token , requires FROM", r"Column count does not match"], [r"Column count does not match"]),
    RDBMS("Generic RDBMS", Tech.GENERIC_DB, [r"java\.sql\.SQLException", r"System\.Data\.OleDb\.OleDbException", r"Invalid SQL statement"])
]
# --- SQL Payloads and Constants ---
SQL_ONE_LINE_COMMENT = " -- "
SQL_SINGLE_QUOTE = "'"
SQL_CHECK_ERRORS = [SQL_SINGLE_QUOTE, "\"", ";", "'(", ")", "(", "NULL", "'\""]
SQL_LIKE_PLACEHOLDER = "%"
SQL_LIKE_SAFE_PLACEHOLDER = "XYZABCDEFGHIJ"
BOOLEAN_TESTS = [(" AND {true_cond}{comment}", " AND {false_cond}{comment}", "", True), ("{quote} AND {true_cond}{quote}{comment}", "{quote} AND {false_cond}{quote}{comment}", "'", True), (SQL_LIKE_PLACEHOLDER, SQL_LIKE_SAFE_PLACEHOLDER, "", False)]
BOOLEAN_OR_TESTS = [(" OR {true_cond}{comment}", " AND {false_cond}{comment}", "", True), ("{quote} OR {true_cond}{quote}{comment}", "{quote} AND {false_cond}{quote}{comment}", "'", True)]
SQL_UNION_SELECT_NULL = " UNION ALL SELECT NULL"
SQL_UNION_PAYLOAD_TEMPLATES = ["{value}" + SQL_UNION_SELECT_NULL + "{comment}", "{value}{quote}" + SQL_UNION_SELECT_NULL + "{comment}"]
ORDER_BY_TESTS = [(" ASC" + SQL_ONE_LINE_COMMENT, " DESC" + SQL_ONE_LINE_COMMENT), (" ASC", " DESC")]
EXPRESSION_TESTS_NUMERIC = [(lambda v: f"{v+2-2}", lambda v: f"{v+3-2}"), (lambda v: f"{v*2/2}", lambda v: f"{v*4/2}" if v != 0 else "1*4/2")]


class SqlInjectionScanRule:
    tech_required: Set[str] = set() # Generic SQLi rule is agnostic

    # Default max payloads for MEDIUM strength
    DEFAULT_MAX_PAYLOADS = {
        "error": 8, "boolean": 6, "expression": 2, "union": 5, "orderby": 2
    }
    ATTACK_STRENGTH_MULTIPLIERS = {
        "LOW": {"error": 3, "boolean": 2, "expression": 1, "union": 2, "orderby": 1},
        "MEDIUM": {"error": 8, "boolean": 6, "expression": 2, "union": 5, "orderby": 2},
        "HIGH": {"error": 15, "boolean": 10, "expression": 4, "union": 8, "orderby": 3},
        "INSANE": {"error": 30, "boolean": 20, "expression": 6, "union": 15, "orderby": 5} # Or len(all_payloads)
    }

    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 enable_error_based: bool = True,
                 enable_boolean_based: bool = True, enable_expression_based: bool = True,
                 enable_union_based: bool = True, enable_orderby_based: bool = True,
                 check_specific_rdbms_errors: bool = True,
                 check_generic_rdbms_errors: bool = True,
                 target_technologies: Optional[List[Tech]] = None,
                 http_timeout: float = 10.0,
                 active_scan_async_q: Optional[asyncio.Queue] = None,
                 **kwargs 
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.active_scan_async_q = active_scan_async_q
        self.http_timeout = http_timeout

        self.enable_error_based = enable_error_based; self.enable_boolean_based = enable_boolean_based
        self.enable_expression_based = enable_expression_based; self.enable_union_based = enable_union_based
        self.enable_orderby_based = enable_orderby_based
        self.check_specific_rdbms_errors = check_specific_rdbms_errors
        self.check_generic_rdbms_errors = check_generic_rdbms_errors
        self.target_technologies = target_technologies or []

        self._rdbms_map = {r.tech: r for r in RDBMS_DEFINITIONS if not r.is_generic()}
        self._generic_rdbms = next(r for r in RDBMS_DEFINITIONS if r.is_generic())
        
        self._sql_injection_found_for_current_param = False
        # Max payload counts will be set in scan() based on attack_strength
        self._max_payloads_config: Dict[str, int] = self.DEFAULT_MAX_PAYLOADS.copy()
        self.logger.debug(f"SqlInjectionScanRule (generic) initialized. Timeout: {self.http_timeout}s")

    async def _emit_alert(self, alert_obj: SQLiAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_obj.as_dict()})
                self.logger.info(f"SQLiScan: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"SQLiScan: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"SQLiScan: Async queue not available. Alert not emitted: {alert_obj.name}")

    async def _send_request_async(
        self, session: aiohttp.ClientSession, method: str, url: str,
        headers: Dict[str, str], cookies: Dict[str, str],
        data: Optional[Any] = None,
        param_name_attacked: Optional[str] = None, payload_used: Optional[str] = None
    ) -> Tuple[Optional[Any], Optional[str], float]:
        start_time = time.monotonic()
        response_text: Optional[str] = None
        aio_response_status: Optional[int] = None
        aio_response_headers: Optional[Dict[str,str]] = None
        
        current_headers = headers.copy()
        if "User-Agent" not in current_headers:
             current_headers["User-Agent"] = "SQLiScanner/1.0"

        log_payload_snippet = str(payload_used)[:50] + "..." if payload_used and len(payload_used) > 50 else payload_used
        self.logger.debug(f"SQLi Sending {method} to {url} (Param: {param_name_attacked}, Payload: {log_payload_snippet})")

        try:
            request_data_for_aiohttp = data
            if isinstance(data, dict) and method.upper() == "POST" and \
               (not current_headers.get("Content-Type") or "application/x-www-form-urlencoded" in current_headers.get("Content-Type","").lower()):
                form = aiohttp.FormData()
                for k, v_item in data.items():
                    form.add_field(k, str(v_item))
                request_data_for_aiohttp = form
            
            async with session.request(
                method.upper(), url, headers=current_headers, cookies=cookies, 
                data=request_data_for_aiohttp, timeout=aiohttp.ClientTimeout(total=self.http_timeout), 
                allow_redirects=False # Important for SQLi checks
            ) as resp:
                aio_response_status = resp.status
                aio_response_headers = dict(resp.headers)
                response_text = await resp.text(errors='replace')
            
            duration = time.monotonic() - start_time
            self.logger.debug(f"SQLi Response from {url}: Status {aio_response_status}, Duration: {duration:.2f}s")

            @dataclass
            class DetachedResponse: status: int; headers: Dict[str, str]; text_content: Optional[str]
            return DetachedResponse(status=aio_response_status, headers=aio_response_headers, text_content=response_text), response_text, duration

        except asyncio.TimeoutError:
            self.logger.warning(f"SQLi Timeout for {method} {url} (Payload: {log_payload_snippet})")
            return None, None, self.http_timeout
        except aiohttp.ClientError as e:
            self.logger.warning(f"SQLi AIOHTTP ClientError for {method} {url} (Payload: {log_payload_snippet}): {type(e).__name__} - {e}")
            return None, None, time.monotonic() - start_time
        except Exception as e:
            self.logger.error(f"SQLi Unexpected error for {method} {url} (Payload: {log_payload_snippet}): {e}", exc_info=True)
            return None, None, time.monotonic() - start_time

    def _strip_payload_from_response(self, body: Optional[str], payload: Optional[str], original_value: Optional[str] = None) -> str:
        if body is None: return ""
        result = body
        patterns_to_strip = []
        if payload:
            patterns_to_strip.extend([payload, urllib.parse.quote_plus(payload), html.escape(payload)])
        if original_value:
            patterns_to_strip.extend([original_value, urllib.parse.quote_plus(original_value), html.escape(original_value)])
        for p_strip in set(patterns_to_strip):
            if p_strip: result = result.replace(p_strip, "")
        return result

    def _compare_responses(
        self, base_resp_status: int, base_resp_text: Optional[str], base_resp_headers: Dict[str, str],
        attack_resp_status: int, attack_resp_text: Optional[str], attack_resp_headers: Dict[str, str],
        original_param_value: Optional[str], attack_payload: str
    ) -> bool:
        is_base_redirect = 300 <= base_resp_status < 400
        is_attack_redirect = 300 <= attack_resp_status < 400
        if is_base_redirect != is_attack_redirect: return False
        if is_base_redirect and base_resp_headers.get("Location", "").strip() != attack_resp_headers.get("Location", "").strip(): return False
        
        stripped_base_body = self._strip_payload_from_response(base_resp_text, original_param_value)
        stripped_attack_body = self._strip_payload_from_response(attack_resp_text, attack_payload, original_param_value)
        
        if abs(len(stripped_base_body) - len(stripped_attack_body)) > max(20, len(stripped_base_body) * 0.05):
            self.logger.debug(f"Responses differ: Stripped body lengths differ significantly ({len(stripped_base_body)} vs {len(stripped_attack_body)})")
            return False
        if stripped_base_body != stripped_attack_body:
             self.logger.debug(f"Responses differ: Stripped bodies mismatch (content different).")
             return False
        return True

    def _build_request_params(
        self, base_url: str, injection_location: str, param_name: str, payload: str,
        original_value: str, method: str, original_form_data: Optional[Dict[str, str]] = None
    ) -> Tuple[str, Optional[Dict[str, str]]]:
        target_url = base_url; request_data: Optional[Dict[str, str]] = None
        if injection_location == "url_params":
            parsed_url = urllib.parse.urlparse(base_url)
            query_params = urllib.parse.parse_qs(parsed_url.query, keep_blank_values=True)
            query_params[param_name] = [payload]
            target_url = parsed_url._replace(query=urllib.parse.urlencode(query_params, doseq=True)).geturl()
        elif injection_location in ["form_data_post", "form_data_get"] :
            request_data = (original_form_data or {}).copy()
            request_data[param_name] = payload
            target_url = base_url
            if injection_location == "form_data_get" and method.upper() == "GET":
                parsed_url = urllib.parse.urlparse(base_url)
                query_params = urllib.parse.parse_qs(parsed_url.query, keep_blank_values=True)
                for k, v_item in request_data.items(): query_params[k] = [str(v_item)]
                target_url = parsed_url._replace(query=urllib.parse.urlencode(query_params, doseq=True)).geturl()
                request_data = None
        return target_url, request_data

    async def _test_error_based(
        self, session: aiohttp.ClientSession, base_url: str,
        original_headers: Dict[str, str], original_cookies: Dict[str, str],
        injection_details: Dict[str, Any], base_response_text: Optional[str]
    ) -> bool:
        if not self.enable_error_based or self._error_requests_count >= self._max_payloads_config["error"]:
            return False
        param_name = injection_details["param_name"]; original_value = injection_details["original_value"]
        location = injection_details["location"]; method = injection_details.get("method", "GET")
        form_action_url = injection_details.get("action_url", base_url); all_form_fields = injection_details.get("all_form_fields")
        prefix = original_value if original_value else ""
        
        payloads_to_test = random.sample(SQL_CHECK_ERRORS, min(len(SQL_CHECK_ERRORS), self._max_payloads_config["error"] - self._error_requests_count))

        for sql_err_fragment in payloads_to_test:
            if self._sql_injection_found_for_current_param: break
            attack_payload = prefix + sql_err_fragment
            current_headers = original_headers.copy(); current_cookies = original_cookies.copy()
            if location == "header": current_headers[param_name] = attack_payload
            elif location == "cookie": current_cookies[param_name] = attack_payload
            target_url, request_data = self._build_request_params(form_action_url, location, param_name, attack_payload, original_value, method, all_form_fields)
            if location in ["header", "cookie"]: target_url, request_data = base_url, None # Use original_url for header/cookie tests
            
            self._error_requests_count += 1
            attack_resp_obj, attack_resp_text, _ = await self._send_request_async(session, method, target_url, current_headers, current_cookies, request_data, param_name, attack_payload)
            if not (attack_resp_obj and attack_resp_text): continue

            for rdbms_def in RDBMS_DEFINITIONS:
                if rdbms_def.is_generic() and not self.check_generic_rdbms_errors: continue
                if not rdbms_def.is_generic() and not self.check_specific_rdbms_errors: continue
                for pattern in rdbms_def.error_patterns:
                    match = pattern.search(attack_resp_text)
                    base_match = pattern.search(base_response_text) if base_response_text else None
                    if match and (not base_response_text or not base_match): # Ensure error wasn't in original page
                        self.logger.info(f"Error-based SQLi: RDBMS '{rdbms_def.name}' pattern matched for '{param_name}'")
                        self._sql_injection_found_for_current_param = True
                        alert = SQLiAlert(cwe_id=89, name=f"SQL Injection - Error Based ({rdbms_def.name})",
                                          description=f"A database error message specific to {rdbms_def.name} was observed when injecting SQL meta-characters.",
                                          uri=target_url, param=param_name,
                                          attack=attack_payload, evidence=match.group(0)[:200], rdbms=str(rdbms_def.tech),
                                          injection_type="Error-based", confidence=3)
                        alert.attack_details = {"location": location, "param": param_name, "method": method}
                        await self._emit_alert(alert)
                        return True
        return False

    async def _test_boolean_based(self, session: aiohttp.ClientSession, base_url: str, original_headers: Dict[str, str], original_cookies: Dict[str, str], injection_details: Dict[str, Any], baseline_resp_obj: Any, baseline_resp_text: Optional[str]) -> bool:
        if not self.enable_boolean_based or self._boolean_requests_count >= self._max_payloads_config["boolean"] or not baseline_resp_obj: return False
        param_name = injection_details["param_name"]; original_value = injection_details["original_value"]; location = injection_details["location"]; method = injection_details.get("method", "GET"); form_action_url = injection_details.get("action_url", base_url); all_form_fields = injection_details.get("all_form_fields")
        tests_to_run = BOOLEAN_TESTS + BOOLEAN_OR_TESTS
        payloads_to_test = random.sample(tests_to_run, min(len(tests_to_run), self._max_payloads_config["boolean"] - self._boolean_requests_count))

        for true_payload_tmpl, false_payload_tmpl, quote_char, needs_comment in payloads_to_test:
            if self._sql_injection_found_for_current_param: break
            comment_str = SQL_ONE_LINE_COMMENT if needs_comment else ""
            true_cond_str = f"{quote_char}1{quote_char}={quote_char}1{quote_char}" if quote_char else "1=1"
            payload_true_str = true_payload_tmpl.format(value=original_value, quote=quote_char, true_cond=true_cond_str, comment=comment_str)
            if "{value}" not in true_payload_tmpl: payload_true_str = original_value + payload_true_str
            false_cond_str = f"{quote_char}1{quote_char}={quote_char}2{quote_char}" if quote_char else "1=2"
            payload_false_str = false_payload_tmpl.format(value=original_value, quote=quote_char, false_cond=false_cond_str, comment=comment_str)
            if "{value}" not in false_payload_tmpl: payload_false_str = original_value + payload_false_str
            
            current_headers_true = original_headers.copy(); current_cookies_true = original_cookies.copy()
            if location == "header": current_headers_true[param_name] = payload_true_str
            elif location == "cookie": current_cookies_true[param_name] = payload_true_str
            target_url_true, request_data_true = self._build_request_params(form_action_url, location, param_name, payload_true_str, original_value, method, all_form_fields)
            if location in ["header", "cookie"]: target_url_true, request_data_true = base_url, None
            self._boolean_requests_count += 1
            resp_true_obj, resp_true_text, _ = await self._send_request_async(session, method, target_url_true, current_headers_true, current_cookies_true, request_data_true, param_name, payload_true_str)
            if not resp_true_obj: continue

            if self._compare_responses(baseline_resp_obj.status, baseline_resp_text, baseline_resp_obj.headers, resp_true_obj.status, resp_true_text, resp_true_obj.headers, original_value, payload_true_str):
                current_headers_false = original_headers.copy(); current_cookies_false = original_cookies.copy()
                if location == "header": current_headers_false[param_name] = payload_false_str
                elif location == "cookie": current_cookies_false[param_name] = payload_false_str
                target_url_false, request_data_false = self._build_request_params(form_action_url, location, param_name, payload_false_str, original_value, method, all_form_fields)
                if location in ["header", "cookie"]: target_url_false, request_data_false = base_url, None
                self._boolean_requests_count += 1
                resp_false_obj, resp_false_text, _ = await self._send_request_async(session, method, target_url_false, current_headers_false, current_cookies_false, request_data_false, param_name, payload_false_str)
                if not resp_false_obj: continue
                if not self._compare_responses(baseline_resp_obj.status, baseline_resp_text, baseline_resp_obj.headers, resp_false_obj.status, resp_false_text, resp_false_obj.headers, original_value, payload_false_str):
                    self.logger.info(f"Boolean-based SQLi: Param '{param_name}' vulnerable.")
                    self._sql_injection_found_for_current_param = True
                    alert = SQLiAlert(cwe_id=89, name="SQL Injection - Boolean Based", description="Boolean-based SQLi detected by observing different responses to true/false conditions.", uri=target_url_true, param=param_name, attack=f"T: {payload_true_str} F: {payload_false_str}", evidence="Response difference between true and false injected conditions.", injection_type="Boolean-based", confidence=3)
                    alert.attack_details = {"location": location, "param": param_name, "method": method}
                    await self._emit_alert(alert)
                    return True
        return False

    async def _test_union_based(self, session: aiohttp.ClientSession, base_url: str, original_headers: Dict[str, str], original_cookies: Dict[str, str], injection_details: Dict[str, Any], base_response_text: Optional[str]) -> bool:
        if not self.enable_union_based or self._union_requests_count >= self._max_payloads_config["union"]: return False
        param_name = injection_details["param_name"]; original_value = injection_details["original_value"]; location = injection_details["location"]; method = injection_details.get("method", "GET"); form_action_url = injection_details.get("action_url", base_url); all_form_fields = injection_details.get("all_form_fields")
        quote_chars_to_try = ["", SQL_SINGLE_QUOTE, "\""]
        payloads_to_test = random.sample(SQL_UNION_PAYLOAD_TEMPLATES, min(len(SQL_UNION_PAYLOAD_TEMPLATES), self._max_payloads_config["union"] - self._union_requests_count))

        for template in payloads_to_test:
            if self._sql_injection_found_for_current_param: break
            for quote_char_union in quote_chars_to_try:
                if self._sql_injection_found_for_current_param: break
                attack_payload = template.format(value=original_value, quote=quote_char_union, comment=SQL_ONE_LINE_COMMENT)
                current_headers = original_headers.copy(); current_cookies = original_cookies.copy()
                if location == "header": current_headers[param_name] = attack_payload
                elif location == "cookie": current_cookies[param_name] = attack_payload
                target_url, request_data = self._build_request_params(form_action_url, location, param_name, attack_payload, original_value, method, all_form_fields)
                if location in ["header", "cookie"]: target_url, request_data = base_url, None
                self._union_requests_count += 1
                attack_resp_obj, attack_resp_text, _ = await self._send_request_async(session, method, target_url, current_headers, current_cookies, request_data, param_name, attack_payload)
                if not (attack_resp_obj and attack_resp_text): continue
                for rdbms_def in RDBMS_DEFINITIONS:
                    if rdbms_def.is_generic(): continue
                    for pattern in rdbms_def.union_error_patterns:
                        match = pattern.search(attack_resp_text)
                        base_match = pattern.search(base_response_text) if base_response_text else None
                        if match and (not base_response_text or not base_match):
                            self.logger.info(f"UNION-based SQLi: RDBMS '{rdbms_def.name}' UNION error pattern matched for '{param_name}'")
                            self._sql_injection_found_for_current_param = True
                            alert = SQLiAlert(cwe_id=89, name=f"SQL Injection - UNION Based Error ({rdbms_def.name})", description=f"A UNION-specific database error from {rdbms_def.name} was observed, indicating a potential UNION-based SQLi.", uri=target_url, param=param_name, attack=attack_payload, evidence=match.group(0)[:200], rdbms=str(rdbms_def.tech), injection_type="UNION-based (Error)", confidence=3)
                            alert.attack_details = {"location": location, "param": param_name, "method": method}
                            await self._emit_alert(alert)
                            return True
        return False

    async def _test_expression_based(self, session: aiohttp.ClientSession, base_url: str, original_headers: Dict[str, str], original_cookies: Dict[str, str], injection_details: Dict[str, Any], baseline_resp_obj: Any, baseline_resp_text: Optional[str]) -> bool:
        if not self.enable_expression_based or self._expression_requests_count >= self._max_payloads_config["expression"] or not baseline_resp_obj: return False
        param_name = injection_details["param_name"]; original_value_str = injection_details["original_value"]; location = injection_details["location"]; method = injection_details.get("method", "GET"); form_action_url = injection_details.get("action_url", base_url); all_form_fields = injection_details.get("all_form_fields")
        try: original_numeric_value = int(original_value_str)
        except ValueError: return False
        
        payloads_to_test = random.sample(EXPRESSION_TESTS_NUMERIC, min(len(EXPRESSION_TESTS_NUMERIC), self._max_payloads_config["expression"] - self._expression_requests_count))

        for same_expr_func, diff_expr_func in payloads_to_test:
            if self._sql_injection_found_for_current_param: break
            try: payload_same = same_expr_func(original_numeric_value); payload_diff = diff_expr_func(original_numeric_value)
            except ArithmeticError: continue
            current_headers_same = original_headers.copy(); current_cookies_same = original_cookies.copy()
            if location == "header": current_headers_same[param_name] = payload_same
            elif location == "cookie": current_cookies_same[param_name] = payload_same
            target_url_same, request_data_same = self._build_request_params(form_action_url, location, param_name, payload_same, original_value_str, method, all_form_fields)
            if location in ["header", "cookie"]: target_url_same, request_data_same = base_url, None
            self._expression_requests_count += 1
            resp_same_obj, resp_same_text, _ = await self._send_request_async(session, method, target_url_same, current_headers_same, current_cookies_same, request_data_same, param_name, payload_same)
            if not resp_same_obj: continue
            if self._compare_responses(baseline_resp_obj.status, baseline_resp_text, baseline_resp_obj.headers, resp_same_obj.status, resp_same_text, resp_same_obj.headers, original_value_str, payload_same):
                current_headers_diff = original_headers.copy(); current_cookies_diff = original_cookies.copy()
                if location == "header": current_headers_diff[param_name] = payload_diff
                elif location == "cookie": current_cookies_diff[param_name] = payload_diff
                target_url_diff, request_data_diff = self._build_request_params(form_action_url, location, param_name, payload_diff, original_value_str, method, all_form_fields)
                if location in ["header", "cookie"]: target_url_diff, request_data_diff = base_url, None
                self._expression_requests_count += 1
                resp_diff_obj, resp_diff_text, _ = await self._send_request_async(session, method, target_url_diff, current_headers_diff, current_cookies_diff, request_data_diff, param_name, payload_diff)
                if not resp_diff_obj: continue
                if not self._compare_responses(baseline_resp_obj.status, baseline_resp_text, baseline_resp_obj.headers, resp_diff_obj.status, resp_diff_text, resp_diff_obj.headers, original_value_str, payload_diff):
                    self.logger.info(f"Expression-based SQLi: Param '{param_name}' vulnerable.")
                    self._sql_injection_found_for_current_param = True
                    alert = SQLiAlert(cwe_id=89, name="SQL Injection - Expression Based", description="Expression-based SQLi detected by observing different responses to equivalent/non-equivalent arithmetic expressions.", uri=target_url_same, param=param_name, attack=f"S: {payload_same} D: {payload_diff}", evidence="Response difference between injected arithmetic expressions.", injection_type="Expression-based", confidence=3)
                    alert.attack_details = {"location": location, "param": param_name, "method": method}
                    await self._emit_alert(alert)
                    return True
        return False

    async def _test_orderby_based(self, session: aiohttp.ClientSession, base_url: str, original_headers: Dict[str, str], original_cookies: Dict[str, str], injection_details: Dict[str, Any], baseline_resp_obj: Any, baseline_resp_text: Optional[str]) -> bool:
        if not self.enable_orderby_based or self._orderby_requests_count >= self._max_payloads_config["orderby"] or not baseline_resp_obj: return False
        param_name = injection_details["param_name"]; original_value = injection_details["original_value"]; location = injection_details["location"]; method = injection_details.get("method", "GET"); form_action_url = injection_details.get("action_url", base_url); all_form_fields = injection_details.get("all_form_fields")
        
        payloads_to_test = random.sample(ORDER_BY_TESTS, min(len(ORDER_BY_TESTS), self._max_payloads_config["orderby"] - self._orderby_requests_count))

        for asc_suffix, desc_suffix in payloads_to_test:
            if self._sql_injection_found_for_current_param: break
            payload_asc = original_value + asc_suffix; payload_desc = original_value + desc_suffix
            current_headers_asc = original_headers.copy(); current_cookies_asc = original_cookies.copy()
            if location == "header": current_headers_asc[param_name] = payload_asc
            elif location == "cookie": current_cookies_asc[param_name] = payload_asc
            target_url_asc, request_data_asc = self._build_request_params(form_action_url, location, param_name, payload_asc, original_value, method, all_form_fields)
            if location in ["header", "cookie"]: target_url_asc, request_data_asc = base_url, None
            self._orderby_requests_count += 1
            resp_asc_obj, resp_asc_text, _ = await self._send_request_async(session, method, target_url_asc, current_headers_asc, current_cookies_asc, request_data_asc, param_name, payload_asc)
            if not resp_asc_obj: continue
            if self._compare_responses(baseline_resp_obj.status, baseline_resp_text, baseline_resp_obj.headers, resp_asc_obj.status, resp_asc_text, resp_asc_obj.headers, original_value, payload_asc):
                current_headers_desc = original_headers.copy(); current_cookies_desc = original_cookies.copy()
                if location == "header": current_headers_desc[param_name] = payload_desc
                elif location == "cookie": current_cookies_desc[param_name] = payload_desc
                target_url_desc, request_data_desc = self._build_request_params(form_action_url, location, param_name, payload_desc, original_value, method, all_form_fields)
                if location in ["header", "cookie"]: target_url_desc, request_data_desc = base_url, None
                self._orderby_requests_count += 1
                resp_desc_obj, resp_desc_text, _ = await self._send_request_async(session, method, target_url_desc, current_headers_desc, current_cookies_desc, request_data_desc, param_name, payload_desc)
                if not resp_desc_obj: continue
                if not self._compare_responses(baseline_resp_obj.status, baseline_resp_text, baseline_resp_obj.headers, resp_desc_obj.status, resp_desc_text, resp_desc_obj.headers, original_value, payload_desc) and \
                   not self._compare_responses(resp_asc_obj.status, resp_asc_text, resp_asc_obj.headers, resp_desc_obj.status, resp_desc_text, resp_desc_obj.headers, payload_asc, payload_desc):
                    self.logger.info(f"Orderby-based SQLi: Param '{param_name}' vulnerable.")
                    self._sql_injection_found_for_current_param = True
                    alert = SQLiAlert(cwe_id=89, name="SQL Injection - ORDER BY Based", description="ORDER BY clause injection detected by observing different responses to ASC/DESC modifiers.", uri=target_url_asc, param=param_name, attack=f"A: {payload_asc} D: {payload_desc}", evidence="Response difference between injected ASC and DESC sorting.", injection_type="ORDER BY-based", confidence=2)
                    alert.attack_details = {"location": location, "param": param_name, "method": method}
                    await self._emit_alert(alert)
                    return True
        return False


    async def scan(
        self,
        original_url: str,
        aiohttp_session: aiohttp.ClientSession,
        injection_details: Dict[str, Any],
        original_headers: Dict[str, str],
        original_cookies: Dict[str, str],
        attack_strength: str = "MEDIUM", # NEW PARAMETER
        original_page_content_for_baseline_errors: Optional[str] = None,
        base_app_url: Optional[str] = None,
        html_content: Optional[str] = None,
        worker_ident: Optional[str] = "SQLiScan",
        page_specific_technologies: Optional[List[str]] = None,
        service_type_hint: Optional[str] = None
    ) -> None:
        
        self._sql_injection_found_for_current_param = False
        self._error_requests_count = 0; self._boolean_requests_count = 0
        self._expression_requests_count = 0; self._union_requests_count = 0
        self._orderby_requests_count = 0

        # Set max payload counts based on attack_strength
        self._max_payloads_config = self.ATTACK_STRENGTH_MULTIPLIERS.get(
            attack_strength.upper(), self.DEFAULT_MAX_PAYLOADS
        )
        self.logger.info(f"[{worker_ident}] SQLi Attack Strength: {attack_strength.upper()}. Max Payloads: Error={self._max_payloads_config['error']}, Boolean={self._max_payloads_config['boolean']}, etc.")


        param_name = injection_details["param_name"]
        location = injection_details["location"]
        method = injection_details.get("method", "GET")
        base_url_for_tests = injection_details.get("action_url", original_url)

        self.logger.info(f"[{worker_ident}] Starting SQLi scan for param: '{param_name}' at location '{location}' on URL: {base_url_for_tests}")

        baseline_text_for_error_diff = html_content if html_content is not None else original_page_content_for_baseline_errors

        if self.enable_error_based and not self._sql_injection_found_for_current_param:
            await self._test_error_based(
                aiohttp_session, base_url_for_tests, original_headers, original_cookies,
                injection_details, baseline_text_for_error_diff
            )
        if self._sql_injection_found_for_current_param: return # Stop if found

        original_target_url_for_baseline, original_request_data_for_baseline = self._build_request_params(
            base_url_for_tests, location, param_name, 
            injection_details["original_value"],
            injection_details["original_value"], method, 
            injection_details.get("all_form_fields")
        )
        baseline_headers_for_req = original_headers.copy()
        baseline_cookies_for_req = original_cookies.copy()
        if location == "header":
            baseline_headers_for_req[param_name] = injection_details["original_value"]
            original_target_url_for_baseline, original_request_data_for_baseline = base_url_for_tests, None
        elif location == "cookie":
            baseline_cookies_for_req[param_name] = injection_details["original_value"]
            original_target_url_for_baseline, original_request_data_for_baseline = base_url_for_tests, None

        self.logger.debug(f"[{worker_ident}] Fetching baseline response for SQLi (param '{param_name}')")
        baseline_resp_obj, baseline_resp_text, _ = await self._send_request_async(
            aiohttp_session, method, original_target_url_for_baseline,
            baseline_headers_for_req, baseline_cookies_for_req, original_request_data_for_baseline,
            param_name, injection_details["original_value"]
        )

        if baseline_resp_obj is None:
            self.logger.warning(f"[{worker_ident}] Could not fetch baseline for param '{param_name}'. Comparison-based SQLi checks will be skipped or unreliable.")
        
        if self.enable_expression_based and not self._sql_injection_found_for_current_param:
            await self._test_expression_based(aiohttp_session, base_url_for_tests, original_headers, original_cookies, injection_details, baseline_resp_obj, baseline_resp_text)
        if self._sql_injection_found_for_current_param: return

        if self.enable_boolean_based and not self._sql_injection_found_for_current_param:
            await self._test_boolean_based(aiohttp_session, base_url_for_tests, original_headers, original_cookies, injection_details, baseline_resp_obj, baseline_resp_text)
        if self._sql_injection_found_for_current_param: return
        
        if self.enable_union_based and not self._sql_injection_found_for_current_param:
            await self._test_union_based(aiohttp_session, base_url_for_tests, original_headers, original_cookies, injection_details, baseline_resp_text)
        if self._sql_injection_found_for_current_param: return
        
        if self.enable_orderby_based and not self._sql_injection_found_for_current_param:
            await self._test_orderby_based(aiohttp_session, base_url_for_tests, original_headers, original_cookies, injection_details, baseline_resp_obj, baseline_resp_text)
            
        self.logger.info(f"[{worker_ident}] SQLi scan for param: '{param_name}' completed.")