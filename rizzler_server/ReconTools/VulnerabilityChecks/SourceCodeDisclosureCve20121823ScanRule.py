# Filename: VulnerabilityChecks/SourceCodeDisclosureCve20121823ScanRule.py

import asyncio
import logging
import random
import re
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Set, TYPE_CHECKING

import aiohttp
from bs4 import BeautifulSoup # For HTML decoding, similar to Jericho Source's getRenderer

if TYPE_CHECKING:
    from asyncio import Queue # For type hinting

@dataclass
class SourceCodeDisclosureCVE20121823Alert:
    cwe_id: int = 200
    wasc_id: int = 13
    name: str = "PHP Source Code Disclosure (CVE-2012-1823)"
    description: str = (
        "The PHP-CGI component is vulnerable to an argument injection vulnerability (CVE-2012-1823). "
        "When certain query parameters are used (like ?-s), the server may disclose the source code "
        "of the requested PHP script instead of executing it."
    )
    uri: str = ""
    attack_payload_url: str = ""
    evidence: str = ""
    other_info: str = ""
    solution: str = (
        "Upgrade to a patched version of PHP. Ensure PHP-CGI is configured securely. "
        "Consider using a web server module like mod_php (Apache) or PHP-FPM instead of CGI mode if possible. "
        "Apply appropriate web application firewall rules to block the malicious query parameters."
    )
    reference: str = (
        "CVE-2012-1823\n"
        "https://httpd.apache.org/security/CVE-2012-1823.txt\n"
        "https://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/"
    )
    risk: int = 3  # Medium to High. Source disclosure is generally High.
    confidence: int = 3 # High if PHP tags are found in highlighted source
    # Class level constants for risk and confidence for easier reference
    RISK_HIGH: int = 3 
    CONFIDENCE_HIGH: int = 3

    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "CVE": "CVE-2012-1823",
        "OWASP_2021_A06": "Vulnerable and Outdated Components",
        "OWASP_2021_A05": "Security Misconfiguration",
        "WSTG_V42_CONF_05": "Enumerate Infrastructure and Application Admin Interfaces",
    })

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": "SourceCodeDisclosure_CVE-2012-1823",
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack_payload_url,
            "injection_point_info": "URL Query Parameter (?-s)",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id,
            "alert_tags": self.alert_tags,
            "other_info": self.other_info
        }

# --- Constants for the rule ---
PHP_PATTERN_TAG_OPEN = re.compile(rb"<(\?php|\?=|\?)(?!xml)", re.IGNORECASE)
PHP_PATTERN_TAG_CLOSE = re.compile(rb"\?>")
PHP_KEYWORDS_IN_HIGHLIGHTED_SOURCE = re.compile(
    rb"(?:echo|print|array|function|class|if|else|while|for|foreach|include|require|define|global|\$\w+)",
    re.IGNORECASE
)
ATTACK_PARAM = "?-s"

class SourceCodeDisclosureCve20121823ScanRule:
    tech_required: Set[str] = {
        "PHP", "PHP-Nuke", "PHPDebugBar", "PHPFusion",
        "Pantheon", "Paymenter", "Phabricator", "PhotoShelter",
        "Pimcore", "Pingoteam", "PrestaShop", "ProcessWire",
        "Proximis Unified Commerce", "Pterodactyl Panel", "papaya CMS",
        "phpAlbum", "phpBB", "phpCMS", "phpDocumentor", "phpMyAdmin",
        "phpPgAdmin", "phpRS", "phpSQLiteCMS", "phpwind", "pinoox",
        "punBB"
    }
    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 http_timeout: float = 10.0,
                 active_scan_async_q: Optional['Queue'] = None # Added parameter
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q # Store the queue

    def _is_likely_php_response(self, headers: Optional[Dict[str, str]], url_path: str) -> bool:
        if url_path.lower().endswith(".php"):
            return True
        if headers:
            content_type = headers.get("Content-Type", "").lower()
            if "php" in content_type:
                return True
            x_powered_by = headers.get("X-Powered-By", "").lower()
            if "php" in x_powered_by:
                return True
        return False

    def _decode_html_entities_in_source(self, html_source: str) -> str:
        soup = BeautifulSoup(html_source, "html.parser")
        return soup.get_text()

    async def _fetch_url_content_check_php(
        self,
        session: aiohttp.ClientSession,
        url: str,
        original_headers_for_consistency: Optional[Dict[str, str]] = None
    ) -> Tuple[Optional[str], Optional[int], bool]:
        
        headers_to_send = (original_headers_for_consistency or {}).copy()
        if "User-Agent" not in headers_to_send:
             headers_to_send["User-Agent"] = random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36"
            ])
        
        self.logger.debug(f"PHP Source Disclosure (CVE-2012-1823) Scan: Fetching {url}")
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.get(url, headers=headers_to_send, timeout=timeout, allow_redirects=False) as resp:
                if resp.status != 200:
                    self.logger.debug(f"PHP Source Disclosure: Target {url} returned status {resp.status}")
                    return None, resp.status, False

                content_type = resp.headers.get("Content-Type", "").lower()
                if not ("text/" in content_type or "html" in content_type or "xml" in content_type or "json" in content_type or not content_type):
                    self.logger.debug(f"PHP Source Disclosure: Target {url} has non-text Content-Type: {content_type}")
                    return None, resp.status, False

                response_bytes = await resp.read()
                
                try:
                    response_text_raw = response_bytes.decode('utf-8')
                except UnicodeDecodeError:
                    response_text_raw = response_bytes.decode('latin-1', errors='replace')

                decoded_text_for_php_check = self._decode_html_entities_in_source(response_text_raw)
                
                found_php_tags = PHP_PATTERN_TAG_OPEN.search(response_bytes) and PHP_PATTERN_TAG_CLOSE.search(response_bytes)
                found_php_keywords = False
                if not found_php_tags:
                    found_php_keywords = PHP_KEYWORDS_IN_HIGHLIGHTED_SOURCE.search(decoded_text_for_php_check.encode('utf-8', errors='ignore'))

                if found_php_tags or found_php_keywords:
                    self.logger.info(f"PHP Source Disclosure: Found PHP code/keywords in response from {url}")
                    return response_text_raw, resp.status, True
                else:
                    self.logger.debug(f"PHP Source Disclosure: No clear PHP tags/keywords found in response from {url}")
                    return response_text_raw, resp.status, False

        except Exception as e:
            self.logger.warning(f"PHP Source Disclosure: Request to {url} failed: {type(e).__name__} - {e}")
            return None, None, False

    async def scan(
        self,
        php_script_url: str, # Renamed from base_app_url for clarity
        original_headers: Dict[str, str],
        aiohttp_session: aiohttp.ClientSession,
        # The following are part of a more generic signature but less used by this specific rule
        original_cookies: Optional[Dict[str, str]] = None, 
        page_specific_technologies: Optional[List[str]] = None,
        injection_details: Optional[Dict[str, Any]] = None, 
        original_page_content_for_baseline_errors: Optional[str] = None 
    ) -> None: # Changed return type to None

        if not self.active_scan_async_q:
            self.logger.warning("PHP Source Disclosure (CVE-2012-1823) scan skipped: active_scan_async_q not configured.")
            return

        parsed_url = urllib.parse.urlparse(php_script_url)
        if not self._is_likely_php_response(original_headers, parsed_url.path):
            if not (page_specific_technologies and any("php" in tech.lower() for tech in page_specific_technologies)):
                self.logger.debug(f"PHP Source Disclosure (CVE-2012-1823): Skipping {php_script_url} as it does not appear to be PHP.")
                return
        
        self.logger.info(f"Starting PHP Source Disclosure (CVE-2012-1823) scan for: {php_script_url}")

        scheme = parsed_url.scheme
        netloc = parsed_url.netloc
        path = parsed_url.path
        if not path: path = '/'
        
        attack_uri_str = f"{scheme}://{netloc}{path}{ATTACK_PARAM}"
        self.logger.debug(f"PHP Source Disclosure: Attack URL: {attack_uri_str}")

        disclosed_source_html, status, found_php_evidence = await self._fetch_url_content_check_php(
            aiohttp_session, attack_uri_str, original_headers
        )

        alerts_generated_count = 0
        if status == 200 and disclosed_source_html and found_php_evidence:
            evidence_snippet = disclosed_source_html[:500]
            decoded_text_for_final_evidence = self._decode_html_entities_in_source(disclosed_source_html)

            match_open = PHP_PATTERN_TAG_OPEN.search(decoded_text_for_final_evidence.encode('utf-8', errors='ignore'))
            if match_open:
                start_offset = match_open.start()
                temp_buffer = decoded_text_for_final_evidence[start_offset:]
                match_close = PHP_PATTERN_TAG_CLOSE.search(temp_buffer.encode('utf-8', errors='ignore'))
                if match_close:
                    end_offset_relative = match_close.end()
                    evidence_snippet = temp_buffer[:end_offset_relative][:500]
                else:
                    evidence_snippet = temp_buffer[:500]
            elif PHP_KEYWORDS_IN_HIGHLIGHTED_SOURCE.search(decoded_text_for_final_evidence.encode('utf-8', errors='ignore')):
                 evidence_snippet = decoded_text_for_final_evidence[:500]

            alert_instance = SourceCodeDisclosureCVE20121823Alert(
                uri=php_script_url,
                attack_payload_url=attack_uri_str,
                evidence=evidence_snippet.strip() + "...",
                other_info=f"Successfully fetched and found PHP syntax in response from {attack_uri_str}.",
                risk=SourceCodeDisclosureCVE20121823Alert.RISK_HIGH,
                confidence=SourceCodeDisclosureCVE20121823Alert.CONFIDENCE_HIGH
            )
            
            if self.active_scan_async_q:
                try:
                    await self.active_scan_async_q.put({"type": "active_scan_alert", "alert": alert_instance.as_dict()})
                    alerts_generated_count += 1
                    self.logger.info(f"PHP Source Disclosure (CVE-2012-1823) confirmed for {php_script_url} via {attack_uri_str}")
                except Exception as e_queue:
                    self.logger.error(f"Failed to put PHP Source Disclosure alert onto async queue: {e_queue}")
            else:
                # This case should ideally not be hit if the initial check passes
                self.logger.warning("active_scan_async_q not available when trying to queue PHP Source Disclosure alert.")


        if alerts_generated_count > 0:
            self.logger.info(f"PHP Source Disclosure (CVE-2012-1823) scan for {php_script_url} completed. Found {alerts_generated_count} alerts.")
        else:
            self.logger.info(f"PHP Source Disclosure (CVE-2012-1823) scan for {php_script_url} completed. No alerts generated.")
        return # No longer returns a list