# Filename: VulnerabilityChecks/WAFFuzzScanRule.py

import asyncio
import logging
import random
import re
import urllib.parse
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Set

import aiohttp

# --- Alert Definition ---
@dataclass
class WAFDetectionAlert:
    cwe_id: int
    name: str # e.g., "Cloudflare WAF Detected"
    description: str
    uri: str         # The URL of the application endpoint tested
    param: Optional[str] # Parameter used for fuzzing, if applicable
    attack: str      # The payload sent (or a representation of the raw request)
    evidence: str    # WAF signature matched

    wasc_id: Optional[int] = None # WAFs are not directly a WASC category, but CWE-200 is info exposure
    other_info: str = ""
    solution: str = (
        "A Web Application Firewall (WAF) has been detected. This is generally a positive security measure. "
        "For penetration testing, be aware that the WAF may block or alter malicious payloads. "
        "Understanding the specific WAF can help in crafting bypass techniques if necessary for thorough testing."
    )
    reference: str = "https://owasp.org/www-community/Web_Application_Firewall"
    risk: int = 1  # Info
    confidence: int = 3 # High if a specific signature matches
    alert_tags: Dict[str, str] = field(default_factory=lambda: {
        "Detection": "WAF_Fingerprint",
        "Appliance": "GenericWAF" # This will be updated with the specific WAF name
    })
    attack_details: Dict[str, Any] = field(default_factory=dict)

    def as_dict(self) -> Dict[str, Any]:
        tags = self.alert_tags.copy()
        return {
            "vulnerability_type": "WAF Detection", # More of an informational finding
            "type": self.name,
            "detail": self.description,
            "payload_used": self.attack[:200] + "..." if len(self.attack) > 200 else self.attack,
            "injection_point_info": f"Fuzzing payload sent to: {self.attack_details.get('target_path', self.uri)} (Param: {self.param or 'N/A'})",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id if self.wasc_id else 0,
            "alert_tags": tags,
            "other_info": self.other_info
        }

class WAFFuzzScanRule:
    tech_required: Set[str] = set() # WAF detection is generally applicable

    # Payloads from the Nuclei template
    WHATWAF_PAYLOADS = [
        "484029\") AS xDKy WHERE 5427=5427 UNION ALL SELECT NULL,NULL",
        "' AND 1=1 '",
        "'))) AND '1'='1' ((('",
        "AND 1=1",
        "' AND 1=1 ' OR 10=11,<script>alert('');</script>",
        "\"\"' AND 1=1 \" OR 1=10 '\"\"\"",
        "' AND 1=1 OR 2=2",
        "' AND 1=1 OR 2=2 '",
        "' )) AND 1=1 ' OR '2'='3 --'",
        "' AND 1=1 OR 24=25 '",
        "' AND 1=1 OR 9=10 ORDERBY(1,2,3,4,5)",
        "' AND 1=1 ORDERBY(1,2,3,4,5) '; asdf",
        "AND 1=1,<script>alert(\"1,2,3,4,5);</script>",
        "AND 1=1,<script>alert(\"test\\\");</script>", # Escaped quote
        "' AND 1=1;SELECT * FROM information_schema.tables '",
        "AS start WHERE 1601=1601 UNION ALL SELECT NULL,NULL",
        "/bin/cat /etc/passwd",
        "<img src=x onerror=\"input\\\">", # Escaped quote
        "r\"\"\"&lt' AND 1=1 ',<script>alert(\"test\\\");</script>\"\"\"", # Escaped quote
        "<script>alert('1');</script>",
        "<script>alert(1);</script>",
        "<script>alert(\"\");</script>",
        "<script>alert(\"test\");</script>",
        "<script>alert('test');</script>",
        "'/>\"<script>alert('whatwaf');</script>", # Corrected from Nuclei template for valid HTML/JS
        "<script>alert(\"XSS\\\");</script>", # Escaped quote
        "SELECT * FROM information_schema.tables",
        "SELECT user FROM information_schema.tables AND user = 'test user';",
        "UNION SELECT * FROM users WHERE user = 'admin';"
    ]

    # Matchers from the Nuclei template (simplified for Python regex)
    # Each key is the WAF name, value is a list of regex patterns
    # 'part' indicates where to look: 'header' or 'body' or 'response' (both)
    WAF_SIGNATURES = {
        "Instart Logic": {"part": "body", "regexes": [re.compile(r'instartrequestid', re.I)]},
        "PerimeterX": {"part": "response", "regexes": [
            re.compile(r'access.to.this.page.has.been.denied.because.we.believe.you.are.using.automation.tool', re.I),
            re.compile(r'http(s)?://(www.)?perimeterx.\w+.whywasiblocked', re.I),
            re.compile(r'perimeterx', re.I), # Generic, might be too broad if not careful
            re.compile(r'(..)?client.perimeterx.*/[a-zA-Z]{8,15}/*.*.js', re.I)
        ]},
        "WebKnight": {"part": "response", "regexes": [re.compile(r'\bwebknight\b', re.I)]}, # Added word boundary
        "Zscaler": {"part": "response", "regexes": [re.compile(r'zscaler', re.I)]},
        "FortiWeb/FortiGate": {"part": "response", "regexes": [
            re.compile(r'.>powered.by.fortinet<.', re.I), re.compile(r'.>fortigate.ips.sensor<.', re.I),
            re.compile(r'fortigate', re.I), re.compile(r'.fgd_icon', re.I),
            re.compile(r'\AFORTIWAFSID=', re.I), # Header (cookie)
            re.compile(r'application.blocked.', re.I), re.compile(r'.fortiGate.application.control', re.I),
            re.compile(r'(http(s)?)?://\w+.fortinet(.\w+:)?', re.I), re.compile(r'fortigate.hostname', re.I),
            re.compile(r'the.page.cannot.be.displayed..please.contact.[^@]+@[^@]+\.[^@]+.for.additional.information', re.I)
        ]},
        "Teros": {"part": "response", "regexes": [re.compile(r'st8(id|.wa|.wf)?.?(\d+|\w+)?', re.I)]}, # Header (cookie) or body
        "StrictHTTP (Unknown WAF)": {"part": "response", "regexes": [
            re.compile(r'the.request.was.rejected.because.the.url.contained.a.potentially.malicious.string', re.I),
            re.compile(r'rejected.by.url.scan', re.I)
        ]},
        "Shadow Daemon": {"part": "response", "condition": "and", "regexes": [ # Note: AND condition
            re.compile(r'<h\d>\d{3}.forbidden<.h\d>', re.I),
            re.compile(r'request.forbidden.by.administrative.rules.', re.I)
        ]},
        "F5 BIG-IP (ASM)": {"part": "response", "regexes": [
            re.compile(r'\ATS\w{4,}=', re.I), # Header (cookie)
            re.compile(r'bigipserver(.i)?|bigipserverinternal', re.I), # Header or body
            re.compile(r'^TS[a-zA-Z0-9]{3,8}=', re.I), # Header (cookie)
            re.compile(r'BigIP|BIG-IP|BIGIP', re.I), # Header or body
        ]},
        "EdgeCast (Verizon)": {"part": "response", "regexes": [re.compile(r'\Aecdf', re.I)]}, # Header
        "Radware": {"part": "response", "regexes": [
            re.compile(r'.\bcloudwebsec.radware.com\b.', re.I),
            re.compile(r'.>unauthorized.activity.has.been.detected<.', re.I),
            re.compile(r'with.the.following.case.number.in.its.subject:.\d+.', re.I)
        ]},
        "Varnish (with CacheWall)": {"part": "response", "regexes": [
            re.compile(r'varnish', re.I), # Server header or body
            re.compile(r'.>.?security.by.cachewall.?<.', re.I),
            re.compile(r'cachewall', re.I),
            re.compile(r'.>access.is.blocked.according.to.our.site.security.policy.<+', re.I)
        ]},
        "InfoSafe": {"part": "response", "regexes": [
            re.compile(r'infosafe', re.I), re.compile(r'by.(http(s)?(.//)?)?7i24.(com|net)', re.I),
            re.compile(r'infosafe.\d.\d', re.I), re.compile(r'var.infosafekey=', re.I)
        ]},
        "AliyunDun": {"part": "response", "regexes": [
            re.compile(r'error(s)?.aliyun(dun)?.(com|net)', re.I),
            re.compile(r'http(s)?://(www.)?aliyun.(com|net)', re.I) # Generic, might be too broad
        ]},
        "Apache Traffic Server (ATS)": {"part": "response", "regexes": [
            re.compile(r'(\()?apachetrafficserver((\/)?\d+(.\d+(.\d+)?)?)', re.I), # Server header or body
            re.compile(r'ats((\/)?(\d+(.\d+(.\d+)?)?))?', re.I) # Server header or body
        ]},
        "MalCare": {"part": "response", "regexes": [
            re.compile(r'malcare', re.I),
            re.compile(r'.>login.protection<.+.><.+>powered.by<.+.>(<.+.>)?(.?malcare.-.pro|blogvault)?', re.I),
            re.compile(r'.>firewall<.+.><.+>powered.by<.+.>(<.+.>)?(.?malcare.-.pro|blogvault)?', re.I)
        ]},
        "WTS-WAF": {"part": "response", "regexes": [re.compile(r'(<title>)?wts.wa(f)?(\w+(\w+(\w+)?)?)?', re.I)]},
        "DW (Unknown WAF)": {"part": "response", "regexes": [re.compile(r'dw.inj.check', re.I)]},
        "DenyAll WAF": {"part": "response", "regexes": [
            re.compile(r'\Acondition.intercepted', re.I), # Header
            re.compile(r'\Asessioncookie=', re.I) # Header (cookie)
        ]},
        "Yunsuo": {"part": "response", "regexes": [
            re.compile(r'<img.class=.yunsuologo.', re.I),
            re.compile(r'yunsuo.session', re.I) # Header (cookie)
        ]},
        "LiteSpeed Web Server": {"part": "response", "regexes": [re.compile(r'litespeed.web.server', re.I)]}, # Server header
        "CloudFront (AWS)": {"part": "response", "regexes": [
            re.compile(r'[a-zA-Z0-9]{,60}.cloudfront.net', re.I), # Header or body
            re.compile(r'cloudfront', re.I), # Server header or body
            re.compile(r'x.amz.cf.id|nguardx', re.I) # Header
        ]},
        "Anyu WAF": {"part": "response", "regexes": [
            re.compile(r'sorry.{1,2}your.access.has.been.intercept(ed)?.by.anyu', re.I),
            re.compile(r'anyu', re.I),
            re.compile(r'anyu-?.the.green.channel', re.I)
        ]},
        "Google Cloud Load Balancer/WAF": {"part": "response", "regexes": [
            re.compile(r'your.client.has.issued.a.malformed.or.illegal.request', re.I),
            re.compile(r'our.systems.have.detected.unusual.traffic', re.I),
            re.compile(r'block(ed)?.by.g.cloud.security.policy.+', re.I)
        ]},
        "DiDiYun WAF": {"part": "response", "regexes": [
            re.compile(r'(http(s)?://)(sec-waf.|www.)?didi(static|yun)?.com(/static/cloudwafstatic)?', re.I),
            re.compile(r'didiyun', re.I)
        ]},
        "BlockDoS": {"part": "response", "regexes": [re.compile(r'blockdos\.net', re.I)]},
        "CodeIgniter (Built-in Filter)": {"part": "response", "regexes": [re.compile(r'the.uri.you.submitted.has.disallowed.characters', re.I)]},
        "Stingray Application Firewall": {"part": "response", "regexes": [re.compile(r'\AX-Mapping-', re.I)]}, # Header
        "West263 CDN": {"part": "response", "regexes": [re.compile(r'wt\d*cdn', re.I)]},
        "AWS WAF": {"part": "response", "regexes": [ # Some overlap with CloudFront, but more specific AWS errors
            re.compile(r'<RequestId>[0-9a-zA-Z]{16,25}<.RequestId>', re.I),
            re.compile(r'<Error><Code>AccessDenied<.Code>', re.I),
            re.compile(r'x.amz.id.\d+', re.I), # Header
            re.compile(r'x.amz.request.id', re.I) # Header
        ]},
        "Yundun WAF": {"part": "response", "regexes": [
            re.compile(r'YUNDUN', re.I), # Server header or body
            re.compile(r'^yd.cookie=', re.I), # Header (cookie)
            re.compile(r'http(s)?.//(www\.)?(\w+.)?yundun(.com)?', re.I),
            re.compile(r'<title>.403.forbidden:.access.is.denied.{0,2}<.{0,2}title>', re.I)
        ]},
        "Barracuda WAF": {"part": "response", "regexes": [
            re.compile(r'\Abarra.counter.session=?', re.I), # Header (cookie)
            re.compile(r'(\A|\b)?barracuda.', re.I), # Server header or body
            re.compile(r'barracuda.networks.{1,2}inc', re.I)
        ]},
        "DoD Enterprise Protection": {"part": "response", "regexes": [re.compile(r'dod.enterprise.level.protection.system', re.I)]},
        "SecuPress (WordPress)": {"part": "response", "regexes": [
            re.compile(r'<h\d*>secupress<.', re.I),
            re.compile(r'block.id.{1,2}bad.url.contents.<.', re.I)
        ]},
        "aeSecure WAF": {"part": "response", "regexes": [re.compile(r'aesecure.denied.png', re.I)]},
        "Incapsula (Imperva)": {"part": "response", "regexes": [
            re.compile(r'incap_ses|visid_incap', re.I), # Header (cookie)
            re.compile(r'incapsula', re.I), # Server header or body
            re.compile(r'incapsula.incident.id', re.I)
        ]},
        "NexusGuard WAF": {"part": "response", "regexes": [
            re.compile(r'nexus.?guard', re.I),
            re.compile(r'((http(s)?://)?speresources.)?nexusguard.com.wafpage', re.I)
        ]},
        "Cloudflare": {"part": "response", "regexes": [
            re.compile(r'cloudflare.ray.id.|var.cloudflare.', re.I),
            re.compile(r'cloudflare.nginx', re.I), # Server header
            re.compile(r'..cfduid=([a-z0-9]{43})?', re.I), # Header (cookie)
            re.compile(r'cf[-|_]ray(..)?([0-9a-f]{16})?[-|_]?(dfw|iad)?', re.I), # Header
            re.compile(r'.>attention.required!.\|.cloudflare<.+', re.I),
            re.compile(r'http(s)?.//report.(uri.)?cloudflare.com(/cdn.cgi(.beacon/expect.ct)?)?', re.I),
            re.compile(r'ray.id', re.I), # Header or body
            re.compile(r'__cfduid', re.I) # Header (cookie)
        ]},
        "Akamai (Kona Site Defender)": {"part": "response", "regexes": [
            re.compile(r'.>access.denied<.', re.I),
            re.compile(r'akamaighost', re.I), # Server header
            re.compile(r'ak.bmsc.', re.I) # Header (cookie)
        ]},
        "IBM WebSEAL": {"part": "response", "regexes": [
            re.compile(r'webseal.error.message.template', re.I),
            re.compile(r'webseal.server.received.an.invalid.http.request', re.I)
        ]},
        "DotDefender (Applicure)": {"part": "response", "regexes": [re.compile(r'dotdefender.blocked.your.request', re.I)]},
        "pkSecurityModule": {"part": "response", "regexes": [
            re.compile(r'.>pkSecurityModule\W..\WSecurity.Alert<.', re.I),
            re.compile(r'.http(s)?.//([w]{3})?.kitnetwork.\w', re.I),
            re.compile(r'.>A.safety.critical.request.was.discovered.and.blocked.<.', re.I)
        ]},
        "ExpressionEngine (Built-in Filter)": {"part": "response", "regexes": [
            re.compile(r'.>error.-.expressionengine<.', re.I),
            re.compile(r'.>:.the.uri.you.submitted.has.disallowed.characters.<.', re.I),
            re.compile(r'invalid.(get|post).data', re.I)
        ]},
        "Comodo WAF": {"part": "response", "regexes": [re.compile(r'protected.by.comodo.waf', re.I)]},
        "Cisco ACE XML Gateway": {"part": "response", "regexes": [re.compile(r'ace.xml.gateway', re.I)]}, # Server header
        "Barikode WAF": {"part": "response", "regexes": [
            re.compile(r'.>barikode<.', re.I),
            re.compile(r'<h\d{1}>forbidden.access<.h\d{1}>', re.I)
        ]},
        "WatchGuard": {"part": "response", "regexes": [
            re.compile(r'(request.denied.by.)?watchguard.firewall', re.I),
            re.compile(r'watchguard(.technologies(.inc)?)?', re.I)
        ]},
        "BinarySec WAF": {"part": "response", "regexes": [
            re.compile(r'x.binarysec.via', re.I), # Header
            re.compile(r'x.binarysec.nocache', re.I), # Header
            re.compile(r'binarysec', re.I) # Server header or body
        ]},
        "Bekchy WAF": {"part": "response", "regexes": [
            re.compile(r'bekchy.(-.)?access.denied', re.I),
            re.compile(r'(http(s)?://)(www.)?bekchy.com(/report)?', re.I)
        ]},
        "BitNinja WAF": {"part": "response", "regexes": [
            re.compile(r'bitninja', re.I),
            re.compile(r'security.check.by.bitninja', re.I),
            re.compile(r'.>visitor.anti(\S)?robot.validation<.', re.I)
        ]},
        "Apache (Generic Blocking)": {"part": "response", "regexes": [ # Often with mod_security or custom rules
            re.compile(r'apache', re.I), # Server header
            re.compile(r'.>you.don.t.have.permission.to.access+', re.I),
            re.compile(r'was.not.found.on.this.server', re.I), # Could be 404, but sometimes WAFs use it
            re.compile(r'<address>apache/([\d+{1,2}](.[\d+]{1,2}(.[\d+]{1,3})?)?)?', re.I),
            re.compile(r'<title>403 Forbidden</title>', re.I)
        ]},
        "GreyWizard WAF": {"part": "response", "regexes": [
            re.compile(r'greywizard(.\d.\d(.\d)?)?', re.I),
            re.compile(r'grey.wizard.block', re.I),
            re.compile(r'(http(s)?.//)?(\w+.)?greywizard.com', re.I),
            re.compile(r'grey.wizard', re.I)
        ]},
        "ConfigServer Firewall": {"part": "response", "regexes": [re.compile(r'.>the.firewall.on.this.server.is.blocking.your.connection.<+', re.I)]},
        "Viettel WAF": {"part": "response", "regexes": [
            re.compile(r'<title>access.denied(...)?viettel.waf</title>', re.I),
            re.compile(r'viettel.waf.system', re.I),
            re.compile(r'(http(s).//)?cloudrity.com(.vn)?', re.I)
        ]},
        "SafeDog WAF (China)": {"part": "response", "regexes": [
            re.compile(r'(http(s)?)?(://)?(www|404|bbs|\w+)?.safedog.\w', re.I),
            re.compile(r'waf(.?\d+.?\d+)', re.I)
        ]},
        "Baidu Yunjiasu WAF": {"part": "response", "regexes": [re.compile(r'yunjiasu.nginx', re.I)]}, # Server header
        "AlertLogic WAF": {"part": "response", "regexes": [
            re.compile(r'.>requested.url.cannot.be.found<.', re.I),
            re.compile(r'proceed.to.homepage', re.I),
            re.compile(r'back.to.previous.page', re.I),
            re.compile(r"we('re|.are)?sorry.{1,2}but.the.page.you.are.looking.for.cannot", re.I),
            re.compile(r'reference.id.?', re.I),
            re.compile(r'page.has.either.been.removed.{1,2}renamed', re.I)
        ]},
        "Armor Defense WAF": {"part": "response", "regexes": [re.compile(r'blocked.by.website.protection.from.armour', re.I)]},
        "DOSarrest WAF": {"part": "response", "regexes": [
            re.compile(r'dosarrest', re.I), # Server header or body
            re.compile(r'x.dis.request.id', re.I) # Header
        ]},
        "Palo Alto Networks WAF": {"part": "response", "regexes": [
            re.compile(r'has.been.blocked.in.accordance.with.company.policy', re.I),
            re.compile(r'.>Virus.Spyware.Download.Blocked<.', re.I)
        ]},
        "ASP.NET (Generic Blocking)": {"part": "response", "regexes": [ # Often with built-in request validation
            re.compile(r'this.generic.403.error.means.that.the.authenticated', re.I),
            re.compile(r'request.could.not.be.understood', re.I),
            re.compile(r'<.+>a.potentially.dangerous.request(.querystring)?.+', re.I),
            re.compile(r'runtime.error', re.I),
            re.compile(r'.>a.potentially.dangerous.request.path.value.was.detected.from.the.client+', re.I),
            re.compile(r'asp.net.sessionid', re.I), # Common header, not WAF specific but context
            re.compile(r'errordocument.to.handle.the.request', re.I),
            re.compile(r'an.application.error.occurred.on.the.server', re.I),
            re.compile(r'error.log.record.number', re.I),
            re.compile(r'error.page.might.contain.sensitive.information', re.I),
            re.compile(r"<.+>server.error.in.'/'.application.+", re.I),
            re.compile(r'\basp.net\b', re.I)
        ]},
        "Powerful Firewall": {"part": "response", "regexes": [
            re.compile(r'Powerful Firewall', re.I),
            re.compile(r'http(s)?...tiny.cc.powerful.firewall', re.I)
        ]},
        "UEWAF (UCloud)": {"part": "response", "regexes": [
            re.compile(r'http(s)?.//ucloud', re.I),
            re.compile(r'uewaf(.deny.pages)', re.I)
        ]},
        "Janusec Application Gateway": {"part": "response", "regexes": [
            re.compile(r'janusec', re.I), # Server header or body
            re.compile(r'(http(s)?\W+(www.)?)?janusec.(com|net|org)', re.I)
        ]},
        "SiteGuard (JP-Secure)": {"part": "response", "regexes": [
            re.compile(r'>Powered.by.SiteGuard.Lite<', re.I),
            re.compile(r'refuse.to.browse', re.I)
        ]},
        "SonicWall": {"part": "response", "regexes": [
            re.compile(r'This.request.is.blocked.by.the.SonicWALL', re.I),
            re.compile(r'Dell.SonicWALL', re.I),
            re.compile(r'\bDell\b', re.I), # Generic, be careful
            re.compile(r'Web.Site.Blocked.+\bnsa.banner', re.I),
            re.compile(r'SonicWALL', re.I),
            re.compile(r'.>policy.this.site.is.blocked<.', re.I)
        ]},
        "Jiasule WAF (China)": {"part": "response", "regexes": [
            re.compile(r'^jsl(_)?tracking', re.I), # Header (cookie)
            re.compile(r'(__)?jsluid(=)?', re.I), # Header (cookie)
            re.compile(r'notice.jiasule', re.I),
            re.compile(r'(static|www|dynamic).jiasule.(com|net)', re.I)
        ]},
        "Nginx (Generic Blocking)": {"part": "response", "regexes": [ # Often with ModSecurity or custom rules
            re.compile(r'nginx', re.I), # Server header
            re.compile(r'you.do(not|n.t)?.have.permission.to.access.this.document', re.I)
        ]},
        "StackPath WAF": {"part": "response", "regexes": [
            re.compile(r'action.that.triggered.the.service.and.blocked', re.I),
            re.compile(r'<h2>sorry,.you.have.been.blocked.?<.h2>', re.I)
        ]},
        "Sabre Firewall": {"part": "response", "regexes": [re.compile(r'dxsupport@sabre.com', re.I)]},
        "Wordfence (WordPress)": {"part": "response", "regexes": [
            re.compile(r'generated.by.wordfence', re.I),
            re.compile(r'your.access.to.this.site.has.been.limited', re.I),
            re.compile(r'.>wordfence<.', re.I)
        ]},
        "360 WangZhan卫士 (China)": {"part": "response", "regexes": [
            re.compile(r'.wzws.waf.cgi.', re.I),
            re.compile(r'wangzhan\.360\.cn', re.I),
            re.compile(r'qianxin.waf', re.I),
            re.compile(r'360wzws', re.I),
            re.compile(r'transfer.is.blocked', re.I)
        ]},
        "ASM (Application Security Manager - F5)": {"part": "response", "regexes": [re.compile(r'the.requested.url.was.rejected..please.consult.with.your.administrator.', re.I)]},
        "RSFirewall (Joomla)": {"part": "response", "regexes": [
            re.compile(r'com.rsfirewall.403.forbidden', re.I),
            re.compile(r'com.rsfirewall.event', re.I),
            re.compile(r'(\b)?rsfirewall(\b)?', re.I),
        ]},
        "Sucuri CloudProxy WAF": {"part": "response", "regexes": [
            re.compile(r'access.denied.-.sucuri.website.firewall', re.I),
            re.compile(r'sucuri.webSite.firewall.-.cloudProxy.-.access.denied', re.I),
            re.compile(r'questions\?.+cloudproxy@sucuri\.net', re.I),
            re.compile(r'http(s)?.\/\/(cdn|supportx.)?sucuri(.net|com)?', re.I)
        ]},
        "Airlock WAF (Ergon)": {"part": "response", "regexes": [re.compile(r'\Aal[.-]?(sess|lb)=?', re.I)]}, # Header (cookie)
        "XuanwuDun WAF": {"part": "response", "regexes": [re.compile(r'class=.(db)?waf.?(-row.)?>', re.I)]},
        "ChuangYuDun WAF": {"part": "response", "regexes": [re.compile(r'(http(s)?.//(www.)?)?365cyd.(com|net)', re.I)]},
        "SecureSphere WAF (Imperva)": {"part": "response", "regexes": [ # Generic error pages, often Imperva
            re.compile(r'<h2>error<.h2>', re.I),
            re.compile(r'<title>error<.title>', re.I),
            re.compile(r'<b>error<.b>', re.I),
            re.compile(r'<td.class="(errormessage|error)".height="[0-9]{1,3}".width="[0-9]{1,3}">', re.I),
            re.compile(r'the.incident.id.(is|number.is).', re.I),
            re.compile(r'page.cannot.be.displayed', re.I),
            re.compile(r'contact.support.for.additional.information', re.I)
        ]},
        "Anquanbao WAF (China)": {"part": "response", "regexes": [re.compile(r'.aqb_cc.error.', re.I)]},
        "ModSecurity": {"part": "response", "regexes": [
            re.compile(r'ModSecurity|NYOB', re.I), # Server header or body
            re.compile(r'mod_security', re.I), # Server header or body
            re.compile(r'this.error.was.generated.by.mod.security', re.I),
            re.compile(r'web.server at', re.I), # Often with ModSec
            re.compile(r'page.you.are.(accessing|trying)?.(to|is)?.(access)?.(is|to)?.(restricted)?', re.I),
            re.compile(r'blocked.by.mod.security', re.I)
        ]},
        "ModSecurity (OWASP CRS)": {"part": "response", "regexes": [ # Specific to OWASP Core Rule Set
            re.compile(r'not.acceptable', re.I),
            re.compile(r'additionally\S.a.406.not.acceptable', re.I)
        ]},
        "Squid Proxy (Blocking)": {"part": "response", "regexes": [
            re.compile(r'squid', re.I), # Server header or body
            re.compile(r'Access control configuration prevents', re.I),
            re.compile(r'X.Squid.Error', re.I) # Header
        ]},
        "Shield Security (WordPress)": {"part": "response", "regexes": [
            re.compile(r'blocked.by.the.shield', re.I),
            re.compile(r'transgression(\(s\))?.against.this', re.I),
            re.compile(r'url.{1,2}form.or.cookie.data.wasn.t.appropriate', re.I)
        ]},
        "Wallarm WAF": {"part": "response", "regexes": [re.compile(r'nginx.wallarm', re.I)]}, # Server header
        "Huawei Cloud WAF": {"part": "response", "condition": "and", "regexes": [ # Note: AND condition
            re.compile(r'content="CloudWAF"', re.I), # Meta tag in body
            re.compile(r'Server: CloudWAF', re.I), # Header
            re.compile(r'Set-Cookie: HWWAFSESID=', re.I) # Header
        ]}
        # Add more WAFs here if needed
    }


    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 http_timeout: float = 10.0,
                 active_scan_async_q: Optional[asyncio.Queue] = None
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q
        self.detected_waf_on_target = {} # Cache per target_app_url
        self.logger.debug("WAFFuzzScanRule initialized.")

    async def _emit_alert(self, alert_obj: WAFDetectionAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({
                    "type": "active_scan_alert", "alert": alert_obj.as_dict()
                })
                self.logger.info(f"WAFFuzzScan: Emitted WAF Detection alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"WAFFuzzScan: Failed to emit WAF alert to queue: {e}")
        else:
            self.logger.warning(f"WAFFuzzScan: Async queue not available. WAF Alert not emitted: {alert_obj.name}")

    async def _send_fuzz_attempt(
        self, session: aiohttp.ClientSession, method: str, url: str,
        headers: Optional[Dict[str, str]], cookies: Optional[Dict[str, str]],
        post_data_param_value: Optional[str] = None # For POST, this is the value for '_'
    ) -> Tuple[Optional[str], Optional[Dict[str,str]], Optional[str]]:
        response_text: Optional[str] = None
        response_headers: Optional[Dict[str,str]] = None
        error_type_str: Optional[str] = None
        
        current_headers = (headers or {}).copy()
        if "User-Agent" not in current_headers:
             current_headers["User-Agent"] = "Mozilla/5.0 WAF-Fuzzer/1.0"
        
        request_body_for_log = ""
        data_to_send = None

        if method.upper() == "POST":
            current_headers["Content-Type"] = "application/x-www-form-urlencoded"
            # The Nuclei template sends the payload as the value of a parameter named '_'
            data_to_send = f"_={urllib.parse.quote_plus(post_data_param_value if post_data_param_value else '')}"
            request_body_for_log = data_to_send[:100]
        
        self.logger.debug(f"WAFFuzzScan: Sending {method} to {url} (Payload snippet: {request_body_for_log or 'GET request'})")
        
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.request(method.upper(), url, headers=current_headers, cookies=cookies, data=data_to_send, timeout=timeout, allow_redirects=False) as resp:
                response_headers = dict(resp.headers)
                try:
                    response_text = await resp.text(errors='replace')
                except Exception as e_read:
                    self.logger.debug(f"WAFFuzzScan: Error reading response body from {url}: {e_read}")
        except asyncio.TimeoutError: error_type_str = "TimeoutError"
        except aiohttp.ClientError as e: error_type_str = type(e).__name__
        except Exception as e: error_type_str = type(e).__name__
            
        if error_type_str:
            self.logger.debug(f"WAFFuzzScan: Request for {method} {url} resulted in {error_type_str}.")
            
        return response_text, response_headers, error_type_str

    def _check_for_waf_signatures(self, response_text: Optional[str], response_headers: Optional[Dict[str,str]]) -> Optional[Tuple[str, str]]:
        if not response_text and not response_headers:
            return None

        for waf_name, sig_details in self.WAF_SIGNATURES.items():
            patterns = sig_details["regexes"]
            part_to_check = sig_details["part"] # 'header', 'body', 'response'
            condition_logic = sig_details.get("condition", "or").lower() # 'or' or 'and'

            matches_found_for_this_waf = []

            for pattern_re in patterns:
                matched_in_current_pattern = False
                # Check headers
                if part_to_check in ["header", "response"] and response_headers:
                    for header_name, header_value in response_headers.items():
                        # Some WAFs are identified by header name (e.g., X-Mapping-), others by value
                        if pattern_re.search(header_name) or pattern_re.search(header_value):
                            matches_found_for_this_waf.append(f"Header '{header_name}: {header_value}' matched regex '{pattern_re.pattern}'")
                            matched_in_current_pattern = True
                            break 
                    if matched_in_current_pattern and condition_logic == "or":
                        break # For OR, one pattern match is enough for this WAF's regex list

                # Check body
                if not matched_in_current_pattern and part_to_check in ["body", "response"] and response_text:
                    if pattern_re.search(response_text):
                        matches_found_for_this_waf.append(f"Body content matched regex '{pattern_re.pattern}'")
                        matched_in_current_pattern = True
                
                if matched_in_current_pattern and condition_logic == "or":
                     break # For OR, one pattern match is enough for this WAF's regex list
                elif not matched_in_current_pattern and condition_logic == "and":
                    matches_found_for_this_waf.clear() # For AND, if one pattern fails, this WAF sig fails
                    break


            if condition_logic == "and" and len(matches_found_for_this_waf) == len(patterns) and patterns:
                return waf_name, "; ".join(matches_found_for_this_waf)
            elif condition_logic == "or" and matches_found_for_this_waf:
                return waf_name, matches_found_for_this_waf[0] # Return first match for OR

        return None


    async def scan(
        self,
        original_url: str, 
        aiohttp_session: aiohttp.ClientSession,
        original_headers: Dict[str, str],
        original_cookies: Dict[str, str],
        worker_ident: Optional[str] = "WAFFuzzScan",
        # Other common args for compatibility
        base_app_url: Optional[str] = None, # The base URL of the application
        html_content: Optional[str] = None, # Not directly used for fuzzing, but for passive context
        injection_details: Optional[Dict[str, Any]] = None, # Not strictly needed as we fuzz root/specific paths
        page_specific_technologies: Optional[List[str]] = None,
        service_type_hint: Optional[str] = None, # e.g., "WAF_GENERIC_PRESENCE_HINT"
        attack_strength: str = "MEDIUM" 
    ) -> None:
        
        target_host = urllib.parse.urlparse(original_url).hostname
        target_scheme = urllib.parse.urlparse(original_url).scheme
        if not target_host:
            self.logger.warning(f"[{worker_ident}] WAFFuzzScan: Could not parse hostname from {original_url}. Skipping.")
            return

        # Use base_app_url if provided and seems more appropriate (e.g. root of app)
        # Otherwise, use the original_url's root.
        fuzz_base_url = base_app_url if base_app_url else f"{target_scheme}://{target_host}/"
        
        # Cache check: If we already detected a WAF for this base URL, don't re-fuzz aggressively.
        # The passive scan should ideally catch many WAFs without active fuzzing.
        # This active scan is more for confirmation or catching WAFs missed by passive checks.
        if fuzz_base_url in self.detected_waf_on_target:
            self.logger.info(f"[{worker_ident}] WAF '{self.detected_waf_on_target[fuzz_base_url]}' already detected for {fuzz_base_url}. Skipping redundant fuzzing.")
            # Optionally, re-emit the alert if needed by the system logic
            # For now, just skip to avoid alert spam.
            return

        self.logger.info(f"[{worker_ident}] Starting WAF Fuzz scan for {fuzz_base_url}")

        payloads_to_test = self.WHATWAF_PAYLOADS
        if attack_strength == "LOW":
            # Send a smaller, less aggressive subset for LOW strength
            payloads_to_test = random.sample(self.WHATWAF_PAYLOADS, min(5, len(self.WHATWAF_PAYLOADS)))
        elif attack_strength == "HIGH":
            # Could add more permutations or variations for HIGH if desired
            pass
        
        # The Nuclei template sends payloads to '/' for both GET and POST
        # It iterates through all payloads for GET, then all for POST.
        # We can optimize by stopping if a WAF is found.

        # Test GET requests
        for payload in payloads_to_test:
            # Construct URL with payload: /?_={{payload}}
            test_url_get = f"{fuzz_base_url}?_={urllib.parse.quote_plus(payload)}"
            
            resp_text, resp_headers, net_error = await self._send_fuzz_attempt(
                aiohttp_session, "GET", test_url_get, original_headers, original_cookies
            )
            if net_error: continue # Skip if network error

            waf_match = self._check_for_waf_signatures(resp_text, resp_headers)
            if waf_match:
                waf_name, evidence = waf_match
                self.detected_waf_on_target[fuzz_base_url] = waf_name # Cache detection
                alert = WAFDetectionAlert(
                    cwe_id=200, # Information Exposure (of WAF presence)
                    name=f"{waf_name} Detected (via GET Fuzz)",
                    description=f"A {waf_name} Web Application Firewall was detected by sending a GET request with a fuzzing payload to {fuzz_base_url}.",
                    uri=fuzz_base_url,
                    param="_", # The parameter used in fuzzing
                    attack=f"GET {test_url_get}",
                    evidence=evidence,
                    alert_tags={"Detection": "WAF_Fingerprint", "Appliance": waf_name, "Method": "GET_Fuzz"}
                )
                alert.attack_details = {"target_path": "/", "method": "GET", "fuzz_payload": payload}
                await self._emit_alert(alert)
                self.logger.info(f"[{worker_ident}] Detected WAF '{waf_name}' for {fuzz_base_url} via GET fuzz.")
                return # Stop-at-first-match for the entire target

        # Test POST requests if no WAF found with GET
        if fuzz_base_url not in self.detected_waf_on_target:
            for payload in payloads_to_test:
                # POST to / with payload in body: _={{payload}}
                test_url_post = fuzz_base_url 
                
                resp_text, resp_headers, net_error = await self._send_fuzz_attempt(
                    aiohttp_session, "POST", test_url_post, original_headers, original_cookies,
                    post_data_param_value=payload
                )
                if net_error: continue

                waf_match = self._check_for_waf_signatures(resp_text, resp_headers)
                if waf_match:
                    waf_name, evidence = waf_match
                    self.detected_waf_on_target[fuzz_base_url] = waf_name # Cache detection
                    alert = WAFDetectionAlert(
                        cwe_id=200,
                        name=f"{waf_name} Detected (via POST Fuzz)",
                        description=f"A {waf_name} Web Application Firewall was detected by sending a POST request with a fuzzing payload to {fuzz_base_url}.",
                        uri=fuzz_base_url,
                        param="_",
                        attack=f"POST {test_url_post} DATA: _={payload[:50]}...",
                        evidence=evidence,
                        alert_tags={"Detection": "WAF_Fingerprint", "Appliance": waf_name, "Method": "POST_Fuzz"}
                    )
                    alert.attack_details = {"target_path": "/", "method": "POST", "fuzz_payload": payload}
                    await self._emit_alert(alert)
                    self.logger.info(f"[{worker_ident}] Detected WAF '{waf_name}' for {fuzz_base_url} via POST fuzz.")
                    return # Stop-at-first-match

        if fuzz_base_url not in self.detected_waf_on_target:
             self.logger.info(f"[{worker_ident}] WAF Fuzz scan finished for {fuzz_base_url}. No specific WAF detected with active fuzzing.")
        else:
             self.logger.info(f"[{worker_ident}] WAF Fuzz scan finished for {fuzz_base_url}. WAF '{self.detected_waf_on_target.get(fuzz_base_url)}' was identified.")