# Filename: VulnerabilityChecks/JQueryScanRule.py

import asyncio
import logging
import random
import string
import uuid
import urllib.parse
import html # For XSS evidence
import re
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple, Set

import aiohttp
from bs4 import BeautifulSoup # For parsing HTML and finding script tags/attributes

# --- Alert Dataclass ---
@dataclass
class JQueryVulnerabilityAlert:
    # Non-default arguments first
    cwe_id: int
    name: str
    description: str
    uri: str
    
    # Default arguments follow
    wasc_id: Optional[int] = None
    attack_details: Dict[str, Any] = field(default_factory=dict)
    evidence: str = ""
    solution: str = (
        "Update jQuery and its plugins to the latest secure versions. "
        "Sanitize all user-supplied input before using it in DOM manipulation or dynamic content rendering. "
        "Follow secure coding practices for client-side scripting."
    )
    reference: str = ""
    risk: int = 3
    confidence: int = 2
    alert_tags: Dict[str, str] = field(default_factory=dict)

    def as_dict(self) -> Dict[str, Any]:
        return {
            "vulnerability_type": self.alert_tags.get("Library", "jQuery"),
            "type": self.name,
            "detail": self.description,
            "payload_used": str(self.attack_details.get("payload", "N/A")),
            "injection_point_info": f"{self.attack_details.get('check_type', 'N/A')}: {self.attack_details.get('parameter', self.attack_details.get('component', 'N/A'))}",
            "url_tested": self.uri,
            "severity": {1: "Info", 2: "Low", 3: "Medium", 4: "High"}.get(self.risk, "Unknown"),
            "confidence": {1: "Low", 2: "Medium", 3: "High"}.get(self.confidence, "Unknown"),
            "evidence": self.evidence,
            "solution": self.solution,
            "reference": self.reference,
            "cwe_id": self.cwe_id,
            "wasc_id": self.wasc_id if self.wasc_id else 0,
            "alert_tags": self.alert_tags,
            "other_info": f"Attack Details: {self.attack_details}"
        }

# --- Main Scan Rule Class ---
class JQueryScanRule:
    tech_required: Set[str] = {
        "jcomponent", "jplayer", "jqtouch", "jquery", "jquery cdn",
        "jquery devbridge autocomplete", "jquery migrate", "jquery mobile",
        "jquery modal", "jquery sparklines", "jquery ui", "jquery-pjax",
        "jqplot"
    } # Case-insensitive matching should be handled by the calling engine

    # Payloads for XSS
    XSS_PAYLOAD_BASIC_ALERT = f"JQueryScanRuleXSS{uuid.uuid4().hex[:4]}"
    # Payload for CVE-2020-11022/11023 style issues (self-closing HTML, needs to be used with .html() etc.)
    # The key is that <style/> or <img/> might execute if passed to .html() in vulnerable jQuery versions
    XSS_PAYLOAD_HTMLPREFILTER = f"<style></style><img src=x onerror=alert('{XSS_PAYLOAD_BASIC_ALERT}_htmlp')>"
    # Generic XSS payloads
    XSS_PAYLOADS_GENERIC = [
        f"<script>alert('{XSS_PAYLOAD_BASIC_ALERT}_s')</script>",
        f"'\"><svg onload=alert('{XSS_PAYLOAD_BASIC_ALERT}_svg')>",
        f"<img src=x onerror=alert('{XSS_PAYLOAD_BASIC_ALERT}_img')>",
    ]

    def __init__(self,
                 parent_logger: Optional[logging.Logger] = None,
                 oast_base_url: Optional[str] = None, # Not heavily used in this rule yet
                 http_timeout: float = 10.0,
                 active_scan_async_q: Optional[asyncio.Queue] = None
                 ):
        self.logger = parent_logger or logging.getLogger(__name__)
        self.oast_base_url = self._normalize_oast_url(oast_base_url) if oast_base_url else None
        self.http_timeout = http_timeout
        self.active_scan_async_q = active_scan_async_q

    def _normalize_oast_url(self, url: str) -> Optional[str]:
        if not url: return None
        parsed = urllib.parse.urlparse(url)
        return parsed.netloc if parsed.netloc else None

    async def _send_request(
        self, session: aiohttp.ClientSession, method: str, url: str,
        headers: Optional[Dict[str, str]] = None, params: Optional[Dict[str, Any]] = None,
        data: Optional[Any] = None, allow_redirects: bool = True
    ) -> Tuple[Optional[aiohttp.ClientResponse], str, Dict[str, str], Optional[bytes]]:
        req_headers = (headers or {}).copy()
        if "User-Agent" not in req_headers:
            req_headers["User-Agent"] = f"JQueryScanner/1.0 ({uuid.uuid4().hex[:8]})"

        self.logger.debug(f"JQueryScan: {method} {url}, Params: {params}")
        resp_text, resp_headers_dict, resp_bytes = "", {}, None
        resp_obj = None
        try:
            timeout = aiohttp.ClientTimeout(total=self.http_timeout)
            async with session.request(
                method.upper(), url, headers=req_headers, params=params, data=data,
                timeout=timeout, allow_redirects=allow_redirects
            ) as resp:
                resp_obj = resp
                try:
                    resp_bytes = await resp.read() # Read bytes first
                    resp_text = resp_bytes.decode(errors='replace') # Decode with error handling
                except Exception as e_read:
                    self.logger.warning(f"Error reading response from {url}: {e_read}")
                resp_headers_dict = dict(resp.headers)
                self.logger.debug(f"JQueryScan: Response from {url}: Status {resp.status}")
        except asyncio.TimeoutError:
            self.logger.warning(f"JQueryScan: Request to {url} timed out.")
        except aiohttp.ClientError as e:
            self.logger.warning(f"JQueryScan: Request to {url} client error: {e}")
        except Exception as e_req:
            self.logger.error(f"JQueryScan: Unexpected error for {url}: {e_req}")
        return resp_obj, resp_text, resp_headers_dict, resp_bytes

    async def _emit_alert(self, alert_obj: JQueryVulnerabilityAlert):
        if self.active_scan_async_q:
            try:
                await self.active_scan_async_q.put({
                    "type": "active_scan_alert", "alert": alert_obj.as_dict()
                })
                self.logger.info(f"JQueryScan: Emitted alert - {alert_obj.name} for {alert_obj.uri}")
            except Exception as e:
                self.logger.error(f"JQueryScan: Failed to emit alert to queue: {e}")
        else:
            self.logger.warning(f"JQueryScan: Async queue not available. Alert not emitted: {alert_obj.name}")

    def _extract_jquery_version_from_content(self, html_content: str) -> Optional[str]:
        if not html_content: return None
        # Try jQuery.fn.jquery (most reliable if jQuery is loaded and not heavily modified)
        match_fn = re.search(r"jQuery\.fn\.jquery\s*=\s*[\"']([0-9\.]+)[\"']", html_content, re.IGNORECASE)
        if match_fn: return match_fn.group(1)
        match_val = re.search(r"jquery\s*:\s*[\"']([0-9\.]+)[\"']", html_content, re.IGNORECASE) # Less reliable
        if match_val: return match_val.group(1)

        # Look in script src attributes or comments
        soup = BeautifulSoup(html_content, 'html.parser')
        for script_tag in soup.find_all('script', src=True):
            src = script_tag['src']
            # jquery-1.12.4.min.js, jquery-3.5.0.js, etc.
            match_src = re.search(r"jquery-([0-9\.]+)(\.min)?\.js", src, re.IGNORECASE)
            if match_src: return match_src.group(1)
            match_cdn = re.search(r"ajax.googleapis.com/ajax/libs/jquery/([0-9\.]+)/jquery(\.min)?\.js", src, re.IGNORECASE)
            if match_cdn: return match_cdn.group(1)

        # Look in comments (less reliable)
        # <!-- jQuery v1.12.4 -->
        comment_match = re.search(r"jQuery v?([0-9\.]+)", html_content, re.IGNORECASE)
        if comment_match: return comment_match.group(1)
        return None

    def _extract_plugin_info_from_content(self, html_content: str, service_type_hint: Optional[str]) -> Dict[str, Dict[str, Optional[str]]]:
        """Extracts info about jQuery plugins. Returns dict: {'pluginName': {'version': 'x.y.z', 'src': 'path/to/script.js'}}"""
        if not html_content: return {}
        detected_plugins = {}
        soup = BeautifulSoup(html_content, 'html.parser')

        # Generic plugin detection from script tags
        for script_tag in soup.find_all('script', src=True):
            src = script_tag['src'].lower()
            plugin_name = None
            version = None

            # jQuery UI
            if "jquery-ui" in src or (service_type_hint and "jquery ui" in service_type_hint.lower()):
                plugin_name = "jQuery UI"
                match_ui_ver = re.search(r"jquery-ui-([0-9\.]+)(\.min)?\.js", src) or \
                               re.search(r"jqueryui/([0-9\.]+)/jquery-ui", src)
                if match_ui_ver: version = match_ui_ver.group(1)
                # Check for $.ui.version in script blocks
                if not version:
                    ui_ver_script = re.search(r"\$\.ui\.version\s*=\s*[\"']([0-9\.]+)[\"']", html_content, re.IGNORECASE)
                    if ui_ver_script: version = ui_ver_script.group(1)

            # jQuery Mobile
            elif "jquery.mobile" in src or (service_type_hint and "jquery mobile" in service_type_hint.lower()):
                plugin_name = "jQuery Mobile"
                match_mob_ver = re.search(r"jquery\.mobile-([0-9\.]+)(\.min)?\.js", src)
                if match_mob_ver: version = match_mob_ver.group(1)
            
            # jPlayer
            elif "jplayer" in src or (service_type_hint and "jplayer" in service_type_hint.lower()):
                plugin_name = "jPlayer"
                # Version often in $.jPlayer.prototype.version.script
                jplayer_ver_script = re.search(r"\$\.jPlayer\.prototype\.version\.script\s*=\s*[\"']([0-9\.]+)[\"']", html_content, re.IGNORECASE)
                if jplayer_ver_script: version = jplayer_ver_script.group(1)

            # Add more specific detections for other plugins from the list if patterns are known
            # jQTouch, DevBridge Autocomplete, Modal, Sparklines, pjax, jqPlot, jComponent

            if plugin_name:
                if plugin_name not in detected_plugins or (version and not detected_plugins[plugin_name].get('version')):
                    detected_plugins[plugin_name] = {"version": version, "src": script_tag['src']}
        
        # If service_type_hint indicates a plugin not found via script src, add it without version
        if service_type_hint:
            hint_lower = service_type_hint.lower()
            # Map hints to canonical names if needed
            plugin_map = {
                "jquery ui": "jQuery UI", "jquery mobile": "jQuery Mobile", "jplayer": "jPlayer",
                "jqtouch": "jQTouch", "jquery devbridge autocomplete": "jQuery DevBridge Autocomplete",
                "jquery modal": "jQuery Modal", "jquery sparklines": "jQuery Sparklines",
                "jquery-pjax": "jQuery-pjax", "jqplot": "jqPlot", "jcomponent": "jComponent"
            }
            for hint_key, canonical_name in plugin_map.items():
                if hint_key in hint_lower and canonical_name not in detected_plugins:
                    detected_plugins[canonical_name] = {"version": None, "src": "Hinted by service_type_hint"}
        
        return detected_plugins

    # --- Check Methods ---
    async def _check_jquery_core_xss(
        self, session: aiohttp.ClientSession, base_url: str, html_content: str, jquery_version: Optional[str]
    ):
        cve_ids = ["CVE-2020-11022", "CVE-2020-11023"] # XSS in htmlPrefilter / HTML parsing
        if not jquery_version:
            self.logger.debug(f"jQueryCoreXSS: jQuery version not detected for {base_url}. Skipping CVEs: {', '.join(cve_ids)}.")
            return

        try:
            major, minor, *_ = map(int, jquery_version.split('.'))
            if major >= 3 and minor >= 5: # Patched in 3.5.0
                self.logger.debug(f"jQueryCoreXSS: jQuery version {jquery_version} is not vulnerable to {', '.join(cve_ids)}.")
                return
        except ValueError:
            self.logger.warning(f"jQueryCoreXSS: Could not parse jQuery version '{jquery_version}'. Proceeding with caution.")

        # These CVEs are about how jQuery processes HTML strings passed to .html(), .append(), etc.
        # An active check needs to find where user input might flow into such methods.
        # This is hard to do generically without a browser context or deep code analysis.
        # We can make a heuristic check: if a parameter is reflected and looks like it's part of an HTML string
        # that might be handled by jQuery, we can try the htmlPrefilter payload.

        # This check is simplified: it doesn't actively inject into parameters for this specific CVE yet,
        # as identifying the exact sink is complex. It raises an informational alert if a vulnerable version is found.
        alert = JQueryVulnerabilityAlert(
            cwe_id=79, wasc_id=8,
            name=f"Potentially Vulnerable jQuery Version (related to {', '.join(cve_ids)})",
            description=(
                f"jQuery version {jquery_version} is used, which is potentially vulnerable to XSS via HTML parsing "
                f"(e.g., {', '.join(cve_ids)}). If user-controlled HTML is passed to DOM manipulation methods "
                f"like .html() or .append(), XSS may be possible. Example payload: {self.XSS_PAYLOAD_HTMLPREFILTER}"
            ),
            uri=base_url,
            attack_details={"check_type": "jQuery Version Check", "version": jquery_version, "related_cves": cve_ids},
            evidence=f"jQuery version {jquery_version} detected. Versions < 3.5.0 are vulnerable to {', '.join(cve_ids)}.",
            reference=f"https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/, CVEs: {', '.join(cve_ids)}",
            risk=2, confidence=2, # Medium risk/confidence as it depends on application code
            alert_tags={"Library": "jQuery", "Vulnerability": "XSS_Potential", "CVE_Hint": ", ".join(cve_ids)}
        )
        await self._emit_alert(alert)

    async def _check_jquery_ui_xss(
        self, session: aiohttp.ClientSession, base_url: str, html_content: str,
        jquery_ui_version: Optional[str], service_type_hint: Optional[str]
    ):
        if not ( (service_type_hint and "jquery ui" in service_type_hint.lower()) or \
                 (html_content and ("jquery-ui" in html_content.lower() or ".ui." in html_content.lower())) ): # Basic check for UI presence
            return

        self.logger.debug(f"JQueryUI XSS: Checking for potential XSS in jQuery UI components on {base_url}. Version: {jquery_ui_version or 'Unknown'}")

        # Example: CVE-2016-7103 (Dialog closeText XSS)
        # This requires finding if user input can control the 'closeText' option of a dialog.
        # A generic check is hard. We can look for reflections of URL params that *might* be used in UI options.

        # For now, this is a placeholder. A real check would involve:
        # 1. Identifying specific UI components in use (e.g., Datepicker, Dialog).
        # 2. Checking if URL parameters or other inputs seem to initialize vulnerable options of these components.
        # 3. Injecting payloads into those inputs.
        # Example: If `?title=<img src=x onerror=alert(1)>` and `title` is used for a dialog title.

        # Informational alert if jQuery UI is detected, as many components had XSS issues in older versions.
        alert = JQueryVulnerabilityAlert(
            cwe_id=79, wasc_id=8,
            name="Potential XSS in jQuery UI Components",
            description=(
                f"jQuery UI (version: {jquery_ui_version or 'Unknown'}) is in use. Older versions of various jQuery UI components "
                "(e.g., Datepicker, Dialog, Autocomplete) have known XSS vulnerabilities (e.g., CVE-2021-41182/3/4, CVE-2016-7103). "
                "If user input controls component options or content without proper sanitization, XSS may be possible."
            ),
            uri=base_url,
            attack_details={"check_type": "jQuery UI General", "version": jquery_ui_version or 'Unknown'},
            evidence=f"jQuery UI detected (Version: {jquery_ui_version or 'Unknown'}). Many components had XSS issues in the past.",
            reference="https.jqueryui.com/category/security/, https://snyk.io/vuln/npm:jquery-ui",
            risk=2, confidence=1, # Low confidence without specific vulnerable pattern
            alert_tags={"Library": "jQuery UI", "Vulnerability": "XSS_Potential"}
        )
        await self._emit_alert(alert)


    async def _check_generic_dom_xss_reflection(
        self, session: aiohttp.ClientSession, original_url: str, html_content: str,
        query_params: Dict[str, str] # Extracted query params from original_url
    ):
        if not query_params or not html_content:
            return

        self.logger.debug(f"JQuery DOM XSS: Checking parameter reflections for XSS on {original_url}")

        for param_name, param_value in query_params.items():
            if len(param_value) < 3: continue # Skip very short params

            for xss_payload_template in self.XSS_PAYLOADS_GENERIC:
                # Use a unique marker within the payload for more reliable detection
                unique_marker = self.XSS_PAYLOAD_BASIC_ALERT + "_" + param_name[:5] + uuid.uuid4().hex[:3]
                payload_to_test = xss_payload_template.replace(self.XSS_PAYLOAD_BASIC_ALERT, unique_marker)
                
                # Create new query params with the injected payload
                test_query_params = query_params.copy()
                test_query_params[param_name] = payload_to_test

                # Reconstruct URL with injected param
                parsed_original_url = urllib.parse.urlparse(original_url)
                test_url = parsed_original_url._replace(query=urllib.parse.urlencode(test_query_params)).geturl()

                self.logger.debug(f"JQuery DOM XSS: Testing param '{param_name}' on {original_url} with payload marker '{unique_marker}'")
                _, resp_text_test, _, _ = await self._send_request(session, "GET", test_url)

                if resp_text_test and unique_marker in resp_text_test:
                    # Check if the payload is reflected in a way that might execute
                    # This is a heuristic. A browser environment would be needed for true confirmation.
                    # Look for reflections inside <script>, on*, data-*, src, href (with javascript:)
                    # Ensure it's not simply HTML escaped in a safe context.
                    
                    # Simplified check: if the payload (specifically the <script> or <img onerror part)
                    # appears largely intact.
                    # Example: <script>alert('...marker...')</script>
                    # Example: <img src=x onerror=alert('...marker...')>
                    # Example: href="javascript:alert('...marker...')"
                    
                    # Regex to find the payload in potentially executable contexts
                    # This is very basic and can have false positives/negatives
                    # Looking for the marker inside common XSS patterns
                    # Making sure it's not like &lt;script&gt;alert(...
                    
                    # If the payload was <script>alert('marker')</script>, we search for "alert('marker')"
                    # If <img src=x onerror=alert('marker')>, search for "onerror=alert('marker')"
                    inner_payload_part = None
                    if "<script>" in payload_to_test:
                        inner_payload_part = payload_to_test.split("<script>")[1].split("</script>")[0]
                    elif "onerror=" in payload_to_test:
                        inner_payload_part = payload_to_test.split("onerror=")[1].split("'")[0] + "'" # e.g. alert('marker')
                    
                    if inner_payload_part and inner_payload_part in resp_text_test:
                        # Check if the surrounding characters are not HTML entities
                        idx = resp_text_test.find(inner_payload_part)
                        # Check 10 chars before and after for common escaping like &lt; or " safely in quotes
                        context_snippet = resp_text_test[max(0, idx - 10): idx + len(inner_payload_part) + 10]
                        
                        # Avoid flagging if it's clearly escaped like &lt;script&gt; or inside a safe quoted attribute value
                        # This is still very heuristic.
                        if not ( (resp_text_test[max(0,idx-7):idx].startswith("&lt;script&gt;") or resp_text_test[max(0,idx-1):idx].startswith("<") ) and \
                                 not (context_snippet.startswith('="') or context_snippet.startswith("='")) ): # Avoid simple attribute value reflection

                            alert = JQueryVulnerabilityAlert(
                                cwe_id=79, wasc_id=8,
                                name="Potential DOM-based XSS via Reflected Parameter",
                                description=(
                                    f"Parameter '{param_name}' reflects its value into the page. "
                                    f"A test payload containing marker '{unique_marker}' was found in the response. "
                                    "If jQuery or other JavaScript processes this reflected value unsafely, it could lead to DOM XSS."
                                ),
                                uri=test_url, # The URL with the payload
                                attack_details={"check_type": "DOM XSS Reflection", "parameter": param_name, "payload_marker": unique_marker},
                                evidence=f"Marker '{unique_marker}' from payload in param '{param_name}' reflected in response. Snippet: ...{html.escape(context_snippet)}...",
                                reference="https.owasp.org/www-community/attacks/DOM_Based_XSS",
                                risk=3, confidence=1, # Low confidence without browser execution
                                alert_tags={"Library": "jQuery/JavaScript", "Vulnerability": "XSS_Potential_DOM"}
                            )
                            await self._emit_alert(alert)
                            # Don't return, check other payloads/params

    async def _identify_and_report_plugins(
        self, session: aiohttp.ClientSession, base_url: str,
        detected_plugins_info: Dict[str, Dict[str, Optional[str]]]
    ):
        if not detected_plugins_info:
            return

        for plugin_name, info in detected_plugins_info.items():
            version = info.get("version", "Unknown")
            src_path = info.get("src", "N/A")
            alert = JQueryVulnerabilityAlert(
                cwe_id=1104, # Use of Unmaintained Third Party Components (general category if old)
                            # Or 200 (Information Exposure - about component usage)
                name=f"jQuery Plugin Detected: {plugin_name}",
                description=(
                    f"The jQuery plugin '{plugin_name}' (Version: {version}) was detected (Source hint: {src_path}). "
                    "Review this plugin for known CVEs specific to its version and ensure it is up to date. "
                    "Many jQuery plugins have had vulnerabilities like XSS or Open Redirect."
                ),
                uri=base_url,
                attack_details={"check_type": "Plugin Identification", "component": plugin_name, "version": version, "source_hint": src_path},
                evidence=f"Detected {plugin_name} (Version: {version}). Source hint: {src_path}",
                reference="Check plugin's official website, CVE databases (NVD, Snyk, etc.) for vulnerabilities.",
                risk=1, confidence=3, # Informational
                alert_tags={"Library": plugin_name, "Detection": "ComponentVersion"}
            )
            await self._emit_alert(alert)
            # Here, one could add calls to specific CVE checks for this plugin if available
            # e.g., if plugin_name == "jPlayer": await self._check_jplayer_cves(...)


    # --- Main Scan Orchestration Method ---
    async def scan(
        self,
        base_app_url: str,
        aiohttp_session: aiohttp.ClientSession,
        service_type_hint: Optional[str] = None, # e.g., "jquery ui", "jplayer", "generic_jquery"
        original_url: Optional[str] = None, # The specific URL that triggered this scan
        original_headers: Optional[Dict[str, str]] = None,
        original_cookies: Optional[Dict[str, str]] = None,
        injection_details: Optional[Dict[str, Any]] = None, # Not heavily used by this rule
        html_content: Optional[str] = None # HTML of original_url
    ):
        self.logger.info(f"JQueryScanRule: Starting scan for base_url='{base_app_url}', service_hint='{service_type_hint}', specific_page='{original_url}'")

        page_specific_url = original_url if original_url else base_app_url
        
        if not html_content: # Fetch if not provided
            _, html_content, _, _ = await self._send_request(aiohttp_session, "GET", page_specific_url)
            if not html_content:
                self.logger.warning(f"JQueryScan: Could not retrieve HTML content for {page_specific_url}. Aborting jQuery checks for this page.")
                return

        jquery_version = self._extract_jquery_version_from_content(html_content)
        if jquery_version:
            self.logger.info(f"JQueryScan: Detected jQuery version {jquery_version} on {page_specific_url}")
            alert = JQueryVulnerabilityAlert(
                cwe_id=200, name="jQuery Version Detected",
                description=f"jQuery version {jquery_version} is used on the page.",
                uri=page_specific_url, attack_details={"check_type": "VersionDetection", "component": "jQuery", "version": jquery_version},
                evidence=f"jQuery version {jquery_version} identified.", risk=1, confidence=3,
                alert_tags={"Library": "jQuery", "Detection": "Version"}
            )
            await self._emit_alert(alert)
            await self._check_jquery_core_xss(aiohttp_session, page_specific_url, html_content, jquery_version)
        else:
            self.logger.info(f"JQueryScan: jQuery core version not reliably detected on {page_specific_url}. Some checks may be skipped.")
            # Still proceed with other checks as jQuery might be present but version undetectable by simple means

        detected_plugins = self._extract_plugin_info_from_content(html_content, service_type_hint)
        if detected_plugins:
            self.logger.info(f"JQueryScan: Detected plugins: {detected_plugins.keys()} on {page_specific_url}")
            await self._identify_and_report_plugins(aiohttp_session, page_specific_url, detected_plugins)
        
        # jQuery UI specific checks
        jquery_ui_info = detected_plugins.get("jQuery UI")
        jquery_ui_version = jquery_ui_info.get("version") if jquery_ui_info else None
        await self._check_jquery_ui_xss(aiohttp_session, page_specific_url, html_content, jquery_ui_version, service_type_hint)

        # Generic DOM XSS reflection check using query parameters from original_url
        parsed_original_url = urllib.parse.urlparse(page_specific_url) # Use page_specific_url for query params
        query_params = urllib.parse.parse_qs(parsed_original_url.query)
        # parse_qs returns list of values, flatten to single string for simplicity here
        flattened_query_params = {k: v[0] if v else "" for k, v in query_params.items()}
        if flattened_query_params:
            await self._check_generic_dom_xss_reflection(aiohttp_session, page_specific_url, html_content, flattened_query_params)
        
        # Placeholder for _check_specific_plugin_cves
        # await self._check_specific_plugin_cves(aiohttp_session, page_specific_url, html_content, service_type_hint, detected_plugins)


        self.logger.info(f"JQueryScanRule: Scan finished for {page_specific_url}")