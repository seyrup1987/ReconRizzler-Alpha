# Filename: ActiveVulnerabilityCheck.py

import asyncio
import json
import logging
import random
import re
import html
import inspect
from typing import Any, Dict, List, Optional, Tuple, Set
from urllib.parse import parse_qs, urlencode, urlparse, urljoin

import aiohttp
from bs4 import BeautifulSoup

# --- Import ALL Active Scan Rule Classes ---
from .VulnerabilityChecks.CodeInjectionScanRule import CodeInjectionScanRule
from .VulnerabilityChecks.CommandInjectionScanRule import CommandInjectionScanRule
from .VulnerabilityChecks.CrossSiteScriptingScanRule import CrossSiteScriptingScanRule
from .VulnerabilityChecks.SqlInjectionScanRule import SqlInjectionScanRule
from .VulnerabilityChecks.SqlInjectionSqLiteScanRule import SqlInjectionSqLiteScanRule
from .VulnerabilityChecks.SqlInjectionPostgreScanRule import SqlInjectionPostgreScanRule
from .VulnerabilityChecks.SqlInjectionMySqlScanRule import SqlInjectionMySqlScanRule
from .VulnerabilityChecks.XXEScanRule import XXEScanRule
from .VulnerabilityChecks.BufferOverflowScanRule import BufferOverflowScanRule, BufferOverflowAlert # Import Alert
from .VulnerabilityChecks.Log4ShellScanRule import Log4ShellScanRule
from .VulnerabilityChecks.RemoteCodeExecutionCve20121823ScanRule import RemoteCodeExecutionCve20121823ScanRule
from .VulnerabilityChecks.SourceCodeDisclosureCve20121823ScanRule import SourceCodeDisclosureCve20121823ScanRule
from .VulnerabilityChecks.SourceCodeDisclosureWebInfScanRule import SourceCodeDisclosureWebInfScanRule
from .VulnerabilityChecks.SSRFScanRule import SSRFScanRule, SSRFAlert # Import Alert
from .VulnerabilityChecks.ApacheSupersetMultiCVEScanRule import ApacheSupersetMultiCVEScanRule
from .VulnerabilityChecks.F5BigIPScanRule import F5BigIPScanRule
from .VulnerabilityChecks.JenkinsCVE202423897ScanRule import JenkinsCVE202423897ScanRule
from .VulnerabilityChecks.GitLabExifToolRCECVE202122205ScanRule import GitLabExifToolRCECVE202122205ScanRule
from .VulnerabilityChecks.ConfluenceOGNLInjectionCVE202226134ScanRule import ConfluenceOGNLInjectionCVE202226134ScanRule
from .VulnerabilityChecks.ApacheOFBizAuthBypassRCECVE202445195ScanRule import ApacheOFBizAuthBypassRCECVE202445195ScanRule
from .VulnerabilityChecks.BitrixActiveScanRule import BitrixActiveScanRule
from .VulnerabilityChecks.ApacheTomcatScanRule import ApacheTomcatScanRule
from .VulnerabilityChecks.AmazonWebServicesScanRule import AmazonWebServicesScanRule
from .VulnerabilityChecks.ASPNetScanRule import ASPNetScanRule
from .VulnerabilityChecks.JQueryScanRule import JQueryScanRule, JQueryVulnerabilityAlert # Import Alert
from .VulnerabilityChecks.ServerSideTemplateInjectionScanRule import ServerSideTemplateInjectionScanRule

# --- NEWLY INTEGRATED SCAN RULES ---
from .VulnerabilityChecks.LinuxLFIScanRule import LinuxLFIScanRule, LFIAlert # NEW
from .VulnerabilityChecks.WAFFuzzScanRule import WAFFuzzScanRule, WAFDetectionAlert # NEW
from .VulnerabilityChecks.XFF403BypassScanRule import XFF403BypassScanRule, XFF403BypassAlert # NEW


logger = logging.getLogger(__name__)

class ActiveVulnerabilityCheck:
    def __init__(self,
                 active_scan_timeout: float,
                 oast_base_url: Optional[str],
                 aiohttp_session: aiohttp.ClientSession,
                 parent_logger: Optional[logging.Logger] = None,
                 sqli_generic_config: Optional[Dict[str, Any]] = None,
                 active_scan_async_q: Optional[asyncio.Queue] = None
                ):
        self.active_scan_timeout = active_scan_timeout
        self.oast_base_url = oast_base_url
        self.aiohttp_session = aiohttp_session
        self.logger = parent_logger or logger
        self.active_scan_async_q = active_scan_async_q

        self.logger.info("Initializing all active scan rules... Passive hint correlation logic is active.")

        # --- Instantiate ALL Scan Rules ---
        # Existing Scanners
        self.buffer_overflow_scanner = BufferOverflowScanRule(parent_logger=self.logger, http_timeout=self.active_scan_timeout * 1.5, active_scan_async_q=self.active_scan_async_q)
        self.code_injection_scanner = CodeInjectionScanRule(parent_logger=self.logger, active_scan_async_q=self.active_scan_async_q, http_timeout=active_scan_timeout)
        self.command_injection_scanner = CommandInjectionScanRule(parent_logger=self.logger, active_scan_async_q=self.active_scan_async_q, http_timeout=active_scan_timeout)
        self.cross_site_scripting_scanner = CrossSiteScriptingScanRule(parent_logger=self.logger, active_scan_async_q=self.active_scan_async_q, http_timeout=active_scan_timeout)
        self.ssrf_scanner = SSRFScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=self.active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.sql_injection_scanner = SqlInjectionScanRule(parent_logger=self.logger, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q, **(sqli_generic_config or {}))
        self.sqlite_injection_scanner = SqlInjectionSqLiteScanRule(parent_logger=self.logger, active_scan_async_q=self.active_scan_async_q, **(sqli_generic_config or {}))
        self.postgres_injection_scanner = SqlInjectionPostgreScanRule(parent_logger=self.logger, active_scan_async_q=self.active_scan_async_q, **(sqli_generic_config or {}))
        self.mysql_injection_scanner = SqlInjectionMySqlScanRule(parent_logger=self.logger, active_scan_async_q=self.active_scan_async_q, **(sqli_generic_config or {}))
        self.xxe_scanner = XXEScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.log4shell_scanner = Log4ShellScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.rce_cve20121823_scanner = RemoteCodeExecutionCve20121823ScanRule(parent_logger=self.logger, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.source_disclosure_cve20121823_scanner = SourceCodeDisclosureCve20121823ScanRule(parent_logger=self.logger, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.source_disclosure_webinf_scanner = SourceCodeDisclosureWebInfScanRule(parent_logger=self.logger, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.ofbiz_scanner = ApacheOFBizAuthBypassRCECVE202445195ScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.jenkins_scanner = JenkinsCVE202423897ScanRule(parent_logger=self.logger, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.gitlab_scanner = GitLabExifToolRCECVE202122205ScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=active_scan_timeout * 1.5, active_scan_async_q=self.active_scan_async_q)
        self.confluence_scanner = ConfluenceOGNLInjectionCVE202226134ScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.superset_scanner = ApacheSupersetMultiCVEScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.f5bigip_scanner = F5BigIPScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.bitrix_scanner = BitrixActiveScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=self.active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.tomcat_scanner = ApacheTomcatScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=self.active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.aws_scanner = AmazonWebServicesScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=self.active_scan_timeout, tcp_connect_timeout=max(1.0, self.active_scan_timeout / 5), active_scan_async_q=self.active_scan_async_q)
        self.aspnet_scanner = ASPNetScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=self.active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.jquery_scanner = JQueryScanRule(parent_logger=self.logger, oast_base_url=self.oast_base_url, http_timeout=self.active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.ssti_scanner = ServerSideTemplateInjectionScanRule(parent_logger=self.logger, active_scan_async_q=self.active_scan_async_q, http_timeout=active_scan_timeout)

        # NEWLY ADDED SCANNERS
        self.linux_lfi_scanner = LinuxLFIScanRule(parent_logger=self.logger, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.waf_fuzz_scanner = WAFFuzzScanRule(parent_logger=self.logger, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)
        self.xff_403_bypass_scanner = XFF403BypassScanRule(parent_logger=self.logger, http_timeout=active_scan_timeout, active_scan_async_q=self.active_scan_async_q)


        self.all_scanners = [
            self.buffer_overflow_scanner, self.code_injection_scanner, self.command_injection_scanner,
            self.cross_site_scripting_scanner, self.ssrf_scanner, self.sql_injection_scanner,
            self.sqlite_injection_scanner, self.postgres_injection_scanner, self.mysql_injection_scanner,
            self.xxe_scanner, self.log4shell_scanner, self.rce_cve20121823_scanner,
            self.source_disclosure_cve20121823_scanner, self.source_disclosure_webinf_scanner,
            self.ofbiz_scanner, self.jenkins_scanner, self.gitlab_scanner, self.confluence_scanner,
            self.superset_scanner, self.f5bigip_scanner,
            self.bitrix_scanner, self.tomcat_scanner, self.aws_scanner,
            self.aspnet_scanner, self.jquery_scanner, self.ssti_scanner,
            self.linux_lfi_scanner,      # NEW
            self.waf_fuzz_scanner,       # NEW
            self.xff_403_bypass_scanner, # NEW
        ]

        for scanner_instance in self.all_scanners:
            if not hasattr(scanner_instance, 'tech_required'):
                scanner_instance.tech_required = set() # type: ignore
            scanner_instance.tech_required = {str(tech).lower() for tech in getattr(scanner_instance, 'tech_required', set())} # type: ignore

        self.agnostic_scanners = [s for s in self.all_scanners if not s.tech_required]
        self.specific_scanners = [s for s in self.all_scanners if s.tech_required]

        self.logger.info(f"Active vulnerability scanners initialized. Total: {len(self.all_scanners)}, Agnostic: {len(self.agnostic_scanners)}, Specific: {len(self.specific_scanners)}")

    def _identify_injection_points(self, url: str, html_content: Optional[str], headers: Dict[str, str], cookies: Dict[str, str], http_method_original: str = "GET", request_body_original: Optional[str] = None) -> Dict[str, Any]:
        self.logger.debug(f"Identifying injection points for {url} (Method: {http_method_original})")
        injection_points: Dict[str, Any] = {
            "url_params": [], "headers": [], "cookies": [], "forms": [],
            "request_body_json_fields": [], "request_body_xml_raw": None, "request_body_text_raw": None
        }
        
        parsed_url = urlparse(url)
        for param_name, values in parse_qs(parsed_url.query, keep_blank_values=True).items():
            injection_points["url_params"].append({"name": param_name, "original_value": values[0] if values else ""})

        for h_name, h_value in headers.items():
            injection_points["headers"].append({"name": h_name, "original_value": h_value})
        for c_name, c_value in cookies.items(): # cookies is {name: value_string}
            injection_points["cookies"].append({"name": c_name, "original_value": c_value})

        if html_content:
            try:
                soup = BeautifulSoup(html_content, 'html.parser')
                for form_tag in soup.find_all('form'):
                    form_action = form_tag.get('action', url)
                    form_method = form_tag.get('method', 'GET').upper()
                    form_fields_list = []
                    original_form_fields_dict = {}
                    for input_tag in form_tag.find_all(['input', 'select', 'textarea']):
                        field_name = input_tag.get('name')
                        field_value = input_tag.get('value', '') 
                        if input_tag.name == 'textarea': 
                            field_value = input_tag.string or ''
                        elif input_tag.name == 'select':
                            selected_option = input_tag.find('option', selected=True)
                            if selected_option: field_value = selected_option.get('value', selected_option.string or '')
                        
                        if field_name is not None: 
                            form_fields_list.append({"name": field_name, "original_value": field_value})
                            original_form_fields_dict[field_name] = field_value
                    
                    if form_fields_list: 
                        injection_points["forms"].append({
                            "action_url": urljoin(url, form_action), "method": form_method,
                            "fields": form_fields_list, "all_form_fields": original_form_fields_dict
                        })
            except Exception as e_form_parse:
                self.logger.warning(f"Error parsing forms from {url}: {e_form_parse}")
        
        content_type_header = headers.get("Content-Type", headers.get("content-type", "")).lower()
        if http_method_original.upper() in ["POST", "PUT", "PATCH"] and request_body_original:
            if "application/json" in content_type_header:
                try:
                    json_body = json.loads(request_body_original)
                    injection_points["request_body_json_fields"].append({
                        "name": "REQUEST_BODY", 
                        "original_value": request_body_original, 
                        "original_full_body": json_body, 
                        "content_type": "application/json"
                    })
                except json.JSONDecodeError:
                    self.logger.debug(f"Could not parse JSON body for {url}, treating as text.")
                    injection_points["request_body_text_raw"] = request_body_original
            elif "application/xml" in content_type_header or "text/xml" in content_type_header:
                injection_points["request_body_xml_raw"] = request_body_original
            elif "application/x-www-form-urlencoded" not in content_type_header: # Already handled by forms if applicable
                injection_points["request_body_text_raw"] = request_body_original

        self.logger.debug(f"Identified injection points summary for {url}: URL Params={len(injection_points['url_params'])}, Forms={len(injection_points['forms'])}, JSON Fields={len(injection_points['request_body_json_fields'])}, XMLRaw={injection_points['request_body_xml_raw'] is not None}, TextRaw={injection_points['request_body_text_raw'] is not None}, Headers={len(injection_points['headers'])}, Cookies={len(injection_points['cookies'])}")
        return injection_points

    def _derive_base_app_url(self, original_url: str) -> str:
        parsed = urlparse(original_url)
        base = f"{parsed.scheme}://{parsed.netloc}"
        if parsed.path and parsed.path != "/":
            first_segment = parsed.path.strip('/').split('/')[0]
            common_app_segments = {"ofbiz", "jenkins", "gitlab", "confluence", "superset", "bitrix", "examples", "docs", "admin", "manager"}
            if first_segment and (first_segment in common_app_segments or (len(first_segment) > 1 and len(first_segment) < 20 and not re.match(r".*\.(php|aspx|jsp|html|htm|do|action)$", first_segment, re.IGNORECASE))):
                return f"{base}/{first_segment}/"
        return f"{base}/"

    def _get_service_type_hint_from_passive(self, passive_hint_type: str) -> Optional[str]:
        hint_lower = passive_hint_type.lower()
        if "php_" in hint_lower: return "php"
        if "asp_net_" in hint_lower or "asp_" in hint_lower : return "asp.net"
        if "xml_" in hint_lower: return "xml"
        if "jquery_core" in hint_lower: return "jquery"
        if "jquery_ui" in hint_lower: return "jquery ui"
        if "jquery_mobile" in hint_lower: return "jquery mobile"
        if "jplayer" in hint_lower: return "jplayer"
        if "lfi_linux" in hint_lower: return "linux" # For LFI hints
        # WAF hints are more about presence, not a "service type" for other scanners.
        # 403 hint is a condition, not a service type.
        return None

    async def _execute_scanner_safely(
        self, scanner_instance: Any, scan_method_name: str, available_args: Dict[str, Any],
        worker_ident: str, url_for_log: str
    ):
        scan_method = getattr(scanner_instance, scan_method_name, None)
        if not scan_method or not callable(scan_method):
            self.logger.warning(f"[{worker_ident}] Scanner '{type(scanner_instance).__name__}' does not have a callable '{scan_method_name}' method. Skipping for {url_for_log}.")
            return

        sig = inspect.signature(scan_method)
        method_params_names = set(sig.parameters.keys())
        
        current_scan_kwargs = {}
        for arg_name, arg_val in available_args.items():
            if arg_name in method_params_names:
                current_scan_kwargs[arg_name] = arg_val
        
        if 'aiohttp_session' in method_params_names and 'aiohttp_session' not in current_scan_kwargs:
            current_scan_kwargs['aiohttp_session'] = self.aiohttp_session
        
        self.logger.debug(f"[{worker_ident}] Calling {type(scanner_instance).__name__}.{scan_method_name} for {url_for_log} with args: {list(current_scan_kwargs.keys())}")
        try:
            await scan_method(**current_scan_kwargs)
        except Exception as e_scan_exec:
            self.logger.error(f"[{worker_ident}] Error executing {type(scanner_instance).__name__}.{scan_method_name} for {url_for_log}: {e_scan_exec}", exc_info=True)


    async def perform_active_scan_for_page(self,
                                           original_url: str, html_content: Optional[str],
                                           headers: Dict[str, str], cookies: Dict[str, str],
                                           worker_ident: str,
                                           page_specific_technologies: Optional[List[str]] = None,
                                           http_method_original: str = "GET",
                                           request_body_original: Optional[str] = None,
                                           passive_scan_hints: Optional[List[Dict[str, Any]]] = None
                                           ) -> None:
        self.logger.info(f"[{worker_ident}] Starting PARAMETER-BASED active scans for: {original_url} (Method: {http_method_original})")
        if passive_scan_hints:
            self.logger.debug(f"[{worker_ident}] Received {len(passive_scan_hints)} passive hints for correlation.")
        
        current_page_techs_lower: Set[str] = {str(tech).lower() for tech in (page_specific_technologies or [])}
        base_app_url = self._derive_base_app_url(original_url)
        
        injection_points = self._identify_injection_points(original_url, html_content, headers, cookies, http_method_original, request_body_original)
        
        available_scan_args_base = {
            "base_app_url": base_app_url, "original_url": original_url, "html_content": html_content,
            "original_headers": headers, "original_cookies": cookies, "aiohttp_session": self.aiohttp_session,
            "worker_ident": worker_ident, "page_specific_technologies": list(current_page_techs_lower),
            "http_method_original": http_method_original, "request_body_original": request_body_original,
            "injection_details": None, "service_type_hint": None, "is_admin_context": False,
            "attack_strength": "MEDIUM",
            "original_page_content_for_baseline_errors": html_content
        }

        # Extract page-level passive hints (not tied to a specific parameter)
        page_level_passive_hint_types: Set[str] = set()
        if passive_scan_hints:
            for hint in passive_scan_hints:
                if not hint.get("affected_parameter_name") and hint.get("specific_passive_hint_type"):
                    page_level_passive_hint_types.add(hint["specific_passive_hint_type"])


        parameter_tasks = []
        all_parameter_like_points: List[Dict[str, Any]] = []
        for p_data in injection_points.get("url_params", []):
            all_parameter_like_points.append({**p_data, "location": "url_params", "method": "GET", "action_url": original_url, "param_name": p_data.get("name")})
        for form_data in injection_points.get("forms", []):
            for field_data in form_data.get("fields", []):
                all_parameter_like_points.append({
                    **field_data, "location": f"form_data_{form_data.get('method', 'GET').lower()}",
                    "method": form_data.get('method', 'GET').upper(), "action_url": form_data.get('action_url', original_url),
                    "all_form_fields": form_data.get("all_form_fields"), 
                    "param_name": field_data.get("name")
                })
        for h_data in injection_points.get("headers", []):
             all_parameter_like_points.append({**h_data, "location": "header", "method": http_method_original, "action_url": original_url, "param_name": h_data.get("name")})
        for c_data in injection_points.get("cookies", []):
             all_parameter_like_points.append({**c_data, "location": "cookie", "method": http_method_original, "action_url": original_url, "param_name": c_data.get("name")})
        
        if injection_points.get("request_body_json_fields"):
            json_body_point_details = injection_points["request_body_json_fields"][0]
            all_parameter_like_points.append({
                "param_name": json_body_point_details.get("name", "REQUEST_BODY"),
                "original_value": json_body_point_details.get("original_value"),
                "original_full_body": json_body_point_details.get("original_full_body"),
                "location": "request_body_json_fields", "method": http_method_original, "action_url": original_url,
                "content_type": json_body_point_details.get("content_type"),
                "original_content_type": json_body_point_details.get("content_type") # For BOF
            })
        if injection_points.get("request_body_xml_raw"):
            all_parameter_like_points.append({
                "param_name": "REQUEST_BODY", 
                "original_value": injection_points["request_body_xml_raw"],
                "location": "request_body_xml_raw", "method": http_method_original, "action_url": original_url,
                "original_content_type": headers.get("Content-Type", headers.get("content-type", "application/xml")).lower() # For BOF
            })
        if injection_points.get("request_body_text_raw"):
            all_parameter_like_points.append({
                "param_name": "REQUEST_BODY", 
                "original_value": injection_points["request_body_text_raw"],
                "location": "request_body_text_raw", "method": http_method_original, "action_url": original_url,
                "original_content_type": headers.get("Content-Type", headers.get("content-type", "text/plain")).lower() # For BOF
            })

        if not all_parameter_like_points:
            self.logger.info(f"[{worker_ident}] No parameter-like injection points identified for {original_url}. Skipping parameter-based scans.")
        else:
            self.logger.info(f"[{worker_ident}] Identified {len(all_parameter_like_points)} parameter-like injection points for {original_url}.")

        for point_details in all_parameter_like_points:
            current_param_name = point_details.get("param_name")
            current_location = point_details.get("location")
            
            relevant_passive_hint_types_for_param: Set[str] = set()
            param_specific_service_hints_from_passive: Set[str] = set()

            if passive_scan_hints:
                for hint in passive_scan_hints:
                    hint_param_name = hint.get("affected_parameter_name")
                    hint_location_passive = hint.get("affected_parameter_location") # Renamed to avoid clash
                    hint_type = hint.get("specific_passive_hint_type") # Use specific_passive_hint_type

                    if hint_type and \
                       ( (hint_param_name == current_param_name and hint_location_passive == current_location) or \
                         (not hint_param_name and hint_location_passive == current_location and current_location in ["header", "cookie"]) ): # Global hint for this location (header/cookie)
                        relevant_passive_hint_types_for_param.add(hint_type)
                        derived_service_hint = self._get_service_type_hint_from_passive(hint_type)
                        if derived_service_hint:
                            param_specific_service_hints_from_passive.add(derived_service_hint)
            
            if relevant_passive_hint_types_for_param:
                self.logger.info(f"[{worker_ident}] Param '{current_param_name}' (Loc: {current_location}) has passive hint types: {relevant_passive_hint_types_for_param}")

            scanners_to_run_for_this_point: List[Any] = []
            
            agnostic_param_scanners = [s for s in self.agnostic_scanners if not isinstance(s, (JQueryScanRule, WAFFuzzScanRule, XFF403BypassScanRule))] # Exclude page/URL-only
            scanners_to_run_for_this_point.extend(agnostic_param_scanners)

            effective_techs_for_point = current_page_techs_lower.union(param_specific_service_hints_from_passive)
            for specific_scanner in self.specific_scanners:
                if isinstance(specific_scanner, (ApacheTomcatScanRule, AmazonWebServicesScanRule, JQueryScanRule, ASPNetScanRule, BitrixActiveScanRule)): 
                    continue
                if hasattr(specific_scanner, 'tech_required') and specific_scanner.tech_required.intersection(effective_techs_for_point):
                    if specific_scanner not in scanners_to_run_for_this_point: 
                        scanners_to_run_for_this_point.append(specific_scanner)
            
            self.logger.debug(f"[{worker_ident}] For point '{current_param_name}' ({current_location}), considering {len(scanners_to_run_for_this_point)} scanners based on effective techs: {effective_techs_for_point}")

            for scanner in scanners_to_run_for_this_point:
                current_point_scan_args = available_scan_args_base.copy()
                current_point_scan_args["injection_details"] = point_details # This now includes original_content_type for BOF
                current_point_scan_args["original_url"] = point_details.get("action_url", original_url)
                
                current_attack_strength = "MEDIUM" 
                service_hint_for_scanner = None

                # Correlation Logic for Attack Strength and Service Hint
                if isinstance(scanner, CommandInjectionScanRule):
                    if any("CMD_INJ_" in hint_type for hint_type in relevant_passive_hint_types_for_param): current_attack_strength = "HIGH"
                elif isinstance(scanner, (SqlInjectionScanRule, SqlInjectionMySqlScanRule, SqlInjectionPostgreScanRule, SqlInjectionSqLiteScanRule)):
                    if any("SQLI_" in hint_type for hint_type in relevant_passive_hint_types_for_param): current_attack_strength = "HIGH"
                elif isinstance(scanner, CrossSiteScriptingScanRule):
                    if any("XSS_" in hint_type for hint_type in relevant_passive_hint_types_for_param): current_attack_strength = "HIGH"
                elif isinstance(scanner, CodeInjectionScanRule):
                    if any("PHP_" in hint_type for hint_type in relevant_passive_hint_types_for_param): service_hint_for_scanner = "php"; current_attack_strength = "HIGH"
                    elif any("ASP_NET_" in hint_type for hint_type in relevant_passive_hint_types_for_param): service_hint_for_scanner = "asp.net"; current_attack_strength = "HIGH"
                elif isinstance(scanner, XXEScanRule):
                    if any("XML_" in hint_type for hint_type in relevant_passive_hint_types_for_param): service_hint_for_scanner = "xml"; current_attack_strength = "HIGH"
                elif isinstance(scanner, SSRFScanRule):
                    if any("SSRF_" in hint_type for hint_type in relevant_passive_hint_types_for_param): current_attack_strength = "HIGH"
                elif isinstance(scanner, ServerSideTemplateInjectionScanRule):
                    if any("SSTI_" in hint_type for hint_type in relevant_passive_hint_types_for_param): current_attack_strength = "HIGH"
                elif isinstance(scanner, LinuxLFIScanRule): # NEW LFI
                    if any("LFI_LINUX_PARAM_NAME_HINT" in hint_type for hint_type in relevant_passive_hint_types_for_param):
                        current_attack_strength = "HIGH"
                        service_hint_for_scanner = "linux" # Reinforce
                elif isinstance(scanner, BufferOverflowScanRule): # NEW BOF Strength
                    combined_hints_for_bof = relevant_passive_hint_types_for_param.union(page_level_passive_hint_types)
                    if any("BOF_INPUT_SIZE_LIMIT_MESSAGE_HINT" in hint_type for hint_type in combined_hints_for_bof):
                        current_attack_strength = "HIGH"
                    elif any("BOF_PARAM_NAME_CANDIDATE_HINT" in hint_type for hint_type in relevant_passive_hint_types_for_param) or \
                         any("BOF_HEADER_NAME_CANDIDATE_HINT" in hint_type for hint_type in relevant_passive_hint_types_for_param):
                        current_attack_strength = "MEDIUM" # Default for candidates
                    else:
                        current_attack_strength = "LOW" # If no specific BOF hints for this param/page

                if current_attack_strength != "MEDIUM":
                     self.logger.info(f"[{worker_ident}] Adjusting {type(scanner).__name__} strength to {current_attack_strength} for '{current_param_name}' ({current_location}) based on passive hints.")
                current_point_scan_args["attack_strength"] = current_attack_strength
                
                if not service_hint_for_scanner and hasattr(scanner, 'tech_required') and scanner.tech_required:
                    matching_param_techs = scanner.tech_required.intersection(param_specific_service_hints_from_passive)
                    if matching_param_techs:
                        service_hint_for_scanner = list(matching_param_techs)[0]
                    else:
                        matching_page_techs = scanner.tech_required.intersection(current_page_techs_lower)
                        if matching_page_techs:
                            service_hint_for_scanner = list(matching_page_techs)[0]
                
                current_point_scan_args["service_type_hint"] = service_hint_for_scanner
                if service_hint_for_scanner:
                    self.logger.debug(f"[{worker_ident}] Providing service_type_hint='{service_hint_for_scanner}' to {type(scanner).__name__} for param '{current_param_name}'.")

                parameter_tasks.append(self._execute_scanner_safely(scanner, "scan", current_point_scan_args, worker_ident, current_point_scan_args["original_url"]))
        
        if parameter_tasks:
            self.logger.info(f"[{worker_ident}] Scheduling {len(parameter_tasks)} PARAMETER-ITERATING scan sub-tasks for {original_url}.")
            try:
                await asyncio.gather(*parameter_tasks, return_exceptions=True)
            except Exception as e_gather_param:
                self.logger.error(f"[{worker_ident}] Error during asyncio.gather for parameter tasks on {original_url}: {e_gather_param}", exc_info=True)
        else:
            self.logger.info(f"[{worker_ident}] No parameter-iterating scan sub-tasks scheduled for {original_url}.")

        self.logger.info(f"[{worker_ident}] All parameter-based active scans for {original_url} completed or scheduled.")


    async def perform_url_based_active_scans(self,
                                           original_url: str,
                                           headers: Dict[str, str],
                                           cookies: Dict[str, str],
                                           worker_ident: str,
                                           page_specific_technologies: Optional[List[str]] = None,
                                           html_content: Optional[str] = None, 
                                           passive_scan_hints: Optional[List[Dict[str, Any]]] = None
                                           ) -> None:
        self.logger.info(f"[{worker_ident}] Starting URL/SERVER-BASED and PAGE-LEVEL active scans for: {original_url}")
        
        current_page_techs_lower: Set[str] = {str(tech).lower() for tech in (page_specific_technologies or [])}
        page_level_service_hints_from_passive: Set[str] = set()
        page_level_specific_passive_hint_types: Set[str] = set() # Store specific hint types for conditions

        if passive_scan_hints:
            for hint in passive_scan_hints:
                if not hint.get("affected_parameter_name") and hint.get("specific_passive_hint_type"): # Page-level hint
                    specific_hint_type = hint["specific_passive_hint_type"]
                    page_level_specific_passive_hint_types.add(specific_hint_type)
                    derived_service_hint = self._get_service_type_hint_from_passive(specific_hint_type)
                    if derived_service_hint:
                        page_level_service_hints_from_passive.add(derived_service_hint)
        
        effective_techs_for_url = current_page_techs_lower.union(page_level_service_hints_from_passive)
        base_app_url = self._derive_base_app_url(original_url)

        available_scan_args = {
            "base_app_url": base_app_url, "original_url": original_url, "html_content": html_content,
            "original_headers": headers, "original_cookies": cookies, "aiohttp_session": self.aiohttp_session,
            "worker_ident": worker_ident, "page_specific_technologies": list(effective_techs_for_url),
            "injection_details": None, "service_type_hint": None, "is_admin_context": False,
            "attack_strength": "MEDIUM", 
            "original_page_content_for_baseline_errors": html_content,
            "passive_scan_hints": passive_scan_hints # Pass all hints for rules that might need them
        }

        url_based_tasks = []
        scanners_for_url_checks = []

        # Add specific URL/Page-level scanners
        for scanner in self.specific_scanners:
            if isinstance(scanner, (ApacheTomcatScanRule, AmazonWebServicesScanRule, JQueryScanRule, ASPNetScanRule, BitrixActiveScanRule)):
                 if hasattr(scanner, 'tech_required') and scanner.tech_required.intersection(effective_techs_for_url):
                    if scanner not in scanners_for_url_checks: scanners_for_url_checks.append(scanner)
        
        # Add agnostic URL/Page-level scanners
        for scanner in self.agnostic_scanners:
            if isinstance(scanner, (WAFFuzzScanRule)): # WAFFuzz is URL-based
                if scanner not in scanners_for_url_checks:
                    scanners_for_url_checks.append(scanner)
            
            if isinstance(scanner, XFF403BypassScanRule): # XFF Bypass is URL-specific, triggered by hint
                if "HTTP_403_FORBIDDEN_PAGE_DETECTED" in page_level_specific_passive_hint_types:
                    # Ensure this hint is for the *current* original_url
                    is_403_for_current_url = False
                    if passive_scan_hints:
                        for hint_item in passive_scan_hints:
                            if hint_item.get("specific_passive_hint_type") == "HTTP_403_FORBIDDEN_PAGE_DETECTED" and \
                               hint_item.get("url_tested") == original_url:
                                is_403_for_current_url = True
                                break
                    if is_403_for_current_url:
                        if scanner not in scanners_for_url_checks:
                            self.logger.info(f"[{worker_ident}] Adding XFF403BypassScanRule for {original_url} due to HTTP_403_FORBIDDEN_PAGE_DETECTED hint.")
                            scanners_for_url_checks.append(scanner)
        
        self.logger.info(f"[{worker_ident}] URL-based: {len(scanners_for_url_checks)} scanners potentially running for {original_url} (Effective Techs: {effective_techs_for_url}, Page Hints: {page_level_specific_passive_hint_types})")

        for scanner in scanners_for_url_checks:
            current_scanner_args = available_scan_args.copy()
            
            service_hint_for_scanner = None
            if hasattr(scanner, 'tech_required') and scanner.tech_required:
                matching_techs = scanner.tech_required.intersection(effective_techs_for_url)
                if matching_techs:
                    service_hint_for_scanner = list(matching_techs)[0] 
            current_scanner_args["service_type_hint"] = service_hint_for_scanner
            if service_hint_for_scanner:
                 self.logger.debug(f"[{worker_ident}] Providing service_type_hint='{service_hint_for_scanner}' to {type(scanner).__name__} for URL-based scan on {original_url}.")

            if isinstance(scanner, AmazonWebServicesScanRule) and not service_hint_for_scanner:
                host = urlparse(original_url).hostname
                if host:
                    if ".s3.amazonaws.com" in host or ".s3-website" in host or host.startswith("s3."): current_scanner_args["service_type_hint"] = "s3"
                    elif ".es.amazonaws.com" in host or ".opensearchservice.amazonaws.com" in host: current_scanner_args["service_type_hint"] = "es"
                    elif "ec2" in host or re.match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", host): current_scanner_args["service_type_hint"] = "ec2"
                if current_scanner_args["service_type_hint"]:
                    self.logger.debug(f"[{worker_ident}] AWSScan inferred hint: {current_scanner_args['service_type_hint']} for {original_url}")

            url_based_tasks.append(self._execute_scanner_safely(scanner, "scan", current_scanner_args, worker_ident, original_url))

        if url_based_tasks:
            self.logger.info(f"[{worker_ident}] Scheduling {len(url_based_tasks)} URL/SERVER/PAGE-BASED active scan sub-tasks for {original_url}.")
            try:
                await asyncio.gather(*url_based_tasks, return_exceptions=True)
            except Exception as e_gather_url:
                self.logger.error(f"[{worker_ident}] Error during asyncio.gather for URL-based tasks on {original_url}: {e_gather_url}", exc_info=True)
        else:
            self.logger.info(f"[{worker_ident}] No URL/SERVER/PAGE-BASED active scan sub-tasks scheduled for {original_url}.")

        self.logger.info(f"[{worker_ident}] URL/SERVER/PAGE-BASED active scans for {original_url} completed or scheduled.")